/*
 * Copyright 2018, Amazon.com, Inc. or its affiliates. All Rights Reserved
 */

/**
 *  @{
 * @file   al_hal_nb_regs.h
 *
 * @brief nb registers
 *
 * This file was auto-generated by RegGen v1.2.1
 *
 */

#ifndef __AL_HAL_NB_REGS_H__
#define __AL_HAL_NB_REGS_H__

#include "al_hal_plat_types.h"

#ifdef __cplusplus
extern "C" {
#endif

/*
 * Unit Registers
 */

struct al_nb_global {
	/*
	 * [0x0] Allow non-secure access to secure registers.
	 * Each bit disables security for one register
	 * Reset: 0x0         Access: RW
	 */
	uint32_t sec_ovrd_low;
	/*
	 * [0x4] Allow non-secure access to secure registers.
	 * Each bit disables security for one register
	 * Reset: 0x0         Access: RW
	 */
	uint32_t sec_ovrd_high;
	/* [0x8] */
	uint32_t cpus_secure;
	/* [0xc] */
	uint32_t rsrvd_0[12];
	/* [0x3c] */
	uint32_t fabric_software_reset;
	/* [0x40] */
	uint32_t rsrvd_1[8];
	/* [0x60] */
	uint32_t acf_base_high;
	/* [0x64] */
	uint32_t acf_base_low;
	/* [0x68] */
	uint32_t acf_control_override;
	/* [0x6c] Read-only that reflects CPU Cluster Local GIC base high address */
	uint32_t lgic_base_high;
	/* [0x70] Read-only that reflects CPU Cluster Local GIC base low address */
	uint32_t lgic_base_low;
	/* [0x74] */
	uint32_t rsrvd_2[4];
	/* [0x84] */
	uint32_t sb_pos_error_log_1;
	/*
	 * [0x88] Error Log 0
	 * [31:0] address_low
	 * Reset: 0x0         Access: RO
	 */
	uint32_t sb_pos_error_log_0;
	/* [0x8c] */
	uint32_t c2swb_config;
	/* [0x90] */
	uint32_t msix_error_log;
	/* [0x94] */
	uint32_t rsrvd_3[15];
	/* [0xd0] */
	uint32_t acf_misc;
	/* [0xd4] */
	uint32_t config_bus_control;
	/* [0xd8] */
	uint32_t rsrvd_4[2];
	/* [0xe0] */
	uint32_t pos_id_match;
	/* [0xe4] */
	uint32_t rsrvd_5[3];
	/* [0xf0] */
	uint32_t sb_sel_override_awuser;
	/* [0xf4] */
	uint32_t sb_override_awuser;
	/* [0xf8] */
	uint32_t sb_sel_override_aruser;
	/* [0xfc] */
	uint32_t sb_override_aruser;
	/* [0x100] */
	uint32_t rsrvd_6[4];
	/* [0x110] */
	uint32_t wr_mixer;
	/* [0x114] */
	uint32_t rd_mixer;
	/* [0x118] */
	uint32_t rsrvd_7[58];
};

struct al_nb_acf {
	/* [0x0] */
	uint32_t pwr;
	/* [0x4] */
	uint32_t misc;
	/* [0x8] */
	uint32_t rsrvd_0[2];
	/* [0x10] */
	uint32_t iocache;
	/* [0x14] */
	uint32_t rsrvd_1[3];
	/* [0x20] */
	uint32_t hash_0_low;
	/* [0x24] */
	uint32_t hash_0_high;
	/* [0x28] */
	uint32_t hash_1_low;
	/* [0x2c] */
	uint32_t hash_1_high;
	/* [0x30] */
	uint32_t hash_2_low;
	/* [0x34] */
	uint32_t hash_2_high;
	/* [0x38] */
	uint32_t rsrvd_2[50];
	/* [0x100] */
	uint32_t sport0_qos;
	/* [0x104] */
	uint32_t rsrvd_3[3];
	/* [0x110] */
	uint32_t sport1_qos;
	/* [0x114] */
	uint32_t rsrvd_4[3];
	/* [0x120] */
	uint32_t sport2_qos;
	/* [0x124] */
	uint32_t rsrvd_5[3];
	/* [0x130] */
	uint32_t sport3_qos;
	/* [0x134] */
	uint32_t rsrvd_6[3];
	/* [0x140] */
	uint32_t sport4_qos;
	/* [0x144] */
	uint32_t rsrvd_7[3];
	/* [0x150] */
	uint32_t sport5_qos;
	/* [0x154] */
	uint32_t rsrvd_8[3];
	/* [0x160] */
	uint32_t sport6_qos;
	/* [0x164] */
	uint32_t rsrvd_9[15];
	/* [0x1a0] */
	uint32_t mport0_qos;
	/* [0x1a4] */
	uint32_t rsrvd_10[23];
};

struct al_nb_coresight {
	/* [0x0] */
	uint32_t pd;
	/* [0x4] */
	uint32_t ctm;
	/* [0x8] */
	uint32_t dbgromaddr;
	/* [0xc] */
	uint32_t rsrvd_0;
	/*
	 * [0x10] [31:28] Peripheral ID2 [7:4]
	 * [27:24] Peripheral ID1 [3:0]
	 * [23:16] Peripheral ID0 [7:0]
	 * [15:12] Drive LOW
	 * [11:8] Peripheral ID4 [3:0]
	 * [7:5] Peripheral ID2 [2:0]
	 * [4:1] Peripheral ID1 [7:4]
	 * [0] Drive HIGH
	 * Reset: 0x29080877  Access: RW
	 */
	uint32_t targetid;
	/*
	 * [0x14] Internal
	 * Reset: 0x29080877  Access: RW
	 */
	uint32_t targetid0;
	/* [0x18] */
	uint32_t cti_0;
	/* [0x1c] */
	uint32_t cti_1;
	/* [0x20] */
	uint32_t stm;
	/* [0x24] */
	uint32_t rom;
	/* [0x28] */
	uint32_t rsrvd_1[2];
	/*
	 * [0x30] DAP APB AP ROM base address
	 * Reset: 0x80000003  Access: RW
	 */
	uint32_t dapapbap;
	/*
	 * [0x34] DAP AXI AP ROM base address [31:0]
	 * Reset: 0x2         Access: RW
	 */
	uint32_t dapaxiap0;
	/*
	 * [0x38] DAP AXI AP ROM base address [63:32]
	 * Reset: 0x0         Access: RW
	 */
	uint32_t dapaxiap1;
	/* [0x3c] */
	uint32_t rsrvd_2[49];
};

struct al_nb_vgic {
	/* [0x0] */
	uint32_t allowed_cores;
	/* [0x4] */
	uint32_t rsrvd_0;
};

struct al_nb_sb2nb_port {
	/* [0x0] */
	uint32_t wr_split_control;
	/* [0x4] */
	uint32_t rsrvd_0;
	/* [0x8] */
	uint32_t rd_rob_control;
	/* [0xc] */
	uint32_t rsrvd_1;
	/* [0x10] */
	uint32_t iommu_cfg;
	/* [0x14] */
	uint32_t iommu_axaddr_l;
	/* [0x18] */
	uint32_t iommu_axaddr_h;
	/* [0x1c] */
	uint32_t rsrvd_2;
	/* [0x20] */
	uint32_t force_same_id_mask_0;
	/* [0x24] */
	uint32_t force_same_id_value_0;
	/* [0x28] */
	uint32_t force_same_id_mask_1;
	/* [0x2c] */
	uint32_t force_same_id_value_1;
	/* [0x30] */
	uint32_t power;
	/* [0x34] */
	uint32_t rsrvd_3[3];
	/* [0x40] */
	uint32_t attr_sel_cache_hit;
	/* [0x44] */
	uint32_t attr_sel_cache_pad;
	/* [0x48] */
	uint32_t attr_sel_force_order;
	/* [0x4c] */
	uint32_t attr_sel_force_order_group;
	/* [0x50] */
	uint32_t attr_sel_tml_hit;
	/* [0x54] */
	uint32_t attr_sel_tdl_hit;
	/* [0x58] */
	uint32_t attr_sel_tml_target;
	/* [0x5c] */
	uint32_t attr_sel_logger_attr_l;
	/* [0x60] */
	uint32_t attr_sel_logger_attr_h;
	/* [0x64] */
	uint32_t attr_sel_iommu_bypass;
	/* [0x68] */
	uint32_t attr_sel_iommu_context;
	/* [0x6c] */
	uint32_t rsrvd_4;
	/* [0x70] */
	uint32_t attr_sel_cache_hit_rd;
	/* [0x74] */
	uint32_t attr_sel_cache_alloc;
	/* [0x78] */
	uint32_t rsrvd_5[2];
};

struct al_nb_system_counter {
	/* [0x0] */
	uint32_t cnt_control;
	/*
	 * [0x4] Counter base frequency
	 * Programs this register to match the counter frequency in ticks per second.
	 * Software information only register
	 * Reset: 0x0         Access: RW
	 */
	uint32_t cnt_base_freq;
	/*
	 * [0x8] Counter count low
	 * Reset: 0x0         Access: RO
	 */
	uint32_t cnt_low;
	/*
	 * [0xc] Counter count high
	 * Reset: 0x0         Access: RO
	 */
	uint32_t cnt_high;
	/*
	 * [0x10] Counter init low
	 * Reset: 0x0         Access: RW
	 */
	uint32_t cnt_init_low;
	/*
	 * [0x14] Counter init high
	 * Reset: 0x0         Access: RW
	 */
	uint32_t cnt_init_high;
	/* [0x18] */
	uint32_t rsrvd_0[58];
};

struct al_nb_pwr_ctl {
	/* [0x0] */
	uint32_t rsrvd_0[2];
	/* [0x8] */
	uint32_t ram;
	/* [0xc] */
	uint32_t rsrvd_1;
	/* [0x10] */
	uint32_t clocks;
	/* [0x14] */
	uint32_t rsrvd_2[59];
};

struct al_nb_semaphores {
	/* [0x0] This configuration is only sampled during reset of the processor */
	uint32_t lockn;
};

struct al_nb_debug {
	/* [0x0] */
	uint32_t rsrvd_0[8];
	/*
	 * [0x20] For ECO
	 * Bits [7:0] - poison parity of snoop filter RAM. Bit per RAM bank
	 * Reset: 0x0         Access: RW
	 */
	uint32_t rsv0;
	/*
	 * [0x24] For ECO
	 * Reset: 0x0         Access: RW
	 */
	uint32_t rsv1;
	/* [0x28] */
	uint32_t rsrvd_1[2];
	/*
	 * [0x30] For ECO
	 * Bit 0 - When set, enable CCI SF to move into broadcast mode on parity error
	 * Reset: 0xffffffff  Access: RW
	 */
	uint32_t rsv2;
	/*
	 * [0x34] For ECO
	 * Reset: 0xffffffff  Access: RW
	 */
	uint32_t rsv3;
	/* [0x38] */
	uint32_t rsrvd_2[50];
	/* [0x100] */
	uint32_t track_dump_ctrl;
	/* [0x104] */
	uint32_t track_dump_rdata_0;
	/*
	 * [0x108] High data
	 * Reset: 0x0         Access: RO
	 */
	uint32_t track_dump_rdata_1;
	/* [0x10c] */
	uint32_t rsrvd_3[6];
	/* [0x124] */
	uint32_t buffers_empty;
	/* [0x128] */
	uint32_t rsrvd_4[2];
	/* [0x130] */
	uint32_t pos_track_dump_ctrl;
	/* [0x134] */
	uint32_t pos_track_dump_rdata_0;
	/*
	 * [0x138] High data
	 * Reset: 0x0         Access: RO
	 */
	uint32_t pos_track_dump_rdata_1;
	/* [0x13c] */
	uint32_t rsrvd_5;
	/* [0x140] */
	uint32_t c2swb_track_dump_ctrl;
	/* [0x144] */
	uint32_t c2swb_track_dump_rdata_0;
	/*
	 * [0x148] High data
	 * Reset: 0x0         Access: RO
	 */
	uint32_t c2swb_track_dump_rdata_1;
	/* [0x14c] */
	uint32_t rsrvd_6[13];
	/* [0x180] */
	uint32_t pmu;
	/* [0x184] */
	uint32_t pmu_sec;
	/* [0x188] */
	uint32_t rsrvd_7[30];
};

struct al_nb_sb_int_out {
	/* [0x0] */
	uint32_t conf;
	/* [0x4] */
	uint32_t rsrvd_0[3];
};

struct al_nb_nb_version {
	/* [0x0] Northbridge Revision */
	uint32_t version;
	/* [0x4] */
	uint32_t rsrvd_0;
};

struct al_nb_push_packet {
	/* [0x0] */
	uint32_t pp_config;
	/* [0x4] */
	uint32_t rsrvd_0[3];
	/* [0x10] */
	uint32_t pp_ext_attr;
	/* [0x14] */
	uint32_t rsrvd_1[3];
	/*
	 * [0x20] PP window base low address bits
	 * Reset: 0x0         Access: RW
	 */
	uint32_t pp_base_low;
	/*
	 * [0x24] PP window base high address bits
	 * Reset: 0x0         Access: RW
	 */
	uint32_t pp_base_high;
	/* [0x28] */
	uint32_t rsrvd_2[2];
	/* [0x30] */
	uint32_t pp_sel_attr;
	/* [0x34] */
	uint32_t pp_err_log;
	/* [0x38] */
	uint32_t rsrvd_3[50];
};

struct al_nb_push_packet_channel {
	/* [0x0] */
	uint32_t cfg;
	/* [0x4] */
	uint32_t rsrvd_0[3];
};

struct al_nb_address_map {
	/* [0x0] PASW low */
	uint32_t ddr_cpu_bar0_low;
	/* [0x4] PASW high */
	uint32_t ddr_cpu_bar0_high;
	/* [0x8] PASW low */
	uint32_t ddr_cpu_bar1_low;
	/* [0xc] PASW high */
	uint32_t ddr_cpu_bar1_high;
	/* [0x10] PASW low */
	uint32_t ddr_cpu_bar2_low;
	/* [0x14] PASW high */
	uint32_t ddr_cpu_bar2_high;
	/* [0x18] PASW low */
	uint32_t ddr_cpu_bar3_low;
	/* [0x1c] PASW high */
	uint32_t ddr_cpu_bar3_high;
	/* [0x20] PASW low */
	uint32_t ddr_cpu_bar4_low;
	/* [0x24] PASW high */
	uint32_t ddr_cpu_bar4_high;
	/* [0x28] PASW low */
	uint32_t ddr_cpu_bar5_low;
	/* [0x2c] PASW high */
	uint32_t ddr_cpu_bar5_high;
	/* [0x30] */
	uint32_t rsrvd_0[4];
	/* [0x40] PASW low */
	uint32_t ddr_io_bar0_low;
	/* [0x44] PASW high */
	uint32_t ddr_io_bar0_high;
	/* [0x48] PASW low */
	uint32_t ddr_io_bar1_low;
	/* [0x4c] PASW high */
	uint32_t ddr_io_bar1_high;
	/* [0x50] PASW low */
	uint32_t ddr_io_bar2_low;
	/* [0x54] PASW high */
	uint32_t ddr_io_bar2_high;
	/* [0x58] PASW low */
	uint32_t ddr_io_bar3_low;
	/* [0x5c] PASW high */
	uint32_t ddr_io_bar3_high;
	/* [0x60] PASW low */
	uint32_t ddr_io_bar4_low;
	/* [0x64] PASW high */
	uint32_t ddr_io_bar4_high;
	/* [0x68] PASW low */
	uint32_t ddr_io_bar5_low;
	/* [0x6c] PASW high */
	uint32_t ddr_io_bar5_high;
	/* [0x70] */
	uint32_t rsrvd_1[4];
	/* [0x80] PASW low */
	uint32_t msix_bar_low;
	/* [0x84] PASW high */
	uint32_t msix_bar_high;
	/* [0x88] */
	uint32_t rsrvd_2[2];
	/* [0x90] PASW remap register */
	uint32_t dram_remap;
	/* [0x94] */
	uint32_t rsrvd_3[27];
	/* [0x100] */
	uint32_t config;
	/* [0x104] */
	uint32_t latch_bars;
	/* [0x108] */
	uint32_t rsrvd_4[62];
};

struct al_nb_regs {
	/* [0x0] */
	struct al_nb_global global;
	/* [0x200] */
	struct al_nb_acf acf;
	/* [0x400] */
	struct al_nb_coresight coresight;
	/* [0x500] */
	uint32_t rsrvd_0[64];
	/* [0x600] */
	struct al_nb_vgic vgic[16];
	/* [0x680] */
	uint32_t rsrvd_1[96];
	/* [0x800] */
	struct al_nb_sb2nb_port sb2nb_port[4];
	/* [0xa00] */
	uint32_t rsrvd_2[384];
	/* [0x1000] */
	struct al_nb_system_counter system_counter;
	/* [0x1100] */
	struct al_nb_pwr_ctl pwr_ctl;
	/* [0x1200] */
	uint32_t rsrvd_3[128];
	/* [0x1400] */
	struct al_nb_semaphores semaphores[64];
	/* [0x1500] */
	uint32_t rsrvd_4[320];
	/* [0x1a00] */
	struct al_nb_debug debug;
	/* [0x1c00] */
	struct al_nb_sb_int_out sb_int_out[10];
	/* [0x1ca0] */
	uint32_t rsrvd_5[1240];
	/* [0x3000] */
	uint32_t error_intc[16];
	/* [0x3040] */
	uint32_t rsrvd_6[48];
	/* [0x3100] */
	uint32_t pmu_intc[16];
	/* [0x3140] */
	uint32_t rsrvd_7[48];
	/* [0x3200] */
	uint32_t coresight_intc[16];
	/* [0x3240] */
	uint32_t rsrvd_8[48];
	/* [0x3300] */
	uint32_t iommu_intc[32];
	/* [0x3380] */
	uint32_t rsrvd_9[32];
	/* [0x3400] */
	uint32_t external_intc_0[64];
	/* [0x3500] */
	uint32_t external_intc_1[64];
	/* [0x3600] */
	uint32_t nmi_intc[32];
	/* [0x3680] */
	uint32_t rsrvd_10[864];
	/* [0x4400] */
	struct al_nb_nb_version nb_version;
	/* [0x4408] */
	uint32_t rsrvd_11[1790];
	/* [0x6000] */
	struct al_nb_push_packet push_packet;
	/* [0x6100] */
	uint32_t rsrvd_12[64];
	/* [0x6200] */
	struct al_nb_push_packet_channel push_packet_channel[8];
	/* [0x6280] */
	uint32_t rsrvd_13[864];
	/* [0x7000] */
	struct al_nb_address_map address_map;
	/* [0x7200] */
	uint32_t rsrvd_14[896];
	/* [0x8000] */
	uint32_t pmu[4096];
	/* [0xc000] */
	uint32_t rsrvd_15[4096];
};


/*
 * Registers Fields
 */

/**** cpus_secure register ****/
/*
 * DBGEN
 * Reset: 0x0         Access: RW
 */
#define NB_GLOBAL_CPUS_SECURE_DBGEN      (1 << 0)
/*
 * NIDEN
 * Reset: 0x0         Access: RW
 */
#define NB_GLOBAL_CPUS_SECURE_NIDEN      (1 << 1)
/*
 * SPIDEN
 * Reset: 0x0         Access: RW
 */
#define NB_GLOBAL_CPUS_SECURE_SPIDEN     (1 << 2)
/*
 * SPNIDEN
 * Reset: 0x0         Access: RW
 */
#define NB_GLOBAL_CPUS_SECURE_SPNIDEN    (1 << 3)

/**** fabric_software_reset register ****/
/*
 * Write 1 apply the software reset.
 * Reset: 0x0         Access: WO
 */
#define NB_GLOBAL_FABRIC_SOFTWARE_RESET_SWRESET_REQ (1 << 0)
/*
 * Defines the level of software reset:
 * 0x0 -  fabric: Fabric reset
 * 0x1 - gic: GIC reset
 * 0x2 - smmu: SMMU reset
 * Reset: 0x0         Access: WO
 */
#define NB_GLOBAL_FABRIC_SOFTWARE_RESET_LEVEL_MASK 0x0000000E
#define NB_GLOBAL_FABRIC_SOFTWARE_RESET_LEVEL_SHIFT 1
/*
 * CPUn waiting for interrupt enable.
 * Defines which CPU WFI indication to wait before applying the software reset.
 * Reset: 0x0         Access: WO
 */
#define NB_GLOBAL_FABRIC_SOFTWARE_RESET_WFI_MASK_MASK 0x000F0000
#define NB_GLOBAL_FABRIC_SOFTWARE_RESET_WFI_MASK_SHIFT 16

/**** acf_base_high register ****/
/*
 * Coherency Fabric registers base [39:32].
 * Reset: 0x0         Access: RO
 */
#define NB_GLOBAL_ACF_BASE_HIGH_BASE_39_32_MASK 0x000000FF
#define NB_GLOBAL_ACF_BASE_HIGH_BASE_39_32_SHIFT 0

/**** acf_base_low register ****/
/*
 * Coherency Fabric registers base [31:15]
 * Reset: 0x0         Access: RO
 */
#define NB_GLOBAL_ACF_BASE_LOW_BASED_31_15_MASK 0xFFFF8000
#define NB_GLOBAL_ACF_BASE_LOW_BASED_31_15_SHIFT 15

/**** acf_control_override register ****/
/*
 * Overrides the ARQOS and AWQOS input signals. One bit exists for each slave
 * interface.
 * Connected to QOSOVERRIDE[6:0]
 * Reset: 0x0         Access: RW
 */
#define NB_GLOBAL_ACF_CONTROL_OVERRIDE_QOSOVRD_MASK 0x0000007F
#define NB_GLOBAL_ACF_CONTROL_OVERRIDE_QOSOVRD_SHIFT 0
/*
 * If LOW, then AC requests are never issued on the corresponding slave
 * interface. One bit exists for each slave interface.
 * Connected to ACCHANNELEN[6:0].
 * Reset: 0x7f        Access: RW
 */
#define NB_GLOBAL_ACF_CONTROL_OVERRIDE_ACE_CH_EN_MASK 0x00007F00
#define NB_GLOBAL_ACF_CONTROL_OVERRIDE_ACE_CH_EN_SHIFT 8
/*
 * If HIGH, then the corresponding slave interface will support the ordered write observation
 * property. Required for ports connected to PCIe.
 * Reset: 0x7         Access: RW
 */
#define NB_GLOBAL_ACF_CONTROL_OVERRIDE_ORDERED_WRITE_OBSERVATION_MASK 0x007F0000
#define NB_GLOBAL_ACF_CONTROL_OVERRIDE_ORDERED_WRITE_OBSERVATION_SHIFT 16
/*
 * If HIGH, indicates that this master interface is connected to a component with both slave and
 * master interfaces, where there is a dependency between them.
 * Reset: 0x1         Access: RW
 */
#define NB_GLOBAL_ACF_CONTROL_OVERRIDE_MI_DEPENDENT_ON_SI_MASK 0x07000000
#define NB_GLOBAL_ACF_CONTROL_OVERRIDE_MI_DEPENDENT_ON_SI_SHIFT 24
/*
 * If HIGH, all incoming requests are split into 64-byte transfers, rather than shareable requests
 * only.
 * This signal has no effect currently.
 * Reset: 0x0         Access: RW
 */
#define NB_GLOBAL_ACF_CONTROL_OVERRIDE_BURST_SPLIT_MASK 0x70000000
#define NB_GLOBAL_ACF_CONTROL_OVERRIDE_BURST_SPLIT_SHIFT 28

/**** lgic_base_high register ****/
/*
 * GIC registers base [39:32].
 * This value is sampled into the CP15 Configuration Base Address Register (CBAR) at reset.
 * Reset: 0x0         Access: RO
 */
#define NB_GLOBAL_LGIC_BASE_HIGH_BASE_43_32_MASK 0x00000FFF
#define NB_GLOBAL_LGIC_BASE_HIGH_BASE_43_32_SHIFT 0

/**** lgic_base_low register ****/
/*
 * GIC registers base [31:15].
 * This value is sampled into the CP15 Configuration Base Address Register (CBAR) at reset
 * Reset: 0x0         Access: RO
 */
#define NB_GLOBAL_LGIC_BASE_LOW_BASED_31_15_MASK 0xFFFF8000
#define NB_GLOBAL_LGIC_BASE_LOW_BASED_31_15_SHIFT 15

/**** sb_pos_error_log_1 register ****/
/*
 * Error Log 1
 * [7:0] address_high
 * [16:8] request id
 * [18:17] bresp
 * Reset: 0x0         Access: RO
 */
#define NB_GLOBAL_SB_POS_ERROR_LOG_1_ERR_LOG_MASK 0x7FFFFFFF
#define NB_GLOBAL_SB_POS_ERROR_LOG_1_ERR_LOG_SHIFT 0
/*
 * Valid logged error
 * Set on SB PoS error occurrence on capturing the error information. Subsequent errors will not be
 * captured until the valid bit is cleared.
 * The SB PoS reports on write errors.
 * When valid, an interrupt is set in the NB Cause Register.
 * Reset: 0x0         Access: RW, RtoClr
 */
#define NB_GLOBAL_SB_POS_ERROR_LOG_1_VALID (1 << 31)

/**** c2swb_config register ****/
/*
 * Write buffer bypass
 * Reset: 0x0         Access: RW
 */
#define NB_GLOBAL_C2SWB_CONFIG_BYPASS    (1 << 4)
/*
 * Write buffer enable
 * Reset: 0x1         Access: RW
 */
#define NB_GLOBAL_C2SWB_CONFIG_ENABLE    (1 << 5)
/*
 * Disable counter (wait 1000 NB cycles) before applying Write buffer enable/bypass configuration
 * Reset: 0x0         Access: RW
 */
#define NB_GLOBAL_C2SWB_CONFIG_CFG_CNT_DIS (1 << 6)
/*
 * Power down Write Buffer memory
 * Reset: 0x0         Access: RW
 */
#define NB_GLOBAL_C2SWB_CONFIG_RAM_PD    (1 << 31)

/**** msix_error_log register ****/
/*
 * Error Log
 * Corresponds to MSIx address message [30:0].
 * Reset: 0x0         Access: RO
 */
#define NB_GLOBAL_MSIX_ERROR_LOG_ERR_LOG_MASK 0x7FFFFFFF
#define NB_GLOBAL_MSIX_ERROR_LOG_ERR_LOG_SHIFT 0
/*
 * Valid logged error
 * Reset: 0x0         Access: RW, RtoClr
 */
#define NB_GLOBAL_MSIX_ERROR_LOG_VALID   (1 << 31)

/**** acf_misc register ****/
/*
 * Disable SB-2-SB path through NB fabric.
 * Reset: 0x1         Access: RW
 */
#define NB_GLOBAL_ACF_MISC_SB2SB_PATH_DIS (1 << 1)
/*
 * Disable ETR tracing to non-DDR.
 * Reset: 0x0         Access: RW
 */
#define NB_GLOBAL_ACF_MISC_ETR2SB_PATH_DIS (1 << 2)
/*
 * Disable CPU generation of MSIx
 * By default, the CPU can set any MSIx message results by setting any SPIn bit in the local and
 * IO-GIC.
 * Reset: 0x0         Access: RW
 */
#define NB_GLOBAL_ACF_MISC_CPU2MSIX_DIS  (1 << 3)
/*
 * Disable MSIx termination.
 * By Default, an MSIx transaction is terminated and not written to memory
 * Reset: 0x0         Access: RW
 */
#define NB_GLOBAL_ACF_MISC_MSIX_TERMINATE_DIS (1 << 4)
/*
 * Disable snoop override for MSIx
 * By default, an MSIx transaction is downgraded to non-coherent.
 * Reset: 0x0         Access: RW
 */
#define NB_GLOBAL_ACF_MISC_MSIX_SNOOPOVRD_DIS (1 << 5)
/*
 * POS bypass
 * Reset: 0x0         Access: RW
 */
#define NB_GLOBAL_ACF_MISC_POS_BYPASS    (1 << 6)
/*
 * PoS ReadStronglyOrdered enable
 * SO read forces flushing of all prior writes
 * Reset: 0x0         Access: RW
 */
#define NB_GLOBAL_ACF_MISC_POS_RSO_EN    (1 << 7)
/*
 * WRAP to INC transfer enable
 * Reset: 0x1         Access: RW
 */
#define NB_GLOBAL_ACF_MISC_POS_WRAP2INC  (1 << 8)
/*
 * PoS DSB flush Disable
 * On DSB from CPU, PoS blocks the progress of post-barrier reads and writes until all pre-barrier
 * writes have been completed.
 * Reset: 0x0         Access: RW
 */
#define NB_GLOBAL_ACF_MISC_POS_DSB_FLUSH_DIS (1 << 9)
/*
 * PoS DMB Flush Disable
 * On DMB from CPU, the PoS blocks the progress of post-barrier non-buffereable reads or writes when
 * there are outstanding non-bufferable writes that have not yet been completed.
 * Other access types are  hazard check against the pre-barrier requests.
 * Reset: 0x0         Access: RW
 */
#define NB_GLOBAL_ACF_MISC_POS_DMB_FLUSH_DIS (1 << 10)
/*
 * change DMB functionality to DSB (block and drain)
 * Reset: 0x0         Access: RW
 */
#define NB_GLOBAL_ACF_MISC_POS_DMB_TO_DSB_EN (1 << 11)
/*
 * Disable counter (wait 1000 NB cycles) before applying PoS enable/disable configuration
 * Reset: 0x0         Access: RW
 */
#define NB_GLOBAL_ACF_MISC_POS_CONFIG_CNT_DIS (1 << 14)
/*
 * Disable IO MMU page table walk to non-DDR.
 * Reset: 0x0         Access: RW
 */
#define NB_GLOBAL_ACF_MISC_IOMMU_PTW2SB_PATH_DIS (1 << 15)
/*
 * Override the address parity calucation for write transactions going to IO-fabric
 * Reset: 0x0         Access: RW
 */
#define NB_GLOBAL_ACF_MISC_NB_NIC_AWADDR_PAR_OVRD (1 << 18)
/*
 * Override the data parity calucation for write transactions going to IO-fabric
 * Reset: 0x0         Access: RW
 */
#define NB_GLOBAL_ACF_MISC_NB_NIC_WDATA_PAR_OVRD (1 << 19)
/*
 * Override the address parity calucation for read transactions going to IO-fabric
 * Reset: 0x0         Access: RW
 */
#define NB_GLOBAL_ACF_MISC_NB_NIC_ARADDR_PAR_OVRD (1 << 20)
/*
 * Halts CPU AXI interface (Ar/Aw channels), not allowing the CPU to send additional transactions
 * Reset: 0x0         Access: RW
 */
#define NB_GLOBAL_ACF_MISC_CPU_AXI_HALT  (1 << 23)
/*
 * Enable DMB flush request to NB to SB PoS when barrier is terminted inside the processor cluster
 * Reset: 0x0         Access: RW
 */
#define NB_GLOBAL_ACF_MISC_CPU_DSB_FLUSH_DIS (1 << 26)
/*
 * Enable DMB flush request to NB to SB PoS when barrier is terminted inside the processor cluster
 * Reset: 0x0         Access: RW
 */
#define NB_GLOBAL_ACF_MISC_CPU_DMB_FLUSH_DIS (1 << 27)
/*
 * Enable CPU WriteUnique to WriteNoSnoop trasform
 * Reset: 0x0         Access: RW
 */
#define NB_GLOBAL_ACF_MISC_CPU_WU2WNS_EN (1 << 29)
/*
 * Disable device after device check
 * Reset: 0x0         Access: RW
 */
#define NB_GLOBAL_ACF_MISC_WR_POS_DEV_AFTER_DEV_DIS (1 << 30)
/*
 * Disable wrap to inc on write
 * Reset: 0x0         Access: RW
 */
#define NB_GLOBAL_ACF_MISC_WR_INC2WRAP_EN (1 << 31)

/**** config_bus_control register ****/
/*
 * Write slave error enable
 * Reset: 0x1         Access: RW
 */
#define NB_GLOBAL_CONFIG_BUS_CONTROL_WR_SLV_ERR_EN (1 << 0)
/*
 * Write decode error enable
 * Reset: 0x1         Access: RW
 */
#define NB_GLOBAL_CONFIG_BUS_CONTROL_WR_DEC_ERR_EN (1 << 1)
/*
 * Read slave error enable
 * Reset: 0x1         Access: RW
 */
#define NB_GLOBAL_CONFIG_BUS_CONTROL_RD_SLV_ERR_EN (1 << 2)
/*
 * Read decode error enable
 * Reset: 0x1         Access: RW
 */
#define NB_GLOBAL_CONFIG_BUS_CONTROL_RD_DEC_ERR_EN (1 << 3)
/*
 * Ignore Write ID
 * Reset: 0x0         Access: RW
 */
#define NB_GLOBAL_CONFIG_BUS_CONTROL_IGNORE_WR_ID (1 << 4)
/*
 * Weight number of reads per one write
 * Reset: 0x3         Access: RW
 */
#define NB_GLOBAL_CONFIG_BUS_CONTROL_WRR_CNT_MASK 0x000000E0
#define NB_GLOBAL_CONFIG_BUS_CONTROL_WRR_CNT_SHIFT 5
/*
 * Timeout limit before terminating configuration bus access with slave error
 * Reset: 0xfff       Access: RW
 */
#define NB_GLOBAL_CONFIG_BUS_CONTROL_TIMEOUT_LIMIT_MASK 0xFFFFFF00
#define NB_GLOBAL_CONFIG_BUS_CONTROL_TIMEOUT_LIMIT_SHIFT 8

/**** pos_id_match register ****/
/*
 * Enable Device (GRE and nGRE) after Device ID hazard
 * Reset: 0x0         Access: RW
 */
#define NB_GLOBAL_POS_ID_MATCH_ENABLE    (1 << 0)
/*
 * ID Field Mask
 * If set, corresonpding ID bits are not used for ID match
 * Reset: 0x0         Access: RW
 */
#define NB_GLOBAL_POS_ID_MATCH_MASK_MASK 0x0FFF0000
#define NB_GLOBAL_POS_ID_MATCH_MASK_SHIFT 16

/**** sb_sel_override_awuser register ****/
/*
 * Select whether to use transaction awuser or sb_override_awuser value for awuser field on outgoing
 * write transactions to SB.
 * Each bit if set to 1 selects the corresponding sb_override_awuser bit. Otherwise, selects the
 * corersponding transaction awuser bit.
 * Reset: 0x0         Access: RW
 */
#define NB_GLOBAL_SB_SEL_OVERRIDE_AWUSER_SEL_MASK 0x03FFFFFF
#define NB_GLOBAL_SB_SEL_OVERRIDE_AWUSER_SEL_SHIFT 0

/**** sb_override_awuser register ****/
/*
 * Awuser to use on overriden transactions
 * Only applicable if sel_override_awuser.sel is set to 1'b1 for the coressponding bit
 * Reset: 0x0         Access: RW
 */
#define NB_GLOBAL_SB_OVERRIDE_AWUSER_AWUSER_MASK 0x03FFFFFF
#define NB_GLOBAL_SB_OVERRIDE_AWUSER_AWUSER_SHIFT 0

/**** sb_sel_override_aruser register ****/
/*
 * Select whether to use transaction aruser or sb_override_aruser value for aruser field on outgoing
 * read transactions to SB.
 * Each bit if set to 1 selects the corresponding sb_override_aruser bit. Otherwise, selects the
 * corersponding transaction aruser bit.
 * Reset: 0x0         Access: RW
 */
#define NB_GLOBAL_SB_SEL_OVERRIDE_ARUSER_SEL_MASK 0x03FFFFFF
#define NB_GLOBAL_SB_SEL_OVERRIDE_ARUSER_SEL_SHIFT 0

/**** sb_override_aruser register ****/
/*
 * Aruser to use on overriden transactions
 * Only applicable if sb_sel_override_aruser.sel is set to 1'b1 for the coressponding bit
 * Reset: 0x0         Access: RW
 */
#define NB_GLOBAL_SB_OVERRIDE_ARUSER_ARUSER_MASK 0x03FFFFFF
#define NB_GLOBAL_SB_OVERRIDE_ARUSER_ARUSER_SHIFT 0

/**** wr_mixer register ****/
/*
 * Write mixer request Qos.
 * Each 4 bits provide the channel quality of service when <use_agent_qos> is set.
 * Channel 0 - SB port 2
 * Channel 1 - SB port 3
 * Channel 2 - ETR
 * Reset: 0x0         Access: RW
 */
#define NB_GLOBAL_WR_MIXER_REQ_QOS_MASK  0x00000FFF
#define NB_GLOBAL_WR_MIXER_REQ_QOS_SHIFT 0
/*
 * Write mixer promotion rate.
 * Controls after how many denials of service to increase the channel Qos by one.
 * Reset: 0x0         Access: RW
 */
#define NB_GLOBAL_WR_MIXER_PROMO_RATE_MASK 0x0F000000
#define NB_GLOBAL_WR_MIXER_PROMO_RATE_SHIFT 24
/*
 * Write mixer use request Qos.
 * If set, the mixer arbiter uses the <req_qos> values for quality of service arbitration.
 * Else, it uses the AXI Qos value.
 * Reset: 0x0         Access: RW
 */
#define NB_GLOBAL_WR_MIXER_USE_AGENT_QOS (1 << 31)

/**** rd_mixer register ****/
/*
 * Read mixer request Qos.
 * Each 4 bits provide the channel quality of service when <use_agent_qos> is set.
 * Channel 0 - SB port 2
 * Channel 1 - SB port 3
 * Channel 2 - ETR
 * Channel 3 - IO MMU page table walk
 * Reset: 0x0         Access: RW
 */
#define NB_GLOBAL_RD_MIXER_REQ_QOS_MASK  0x0000FFFF
#define NB_GLOBAL_RD_MIXER_REQ_QOS_SHIFT 0
/*
 * Read mixer promotion rate.
 * Controls after how many denials of service to increase the channel Qos by one.
 * Reset: 0x0         Access: RW
 */
#define NB_GLOBAL_RD_MIXER_PROMO_RATE_MASK 0x0F000000
#define NB_GLOBAL_RD_MIXER_PROMO_RATE_SHIFT 24
/*
 * Read mixer use request Qos.
 * If set, the mixer arbiter uses the <req_qos> values for quality of service arbitration.
 * Else, it uses the AXI Qos value.
 * Reset: 0x0         Access: RW
 */
#define NB_GLOBAL_RD_MIXER_USE_AGENT_QOS (1 << 31)

/**** pwr register ****/
/*
 * Power down snoop filter memories (one bit per RAM)
 * Reset: 0x0         Access: RW
 */
#define NB_ACF_PWR_SF_RAM_MASK           0x0000FFFF
#define NB_ACF_PWR_SF_RAM_SHIFT          0

/**** misc register ****/
/*
 * Auto-precharge Write-Clean transactions in DDR
 * Reset: 0x1         Access: RW
 */
#define NB_ACF_MISC_AUTOPRE_WC           (1 << 0)
/*
 * Auto-precharge Write-Back transactions in DDR
 * Reset: 0x1         Access: RW
 */
#define NB_ACF_MISC_AUTOPRE_WB           (1 << 1)
/*
 * Auto-precharge Write-Evict transactions in DDR
 * Reset: 0x1         Access: RW
 */
#define NB_ACF_MISC_AUTOPRE_WE           (1 << 2)
/*
 * Allow CPU to generate PAD transactions to I/O Cache
 * Reset: 0x0         Access: RW
 */
#define NB_ACF_MISC_CPU_IOCACHE_PAD_EN   (1 << 3)
/*
 * Set I/O MMU PTW RRESP to SLVERR when detecting parity error on read data
 * Reset: 0x1         Access: RW
 */
#define NB_ACF_MISC_IOMMU_PTW_SLVERR_ON_PAR_ERR (1 << 4)
/*
 * Enables force same id mechanism after write splitter
 * Reset: 0x1         Access: RW
 */
#define NB_ACF_MISC_FORCE_SAME_ID_EN     (1 << 5)
/*
 * Enables MSIx stall when write transactions from same ID mechanism are in progress
 * Reset: 0x1         Access: RW
 */
#define NB_ACF_MISC_FORCE_SAME_ID_MSIX_STALL_EN (1 << 6)
/*
 * Enables force same id mechanism before I/O MMU
 * Reset: 0x1         Access: RW
 */
#define NB_ACF_MISC_IOMMU_FORCE_SAME_ID_EN (1 << 7)
/*
 * Enables virq and vgic mechanism
 * Reset: 0x0         Access: RW
 */
#define NB_ACF_MISC_VIRQ_EN              (1 << 8)
/*
 * If set, vGIC checks AXI ID to determine source core. Else, take from vGIC access address bits
 * Reset: 0x1         Access: RW
 */
#define NB_ACF_MISC_VGIC_USE_AXI_ID      (1 << 9)
/*
 * Allow CPU to generate Allocate transactions to I/O Cache
 * Reset: 0x0         Access: RW
 */
#define NB_ACF_MISC_CPU_IOCACHE_ALLOC_EN (1 << 10)

/**** iocache register ****/
/*
 * Mask on RDMEMATTR of CPU to determine if access I/O cache
 * Reset: 0x0         Access: RW
 */
#define NB_ACF_IOCACHE_CPU_RD_MASK_MASK  0x000000FF
#define NB_ACF_IOCACHE_CPU_RD_MASK_SHIFT 0
/*
 * Value on RDMEMATTR of CPU to determine if access I/O cache.
 * To disable CPU access to I/O cache, set the mask to 0 and the value to non-zero. To send all
 * transactions to I/O cache, set the mask to 0 and the value to 0.
 * Reset: 0x0         Access: RW
 */
#define NB_ACF_IOCACHE_CPU_RD_VALUE_MASK 0x0000FF00
#define NB_ACF_IOCACHE_CPU_RD_VALUE_SHIFT 8
/*
 * Mask on WRMEMATTR of CPU to determine if access I/O cache
 * Reset: 0x0         Access: RW
 */
#define NB_ACF_IOCACHE_CPU_WR_MASK_MASK  0x00FF0000
#define NB_ACF_IOCACHE_CPU_WR_MASK_SHIFT 16
/*
 * Value on WRMEMATTR of CPU to determine if access I/O cache.
 * To disable CPU access to I/O cache, set the mask to 0 and the value to non-zero. To send all
 * transactions to I/O cache, set the mask to 0 and the value to 0.
 * Reset: 0x0         Access: RW
 */
#define NB_ACF_IOCACHE_CPU_WR_VALUE_MASK 0xFF000000
#define NB_ACF_IOCACHE_CPU_WR_VALUE_SHIFT 24

/**** hash_0_low register ****/
/*
 * Determines which address bits are used to determine ccu_hash[0] (XORing these bits)
 * Applied for address bits [31:6]
 * Reset: 0x11        Access: RW
 */
#define NB_ACF_HASH_0_LOW_MASK_MASK      0xFFFFFFC0
#define NB_ACF_HASH_0_LOW_MASK_SHIFT     6

/**** hash_0_high register ****/
/*
 * Determines which address bits are used to determine ccu_hash[0] (XORing these bits)
 * Applied for address bits [39:32]
 * Reset: 0x0         Access: RW
 */
#define NB_ACF_HASH_0_HIGH_MASK_MASK     0x000000FF
#define NB_ACF_HASH_0_HIGH_MASK_SHIFT    0

/**** hash_1_low register ****/
/*
 * Determines which address bits are used to determine ccu_hash[1] (XORing these bits)
 * Applied for address bits [31:6]
 * Reset: 0x22        Access: RW
 */
#define NB_ACF_HASH_1_LOW_MASK_MASK      0xFFFFFFC0
#define NB_ACF_HASH_1_LOW_MASK_SHIFT     6

/**** hash_1_high register ****/
/*
 * Determines which address bits are used to determine ccu_hash[1] (XORing these bits)
 * Applied for address bits [39:32]
 * Reset: 0x0         Access: RW
 */
#define NB_ACF_HASH_1_HIGH_MASK_MASK     0x000000FF
#define NB_ACF_HASH_1_HIGH_MASK_SHIFT    0

/**** hash_2_low register ****/
/*
 * Determines which address bits are used to determine ccu_hash[2] (XORing these bits)
 * Applied for address bits [31:6]
 * Reset: 0x501004    Access: RW
 */
#define NB_ACF_HASH_2_LOW_MASK_MASK      0xFFFFFFC0
#define NB_ACF_HASH_2_LOW_MASK_SHIFT     6

/**** hash_2_high register ****/
/*
 * Determines which address bits are used to determine ccu_hash[2] (XORing these bits)
 * Applied for address bits [39:32]
 * Reset: 0x0         Access: RW
 */
#define NB_ACF_HASH_2_HIGH_MASK_MASK     0x000000FF
#define NB_ACF_HASH_2_HIGH_MASK_SHIFT    0

/**** sport0_qos register ****/
/*
 * Maximum number of High Priority reads from the port. Any read beyond this number will be reduced
 * to  Low Priority.
 * Set to 0 to disable this mechanism and take the original transaction Qos.
 * Reset: 0x8         Access: RW
 */
#define NB_ACF_SPORT0_QOS_READ_THRESHOLD_MASK 0x0000007F
#define NB_ACF_SPORT0_QOS_READ_THRESHOLD_SHIFT 0
/*
 * Maximum number of High Priority writes from the port. Any write beyond this number will be
 * reduced to  Low Priority.
 * Set to 0 to disable this mechanism and take the original transaction Qos.
 * Reset: 0x8         Access: RW
 */
#define NB_ACF_SPORT0_QOS_WRITE_THRESHOLD_MASK 0x00007F00
#define NB_ACF_SPORT0_QOS_WRITE_THRESHOLD_SHIFT 8
/*
 * High Priority Read Qos
 * Reset: 0x1         Access: RW
 */
#define NB_ACF_SPORT0_QOS_HP_ARQOS_MASK  0x000F0000
#define NB_ACF_SPORT0_QOS_HP_ARQOS_SHIFT 16
/*
 * Low Priority Read Qos
 * Reset: 0x0         Access: RW
 */
#define NB_ACF_SPORT0_QOS_LP_ARQOS_MASK  0x00F00000
#define NB_ACF_SPORT0_QOS_LP_ARQOS_SHIFT 20
/*
 * High Priority Write Qos
 * Reset: 0x1         Access: RW
 */
#define NB_ACF_SPORT0_QOS_HP_AWQOS_MASK  0x0F000000
#define NB_ACF_SPORT0_QOS_HP_AWQOS_SHIFT 24
/*
 * Low Priority Write Qos
 * Reset: 0x0         Access: RW
 */
#define NB_ACF_SPORT0_QOS_LP_AWQOS_MASK  0xF0000000
#define NB_ACF_SPORT0_QOS_LP_AWQOS_SHIFT 28

/**** sport1_qos register ****/
/*
 * Maximum number of High Priority reads from the port. Any read beyond this number will be reduced
 * to  Low Priority.
 * Set to 0 to disable this mechanism and take the original transaction Qos.
 * Reset: 0x8         Access: RW
 */
#define NB_ACF_SPORT1_QOS_READ_THRESHOLD_MASK 0x0000007F
#define NB_ACF_SPORT1_QOS_READ_THRESHOLD_SHIFT 0
/*
 * Maximum number of High Priority writes from the port. Any write beyond this number will be
 * reduced to  Low Priority.
 * Set to 0 to disable this mechanism and take the original transaction Qos.
 * Reset: 0x8         Access: RW
 */
#define NB_ACF_SPORT1_QOS_WRITE_THRESHOLD_MASK 0x00007F00
#define NB_ACF_SPORT1_QOS_WRITE_THRESHOLD_SHIFT 8
/*
 * High Priority Read Qos
 * Reset: 0x1         Access: RW
 */
#define NB_ACF_SPORT1_QOS_HP_ARQOS_MASK  0x000F0000
#define NB_ACF_SPORT1_QOS_HP_ARQOS_SHIFT 16
/*
 * Low Priority Read Qos
 * Reset: 0x0         Access: RW
 */
#define NB_ACF_SPORT1_QOS_LP_ARQOS_MASK  0x00F00000
#define NB_ACF_SPORT1_QOS_LP_ARQOS_SHIFT 20
/*
 * High Priority Write Qos
 * Reset: 0x1         Access: RW
 */
#define NB_ACF_SPORT1_QOS_HP_AWQOS_MASK  0x0F000000
#define NB_ACF_SPORT1_QOS_HP_AWQOS_SHIFT 24
/*
 * Low Priority Write Qos
 * Reset: 0x0         Access: RW
 */
#define NB_ACF_SPORT1_QOS_LP_AWQOS_MASK  0xF0000000
#define NB_ACF_SPORT1_QOS_LP_AWQOS_SHIFT 28

/**** sport2_qos register ****/
/*
 * Maximum number of High Priority reads from the port. Any read beyond this number will be reduced
 * to  Low Priority.
 * Set to 0 to disable this mechanism and take the original transaction Qos.
 * Reset: 0x8         Access: RW
 */
#define NB_ACF_SPORT2_QOS_READ_THRESHOLD_MASK 0x0000007F
#define NB_ACF_SPORT2_QOS_READ_THRESHOLD_SHIFT 0
/*
 * Maximum number of High Priority writes from the port. Any write beyond this number will be
 * reduced to  Low Priority.
 * Set to 0 to disable this mechanism and take the original transaction Qos.
 * Reset: 0x8         Access: RW
 */
#define NB_ACF_SPORT2_QOS_WRITE_THRESHOLD_MASK 0x00007F00
#define NB_ACF_SPORT2_QOS_WRITE_THRESHOLD_SHIFT 8
/*
 * High Priority Read Qos
 * Reset: 0x1         Access: RW
 */
#define NB_ACF_SPORT2_QOS_HP_ARQOS_MASK  0x000F0000
#define NB_ACF_SPORT2_QOS_HP_ARQOS_SHIFT 16
/*
 * Low Priority Read Qos
 * Reset: 0x0         Access: RW
 */
#define NB_ACF_SPORT2_QOS_LP_ARQOS_MASK  0x00F00000
#define NB_ACF_SPORT2_QOS_LP_ARQOS_SHIFT 20
/*
 * High Priority Write Qos
 * Reset: 0x1         Access: RW
 */
#define NB_ACF_SPORT2_QOS_HP_AWQOS_MASK  0x0F000000
#define NB_ACF_SPORT2_QOS_HP_AWQOS_SHIFT 24
/*
 * Low Priority Write Qos
 * Reset: 0x0         Access: RW
 */
#define NB_ACF_SPORT2_QOS_LP_AWQOS_MASK  0xF0000000
#define NB_ACF_SPORT2_QOS_LP_AWQOS_SHIFT 28

/**** sport3_qos register ****/
/*
 * Maximum number of High Priority reads from the port. Any read beyond this number will be reduced
 * to  Low Priority.
 * Set to 0 to disable this mechanism and take the original transaction Qos.
 * Reset: 0x8         Access: RW
 */
#define NB_ACF_SPORT3_QOS_READ_THRESHOLD_MASK 0x0000007F
#define NB_ACF_SPORT3_QOS_READ_THRESHOLD_SHIFT 0
/*
 * Maximum number of High Priority writes from the port. Any write beyond this number will be
 * reduced to  Low Priority.
 * Set to 0 to disable this mechanism and take the original transaction Qos.
 * Reset: 0x8         Access: RW
 */
#define NB_ACF_SPORT3_QOS_WRITE_THRESHOLD_MASK 0x00007F00
#define NB_ACF_SPORT3_QOS_WRITE_THRESHOLD_SHIFT 8
/*
 * High Priority Read Qos
 * Reset: 0xf         Access: RW
 */
#define NB_ACF_SPORT3_QOS_HP_ARQOS_MASK  0x000F0000
#define NB_ACF_SPORT3_QOS_HP_ARQOS_SHIFT 16
/*
 * Low Priority Read Qos
 * Reset: 0x0         Access: RW
 */
#define NB_ACF_SPORT3_QOS_LP_ARQOS_MASK  0x00F00000
#define NB_ACF_SPORT3_QOS_LP_ARQOS_SHIFT 20
/*
 * High Priority Write Qos
 * Reset: 0xf         Access: RW
 */
#define NB_ACF_SPORT3_QOS_HP_AWQOS_MASK  0x0F000000
#define NB_ACF_SPORT3_QOS_HP_AWQOS_SHIFT 24
/*
 * Low Priority Write Qos
 * Reset: 0x0         Access: RW
 */
#define NB_ACF_SPORT3_QOS_LP_AWQOS_MASK  0xF0000000
#define NB_ACF_SPORT3_QOS_LP_AWQOS_SHIFT 28

/**** sport4_qos register ****/
/*
 * Maximum number of High Priority reads from the port. Any read beyond this number will be reduced
 * to  Low Priority.
 * Set to 0 to disable this mechanism and take the original transaction Qos.
 * Reset: 0x8         Access: RW
 */
#define NB_ACF_SPORT4_QOS_READ_THRESHOLD_MASK 0x0000007F
#define NB_ACF_SPORT4_QOS_READ_THRESHOLD_SHIFT 0
/*
 * Maximum number of High Priority writes from the port. Any write beyond this number will be
 * reduced to  Low Priority.
 * Set to 0 to disable this mechanism and take the original transaction Qos.
 * Reset: 0x8         Access: RW
 */
#define NB_ACF_SPORT4_QOS_WRITE_THRESHOLD_MASK 0x00007F00
#define NB_ACF_SPORT4_QOS_WRITE_THRESHOLD_SHIFT 8
/*
 * High Priority Read Qos
 * Reset: 0xf         Access: RW
 */
#define NB_ACF_SPORT4_QOS_HP_ARQOS_MASK  0x000F0000
#define NB_ACF_SPORT4_QOS_HP_ARQOS_SHIFT 16
/*
 * Low Priority Read Qos
 * Reset: 0x0         Access: RW
 */
#define NB_ACF_SPORT4_QOS_LP_ARQOS_MASK  0x00F00000
#define NB_ACF_SPORT4_QOS_LP_ARQOS_SHIFT 20
/*
 * High Priority Write Qos
 * Reset: 0xf         Access: RW
 */
#define NB_ACF_SPORT4_QOS_HP_AWQOS_MASK  0x0F000000
#define NB_ACF_SPORT4_QOS_HP_AWQOS_SHIFT 24
/*
 * Low Priority Write Qos
 * Reset: 0x0         Access: RW
 */
#define NB_ACF_SPORT4_QOS_LP_AWQOS_MASK  0xF0000000
#define NB_ACF_SPORT4_QOS_LP_AWQOS_SHIFT 28

/**** sport5_qos register ****/
/*
 * Maximum number of High Priority reads from the port. Any read beyond this number will be reduced
 * to  Low Priority.
 * Set to 0 to disable this mechanism and take the original transaction Qos.
 * Reset: 0x8         Access: RW
 */
#define NB_ACF_SPORT5_QOS_READ_THRESHOLD_MASK 0x0000007F
#define NB_ACF_SPORT5_QOS_READ_THRESHOLD_SHIFT 0
/*
 * Maximum number of High Priority writes from the port. Any write beyond this number will be
 * reduced to  Low Priority.
 * Set to 0 to disable this mechanism and take the original transaction Qos.
 * Reset: 0x8         Access: RW
 */
#define NB_ACF_SPORT5_QOS_WRITE_THRESHOLD_MASK 0x00007F00
#define NB_ACF_SPORT5_QOS_WRITE_THRESHOLD_SHIFT 8
/*
 * High Priority Read Qos
 * Reset: 0xf         Access: RW
 */
#define NB_ACF_SPORT5_QOS_HP_ARQOS_MASK  0x000F0000
#define NB_ACF_SPORT5_QOS_HP_ARQOS_SHIFT 16
/*
 * Low Priority Read Qos
 * Reset: 0x0         Access: RW
 */
#define NB_ACF_SPORT5_QOS_LP_ARQOS_MASK  0x00F00000
#define NB_ACF_SPORT5_QOS_LP_ARQOS_SHIFT 20
/*
 * High Priority Write Qos
 * Reset: 0xf         Access: RW
 */
#define NB_ACF_SPORT5_QOS_HP_AWQOS_MASK  0x0F000000
#define NB_ACF_SPORT5_QOS_HP_AWQOS_SHIFT 24
/*
 * Low Priority Write Qos
 * Reset: 0x0         Access: RW
 */
#define NB_ACF_SPORT5_QOS_LP_AWQOS_MASK  0xF0000000
#define NB_ACF_SPORT5_QOS_LP_AWQOS_SHIFT 28

/**** sport6_qos register ****/
/*
 * Maximum number of High Priority reads from the port. Any read beyond this number will be reduced
 * to  Low Priority.
 * Set to 0 to disable this mechanism and take the original transaction Qos.
 * Reset: 0x8         Access: RW
 */
#define NB_ACF_SPORT6_QOS_READ_THRESHOLD_MASK 0x0000007F
#define NB_ACF_SPORT6_QOS_READ_THRESHOLD_SHIFT 0
/*
 * Maximum number of High Priority writes from the port. Any write beyond this number will be
 * reduced to  Low Priority.
 * Set to 0 to disable this mechanism and take the original transaction Qos.
 * Reset: 0x8         Access: RW
 */
#define NB_ACF_SPORT6_QOS_WRITE_THRESHOLD_MASK 0x00007F00
#define NB_ACF_SPORT6_QOS_WRITE_THRESHOLD_SHIFT 8
/*
 * High Priority Read Qos
 * Reset: 0xf         Access: RW
 */
#define NB_ACF_SPORT6_QOS_HP_ARQOS_MASK  0x000F0000
#define NB_ACF_SPORT6_QOS_HP_ARQOS_SHIFT 16
/*
 * Low Priority Read Qos
 * Reset: 0x0         Access: RW
 */
#define NB_ACF_SPORT6_QOS_LP_ARQOS_MASK  0x00F00000
#define NB_ACF_SPORT6_QOS_LP_ARQOS_SHIFT 20
/*
 * High Priority Write Qos
 * Reset: 0xf         Access: RW
 */
#define NB_ACF_SPORT6_QOS_HP_AWQOS_MASK  0x0F000000
#define NB_ACF_SPORT6_QOS_HP_AWQOS_SHIFT 24
/*
 * Low Priority Write Qos
 * Reset: 0x0         Access: RW
 */
#define NB_ACF_SPORT6_QOS_LP_AWQOS_MASK  0xF0000000
#define NB_ACF_SPORT6_QOS_LP_AWQOS_SHIFT 28

/**** mport0_qos register ****/
/*
 * Override read Qos.
 * Set to 0 to disable this mechanism and propagate the incoming Qos
 * Reset: 0x0         Access: RW
 */
#define NB_ACF_MPORT0_QOS_ARQOS_MASK     0x0000000F
#define NB_ACF_MPORT0_QOS_ARQOS_SHIFT    0
/*
 * Override write Qos.
 * Set to 0 to disable this mechanism and propagate the incoming Qos
 * Reset: 0x0         Access: RW
 */
#define NB_ACF_MPORT0_QOS_AWQOS_MASK     0x000000F0
#define NB_ACF_MPORT0_QOS_AWQOS_SHIFT    4

/**** pd register ****/
/*
 * APBIC clock enable
 * Reset: 0x1         Access: RW
 */
#define NB_CORESIGHT_PD_APBICLKEN        (1 << 4)
/*
 * DAP system clock enable
 * Reset: 0x1         Access: RW
 */
#define NB_CORESIGHT_PD_DAP_SYS_CLKEN    (1 << 5)

/**** ctm register ****/
/*
 * TOP CTM and Coresight CTI operate according to the same clock.
 * Bypass modes can be enabled
 * Reset: 0x1         Access: RW
 */
#define NB_CORESIGHT_CTM_CTIAPBSBYPASS   (1 << 0)
/*
 * CPU CTM and TOP CTM operate at different clock, bypass modes cannot be enabled
 * Reset: 0x0         Access: RW
 */
#define NB_CORESIGHT_CTM_CPU_CIHSBYPASS_MASK 0x0000003C
#define NB_CORESIGHT_CTM_CPU_CIHSBYPASS_SHIFT 2
/*
 * TOP CTM and Coresight CTI operate at same clock, bypass modes can be enabled
 * Reset: 0x1         Access: RW
 */
#define NB_CORESIGHT_CTM_TOP_CISBYPASS   (1 << 6)
/*
 * TOP CTM and Coresight CTI operate according to the same clock.
 * Bypass modes can be enabled
 * Reset: 0xf         Access: RW
 */
#define NB_CORESIGHT_CTM_TOP_CIHSBYPASS_MASK 0x00000780
#define NB_CORESIGHT_CTM_TOP_CIHSBYPASS_SHIFT 7

/**** dbgromaddr register ****/
/*
 * Valid signal for DBGROMADDR.
 * Connected to DBGROMADDRV
 * Reset: 0x1         Access: RW
 */
#define NB_CORESIGHT_DBGROMADDR_VALID    (1 << 0)
/*
 * Specifies bits [39:12] of the ROM table physical address.
 * Reset: 0x0         Access: RO
 */
#define NB_CORESIGHT_DBGROMADDR_ADDR_39_12_MASK 0x3FFFFFFC
#define NB_CORESIGHT_DBGROMADDR_ADDR_39_12_SHIFT 2

/**** cti_0 register ****/
/*
 * Trigger interface handshake bypass
 * Reset: 0x0         Access: RW
 */
#define NB_CORESIGHT_CTI_0_TIHSBYPASS_MASK 0x000000FF
#define NB_CORESIGHT_CTI_0_TIHSBYPASS_SHIFT 0
/*
 * Trigger out acknowledge sync bypass
 * Reset: 0x0         Access: RW
 */
#define NB_CORESIGHT_CTI_0_TISBYPASSACK_MASK 0x00FF0000
#define NB_CORESIGHT_CTI_0_TISBYPASSACK_SHIFT 16
/*
 * Trigger in sync bypass
 * Reset: 0x0         Access: RW
 */
#define NB_CORESIGHT_CTI_0_TISBYPASSIN_MASK 0xFF000000
#define NB_CORESIGHT_CTI_0_TISBYPASSIN_SHIFT 24

/**** cti_1 register ****/
/*
 * Masks when dbgen is LOW
 * Reset: 0x0         Access: RW
 */
#define NB_CORESIGHT_CTI_1_TODBGENSEL_MASK 0x000000FF
#define NB_CORESIGHT_CTI_1_TODBGENSEL_SHIFT 0
/*
 * Masks when NIDEN is LOW
 * Reset: 0x0         Access: RW
 */
#define NB_CORESIGHT_CTI_1_TINIDENSEL_MASK 0x0000FF00
#define NB_CORESIGHT_CTI_1_TINIDENSEL_SHIFT 8

/**** stm register ****/
/*
 * When the NSGUAREN signal is LOW, Non-secure guaranteed accesses behave like
 * invariant timing accesses, that is, the AXI does not stall.
 * When the NSGUAREN signal is HIGH, Non-secure guaranteed accesses are enabled,
 * that is, the AXI can stall and the trace output is guaranteed.
 * Reset: 0x0         Access: RW
 */
#define NB_CORESIGHT_STM_NSGUAREN        (1 << 0)
/*
 * When set, take STM master ID from reg_value, else take from address bits [20:17]
 * Reset: 0x0         Access: RW
 */
#define NB_CORESIGHT_STM_MASTER_ID_REG_OVRD (1 << 1)
/*
 * Value to use as master ID if reg_ovrd is set
 * Reset: 0x0         Access: RW
 */
#define NB_CORESIGHT_STM_MASTER_ID_REG_VALUE_MASK 0x000000FC
#define NB_CORESIGHT_STM_MASTER_ID_REG_VALUE_SHIFT 2

/**** rom register ****/
/*
 * Override ROM entries
 * Reset: 0x0         Access: RW
 */
#define NB_CORESIGHT_ROM_OVRD            (1 << 0)

/**** allowed_cores register ****/
/*
 * Determines if for this core (specify by register index), can send vIRQ to other cores (bit per
 * core)
 * Reset: 0x0         Access: RW
 */
#define NB_VGIC_ALLOWED_CORES_VAL_MASK   0x0000FFFF
#define NB_VGIC_ALLOWED_CORES_VAL_SHIFT  0

/**** wr_split_control register ****/
/*
 * Write splitters store and forward.
 * If store and forward is disabled, splitter does not check non-active BE in the middle of a
 * transaction.
 * Reset: 0x1         Access: RW
 */
#define NB_SB2NB_PORT_WR_SPLIT_CONTROL_ST_FW (1 << 1)
/*
 * Write splitters unmodify snoop type.
 * Disables modifying snoop type from Clean & Invalidate to Invalidate when conditions enable it.
 * Only split operation to 64B is applied.
 * Reset: 0x0         Access: RW
 */
#define NB_SB2NB_PORT_WR_SPLIT_CONTROL_UNMODIFY_SNP (1 << 2)
/*
 * In default mode, AWADDR waits for WDATA.
 * Reset: 0x0         Access: RW
 */
#define NB_SB2NB_PORT_WR_SPLIT_CONTROL_PACK_DIS (1 << 4)
/*
 * Write splitters track sub 64bit transactions enable
 * Reset: 0x0         Access: RW
 */
#define NB_SB2NB_PORT_WR_SPLIT_CONTROL_TRACK_64BIT (1 << 6)
/*
 * Write splitter rate limit.
 * Reset: 0x4         Access: RW
 */
#define NB_SB2NB_PORT_WR_SPLIT_CONTROL_RATE_LIMIT_MASK 0x00001F00
#define NB_SB2NB_PORT_WR_SPLIT_CONTROL_RATE_LIMIT_SHIFT 8
/*
 * Disable wr spliter alpine V1 bug fixes
 * Reset: 0x0         Access: RW
 */
#define NB_SB2NB_PORT_WR_SPLIT_CONTROL_ALPINE_V1_MODE_DIS (1 << 13)
/*
 * Disable wr spliter alpine V3 response bug fixes
 * Reset: 0x0         Access: RW
 */
#define NB_SB2NB_PORT_WR_SPLIT_CONTROL_ALPINE_V3_BRESP_DIS (1 << 14)

/**** rd_rob_control register ****/
/*
 * Read ROB in order.
 * Return data in the order of request acceptance.
 * Reset: 0x0         Access: RW
 */
#define NB_SB2NB_PORT_RD_ROB_CONTROL_INORDER (1 << 1)
/*
 * Read ROB response rate
 * When enabled drops one cycle from back to back read responses
 * Reset: 0x1         Access: RW
 */
#define NB_SB2NB_PORT_RD_ROB_CONTROL_RSP_RATE (1 << 2)
/*
 * When enabled allows submission of transactions once anything is available, else wait for
 * existence of all in hand
 * Reset: 0x1         Access: RW
 */
#define NB_SB2NB_PORT_RD_ROB_CONTROL_CUTTHRU_EN (1 << 3)
/*
 * Read splitter rate limit
 * Reset: 0x4         Access: RW
 */
#define NB_SB2NB_PORT_RD_ROB_CONTROL_RATE_LIMIT_MASK 0x00001F00
#define NB_SB2NB_PORT_RD_ROB_CONTROL_RATE_LIMIT_SHIFT 8

/**** iommu_cfg register ****/
/*
 * StreamID value to use for transactions with iommu_bypass attribute
 * Reset: 0x0         Access: RW
 */
#define NB_SB2NB_PORT_IOMMU_CFG_BYPASS_STREAMID_MASK 0x00007FFF
#define NB_SB2NB_PORT_IOMMU_CFG_BYPASS_STREAMID_SHIFT 0
/*
 * Selects whether to use context attribute or PCIe BDF as StreamID
 * Reset: 0x1         Access: RW
 */
#define NB_SB2NB_PORT_IOMMU_CFG_STREAMID_USE_CONTEXT (1 << 16)

/**** iommu_axaddr_l register ****/
/*
 * Bit-wise selects whether to take attribute from reg_value.
 * Reset: 0xff        Access: RW
 */
#define NB_SB2NB_PORT_IOMMU_AXADDR_L_REG_OVRD_MASK 0x000000FF
#define NB_SB2NB_PORT_IOMMU_AXADDR_L_REG_OVRD_SHIFT 0
/*
 * Attribute value if taken from register (reg_ovrd set)
 * Reset: 0x0         Access: RW
 */
#define NB_SB2NB_PORT_IOMMU_AXADDR_L_REG_VALUE_MASK 0x0000FF00
#define NB_SB2NB_PORT_IOMMU_AXADDR_L_REG_VALUE_SHIFT 8
/*
 * Bit-wise selects whether to take attribute from PCIe BDF (using bdf_offset)
 * Reset: 0x0         Access: RW
 */
#define NB_SB2NB_PORT_IOMMU_AXADDR_L_BDF_OVRD_MASK 0x00FF0000
#define NB_SB2NB_PORT_IOMMU_AXADDR_L_BDF_OVRD_SHIFT 16

/**** iommu_axaddr_h register ****/
/*
 * Offset in PCIe BDF from which to take attribute
 * Reset: 0x0         Access: RW
 */
#define NB_SB2NB_PORT_IOMMU_AXADDR_H_BDF_OFFSET_0_MASK 0x0000000F
#define NB_SB2NB_PORT_IOMMU_AXADDR_H_BDF_OFFSET_0_SHIFT 0
/*
 * Offset in PCIe BDF from which to take attribute
 * Reset: 0x0         Access: RW
 */
#define NB_SB2NB_PORT_IOMMU_AXADDR_H_BDF_OFFSET_2_MASK 0x000000F0
#define NB_SB2NB_PORT_IOMMU_AXADDR_H_BDF_OFFSET_2_SHIFT 4
/*
 * Offset in PCIe BDF from which to take attribute
 * Reset: 0x0         Access: RW
 */
#define NB_SB2NB_PORT_IOMMU_AXADDR_H_BDF_OFFSET_4_MASK 0x00000F00
#define NB_SB2NB_PORT_IOMMU_AXADDR_H_BDF_OFFSET_4_SHIFT 8
/*
 * Offset in PCIe BDF from which to take attribute
 * Reset: 0x0         Access: RW
 */
#define NB_SB2NB_PORT_IOMMU_AXADDR_H_BDF_OFFSET_6_MASK 0x0000F000
#define NB_SB2NB_PORT_IOMMU_AXADDR_H_BDF_OFFSET_6_SHIFT 12

/**** force_same_id_mask_0 register ****/
/*
 * Mask to use for determining if same ID enforcement in needed
 * Reset: 0x0         Access: RW
 */
#define NB_SB2NB_PORT_FORCE_SAME_ID_MASK_0_VAL_MASK 0x001FFFFF
#define NB_SB2NB_PORT_FORCE_SAME_ID_MASK_0_VAL_SHIFT 0

/**** force_same_id_value_0 register ****/
/*
 * Value to use for determining if same ID enforcement in needed
 * Reset: 0x0         Access: RW
 */
#define NB_SB2NB_PORT_FORCE_SAME_ID_VALUE_0_VAL_MASK 0x001FFFFF
#define NB_SB2NB_PORT_FORCE_SAME_ID_VALUE_0_VAL_SHIFT 0

/**** force_same_id_mask_1 register ****/
/*
 * Mask to use for determining if same ID enforcement in needed
 * Reset: 0x0         Access: RW
 */
#define NB_SB2NB_PORT_FORCE_SAME_ID_MASK_1_VAL_MASK 0x001FFFFF
#define NB_SB2NB_PORT_FORCE_SAME_ID_MASK_1_VAL_SHIFT 0

/**** force_same_id_value_1 register ****/
/*
 * Value to use for determining if same ID enforcement in needed
 * Reset: 0x0         Access: RW
 */
#define NB_SB2NB_PORT_FORCE_SAME_ID_VALUE_1_VAL_MASK 0x001FFFFF
#define NB_SB2NB_PORT_FORCE_SAME_ID_VALUE_1_VAL_SHIFT 0

/**** power register ****/
/*
 * Power down read ROB memory
 * Reset: 0x0         Access: RW
 */
#define NB_SB2NB_PORT_POWER_RD_ROB_RAM   (1 << 0)
/*
 * Power down I/O MMU TBU memory
 * Reset: 0x0         Access: RW
 */
#define NB_SB2NB_PORT_POWER_IOMMU_TBU_RAM (1 << 1)

/**** attr_sel_cache_hit register ****/
/*
 * Bit-wise selects whether to take attribute from reg_value.
 * Reset: 0x1         Access: RW
 */
#define NB_SB2NB_PORT_ATTR_SEL_CACHE_HIT_REG_OVRD (1 << 0)
/*
 * Attribute value if taken from register (reg_ovrd set)
 * Reset: 0x1         Access: RW
 */
#define NB_SB2NB_PORT_ATTR_SEL_CACHE_HIT_REG_VALUE (1 << 6)
/*
 * Bit-wise selects whether to take attribute from AxUser signal (using user_offset)
 * Reset: 0x0         Access: RW
 */
#define NB_SB2NB_PORT_ATTR_SEL_CACHE_HIT_USER_OVRD (1 << 12)
/*
 * Offset in AxUser signal from which to take attribute
 * Reset: 0x0         Access: RW
 */
#define NB_SB2NB_PORT_ATTR_SEL_CACHE_HIT_USER_OFFSET_MASK 0x003C0000
#define NB_SB2NB_PORT_ATTR_SEL_CACHE_HIT_USER_OFFSET_SHIFT 18
/*
 * Offset in AxAddr signal from which to take attribute
 * Reset: 0xa         Access: RW
 */
#define NB_SB2NB_PORT_ATTR_SEL_CACHE_HIT_ADDR_OFFSET_MASK 0x1F000000
#define NB_SB2NB_PORT_ATTR_SEL_CACHE_HIT_ADDR_OFFSET_SHIFT 24

/**** attr_sel_cache_pad register ****/
/*
 * Bit-wise selects whether to take attribute from reg_value.
 * Reset: 0x0         Access: RW
 */
#define NB_SB2NB_PORT_ATTR_SEL_CACHE_PAD_REG_OVRD (1 << 0)
/*
 * Attribute value if taken from register (reg_ovrd set)
 * Reset: 0x0         Access: RW
 */
#define NB_SB2NB_PORT_ATTR_SEL_CACHE_PAD_REG_VALUE (1 << 6)
/*
 * Bit-wise selects whether to take attribute from AxUser signal (using user_offset)
 * Reset: 0x0         Access: RW
 */
#define NB_SB2NB_PORT_ATTR_SEL_CACHE_PAD_USER_OVRD (1 << 12)
/*
 * Offset in AxUser signal from which to take attribute
 * Reset: 0x0         Access: RW
 */
#define NB_SB2NB_PORT_ATTR_SEL_CACHE_PAD_USER_OFFSET_MASK 0x003C0000
#define NB_SB2NB_PORT_ATTR_SEL_CACHE_PAD_USER_OFFSET_SHIFT 18
/*
 * Offset in AxAddr signal from which to take attribute
 * Reset: 0xb         Access: RW
 */
#define NB_SB2NB_PORT_ATTR_SEL_CACHE_PAD_ADDR_OFFSET_MASK 0x1F000000
#define NB_SB2NB_PORT_ATTR_SEL_CACHE_PAD_ADDR_OFFSET_SHIFT 24

/**** attr_sel_force_order register ****/
/*
 * Bit-wise selects whether to take attribute from reg_value.
 * Reset: 0x1         Access: RW
 */
#define NB_SB2NB_PORT_ATTR_SEL_FORCE_ORDER_REG_OVRD (1 << 0)
/*
 * Attribute value if taken from register (reg_ovrd set)
 * Reset: 0x0         Access: RW
 */
#define NB_SB2NB_PORT_ATTR_SEL_FORCE_ORDER_REG_VALUE (1 << 6)
/*
 * Bit-wise selects whether to take attribute from AxUser signal (using user_offset)
 * Reset: 0x0         Access: RW
 */
#define NB_SB2NB_PORT_ATTR_SEL_FORCE_ORDER_USER_OVRD (1 << 12)
/*
 * Offset in AxUser signal from which to take attribute
 * Reset: 0x0         Access: RW
 */
#define NB_SB2NB_PORT_ATTR_SEL_FORCE_ORDER_USER_OFFSET_MASK 0x003C0000
#define NB_SB2NB_PORT_ATTR_SEL_FORCE_ORDER_USER_OFFSET_SHIFT 18
/*
 * Offset in AxAddr signal from which to take attribute
 * Reset: 0x0         Access: RW
 */
#define NB_SB2NB_PORT_ATTR_SEL_FORCE_ORDER_ADDR_OFFSET_MASK 0x1F000000
#define NB_SB2NB_PORT_ATTR_SEL_FORCE_ORDER_ADDR_OFFSET_SHIFT 24

/**** attr_sel_force_order_group register ****/
/*
 * Bit-wise selects whether to take attribute from reg_value.
 * Reset: 0x1         Access: RW
 */
#define NB_SB2NB_PORT_ATTR_SEL_FORCE_ORDER_GROUP_REG_OVRD (1 << 0)
/*
 * Attribute value if taken from register (reg_ovrd set)
 * Reset: 0x0         Access: RW
 */
#define NB_SB2NB_PORT_ATTR_SEL_FORCE_ORDER_GROUP_REG_VALUE (1 << 6)
/*
 * Bit-wise selects whether to take attribute from AxUser signal (using user_offset)
 * Reset: 0x0         Access: RW
 */
#define NB_SB2NB_PORT_ATTR_SEL_FORCE_ORDER_GROUP_USER_OVRD (1 << 12)
/*
 * Offset in AxUser signal from which to take attribute
 * Reset: 0x0         Access: RW
 */
#define NB_SB2NB_PORT_ATTR_SEL_FORCE_ORDER_GROUP_USER_OFFSET_MASK 0x003C0000
#define NB_SB2NB_PORT_ATTR_SEL_FORCE_ORDER_GROUP_USER_OFFSET_SHIFT 18
/*
 * Offset in AxAddr signal from which to take attribute
 * Reset: 0x0         Access: RW
 */
#define NB_SB2NB_PORT_ATTR_SEL_FORCE_ORDER_GROUP_ADDR_OFFSET_MASK 0x1F000000
#define NB_SB2NB_PORT_ATTR_SEL_FORCE_ORDER_GROUP_ADDR_OFFSET_SHIFT 24

/**** attr_sel_tml_hit register ****/
/*
 * Bit-wise selects whether to take attribute from reg_value.
 * Reset: 0x0         Access: RW
 */
#define NB_SB2NB_PORT_ATTR_SEL_TML_HIT_REG_OVRD (1 << 0)
/*
 * Attribute value if taken from register (reg_ovrd set)
 * Reset: 0x0         Access: RW
 */
#define NB_SB2NB_PORT_ATTR_SEL_TML_HIT_REG_VALUE (1 << 6)
/*
 * Bit-wise selects whether to take attribute from AxUser signal (using user_offset)
 * Reset: 0x0         Access: RW
 */
#define NB_SB2NB_PORT_ATTR_SEL_TML_HIT_USER_OVRD (1 << 12)
/*
 * Offset in AxUser signal from which to take attribute
 * Reset: 0x0         Access: RW
 */
#define NB_SB2NB_PORT_ATTR_SEL_TML_HIT_USER_OFFSET_MASK 0x003C0000
#define NB_SB2NB_PORT_ATTR_SEL_TML_HIT_USER_OFFSET_SHIFT 18
/*
 * Offset in AxAddr signal from which to take attribute
 * Reset: 0x6         Access: RW
 */
#define NB_SB2NB_PORT_ATTR_SEL_TML_HIT_ADDR_OFFSET_MASK 0x1F000000
#define NB_SB2NB_PORT_ATTR_SEL_TML_HIT_ADDR_OFFSET_SHIFT 24

/**** attr_sel_tdl_hit register ****/
/*
 * Bit-wise selects whether to take attribute from reg_value.
 * Reset: 0x0         Access: RW
 */
#define NB_SB2NB_PORT_ATTR_SEL_TDL_HIT_REG_OVRD (1 << 0)
/*
 * Attribute value if taken from register (reg_ovrd set)
 * Reset: 0x0         Access: RW
 */
#define NB_SB2NB_PORT_ATTR_SEL_TDL_HIT_REG_VALUE (1 << 6)
/*
 * Bit-wise selects whether to take attribute from AxUser signal (using user_offset)
 * Reset: 0x0         Access: RW
 */
#define NB_SB2NB_PORT_ATTR_SEL_TDL_HIT_USER_OVRD (1 << 12)
/*
 * Offset in AxUser signal from which to take attribute
 * Reset: 0x0         Access: RW
 */
#define NB_SB2NB_PORT_ATTR_SEL_TDL_HIT_USER_OFFSET_MASK 0x003C0000
#define NB_SB2NB_PORT_ATTR_SEL_TDL_HIT_USER_OFFSET_SHIFT 18
/*
 * Offset in AxAddr signal from which to take attribute
 * Reset: 0x7         Access: RW
 */
#define NB_SB2NB_PORT_ATTR_SEL_TDL_HIT_ADDR_OFFSET_MASK 0x1F000000
#define NB_SB2NB_PORT_ATTR_SEL_TDL_HIT_ADDR_OFFSET_SHIFT 24

/**** attr_sel_tml_target register ****/
/*
 * Bit-wise selects whether to take attribute from reg_value.
 * Reset: 0x1c        Access: RW
 */
#define NB_SB2NB_PORT_ATTR_SEL_TML_TARGET_REG_OVRD_MASK 0x0000001F
#define NB_SB2NB_PORT_ATTR_SEL_TML_TARGET_REG_OVRD_SHIFT 0
/*
 * Attribute value if taken from register (reg_ovrd set)
 * Reset: 0x0         Access: RW
 */
#define NB_SB2NB_PORT_ATTR_SEL_TML_TARGET_REG_VALUE_MASK 0x000007C0
#define NB_SB2NB_PORT_ATTR_SEL_TML_TARGET_REG_VALUE_SHIFT 6
/*
 * Bit-wise selects whether to take attribute from AxUser signal (using user_offset)
 * Reset: 0x3         Access: RW
 */
#define NB_SB2NB_PORT_ATTR_SEL_TML_TARGET_USER_OVRD_MASK 0x0001F000
#define NB_SB2NB_PORT_ATTR_SEL_TML_TARGET_USER_OVRD_SHIFT 12
/*
 * Offset in AxUser signal from which to take attribute
 * Reset: 0xa         Access: RW
 */
#define NB_SB2NB_PORT_ATTR_SEL_TML_TARGET_USER_OFFSET_MASK 0x003C0000
#define NB_SB2NB_PORT_ATTR_SEL_TML_TARGET_USER_OFFSET_SHIFT 18
/*
 * Offset in AxAddr signal from which to take attribute
 * Reset: 0x0         Access: RW
 */
#define NB_SB2NB_PORT_ATTR_SEL_TML_TARGET_ADDR_OFFSET_MASK 0x1F000000
#define NB_SB2NB_PORT_ATTR_SEL_TML_TARGET_ADDR_OFFSET_SHIFT 24

/**** attr_sel_logger_attr_l register ****/
/*
 * Bit-wise selects whether to take attribute from reg_value.
 * Reset: 0xc000      Access: RW
 */
#define NB_SB2NB_PORT_ATTR_SEL_LOGGER_ATTR_L_REG_OVRD_MASK 0x0000FFFF
#define NB_SB2NB_PORT_ATTR_SEL_LOGGER_ATTR_L_REG_OVRD_SHIFT 0
/*
 * Attribute value if taken from register (reg_ovrd set)
 * Reset: 0x0         Access: RW
 */
#define NB_SB2NB_PORT_ATTR_SEL_LOGGER_ATTR_L_REG_VALUE_MASK 0xFFFF0000
#define NB_SB2NB_PORT_ATTR_SEL_LOGGER_ATTR_L_REG_VALUE_SHIFT 16

/**** attr_sel_logger_attr_h register ****/
/*
 * Bit-wise selects whether to take attribute from AxUser signal
 * Reset: 0xc         Access: RW
 */
#define NB_SB2NB_PORT_ATTR_SEL_LOGGER_ATTR_H_USER_OVRD_MASK 0x0000FFFF
#define NB_SB2NB_PORT_ATTR_SEL_LOGGER_ATTR_H_USER_OVRD_SHIFT 0
/*
 * Use BDF for attribute
 * Reset: 0x0         Access: RW
 */
#define NB_SB2NB_PORT_ATTR_SEL_LOGGER_ATTR_H_USE_BDF (1 << 31)

/**** attr_sel_iommu_bypass register ****/
/*
 * Bit-wise selects whether to take attribute from reg_value.
 * Reset: 0x0         Access: RW
 */
#define NB_SB2NB_PORT_ATTR_SEL_IOMMU_BYPASS_REG_OVRD (1 << 0)
/*
 * Attribute value if taken from register (reg_ovrd set)
 * Reset: 0x0         Access: RW
 */
#define NB_SB2NB_PORT_ATTR_SEL_IOMMU_BYPASS_REG_VALUE (1 << 6)
/*
 * Bit-wise selects whether to take attribute from AxUser signal (using user_offset)
 * Reset: 0x1         Access: RW
 */
#define NB_SB2NB_PORT_ATTR_SEL_IOMMU_BYPASS_USER_OVRD (1 << 12)
/*
 * Offset in AxUser signal from which to take attribute
 * Reset: 0x1         Access: RW
 */
#define NB_SB2NB_PORT_ATTR_SEL_IOMMU_BYPASS_USER_OFFSET_MASK 0x003C0000
#define NB_SB2NB_PORT_ATTR_SEL_IOMMU_BYPASS_USER_OFFSET_SHIFT 18
/*
 * Offset in AxAddr signal from which to take attribute
 * Reset: 0x0         Access: RW
 */
#define NB_SB2NB_PORT_ATTR_SEL_IOMMU_BYPASS_ADDR_OFFSET_MASK 0x1F000000
#define NB_SB2NB_PORT_ATTR_SEL_IOMMU_BYPASS_ADDR_OFFSET_SHIFT 24

/**** attr_sel_iommu_context register ****/
/*
 * Bit-wise selects whether to take attribute from reg_value.
 * Reset: 0x0         Access: RW
 */
#define NB_SB2NB_PORT_ATTR_SEL_IOMMU_CONTEXT_REG_OVRD_MASK 0x0000003F
#define NB_SB2NB_PORT_ATTR_SEL_IOMMU_CONTEXT_REG_OVRD_SHIFT 0
/*
 * Attribute value if taken from register (reg_ovrd set)
 * Reset: 0x0         Access: RW
 */
#define NB_SB2NB_PORT_ATTR_SEL_IOMMU_CONTEXT_REG_VALUE_MASK 0x00000FC0
#define NB_SB2NB_PORT_ATTR_SEL_IOMMU_CONTEXT_REG_VALUE_SHIFT 6
/*
 * Bit-wise selects whether to take attribute from AxUser signal (using user_offset)
 * Reset: 0x3f        Access: RW
 */
#define NB_SB2NB_PORT_ATTR_SEL_IOMMU_CONTEXT_USER_OVRD_MASK 0x0003F000
#define NB_SB2NB_PORT_ATTR_SEL_IOMMU_CONTEXT_USER_OVRD_SHIFT 12
/*
 * Offset in AxUser signal from which to take attribute
 * Reset: 0x4         Access: RW
 */
#define NB_SB2NB_PORT_ATTR_SEL_IOMMU_CONTEXT_USER_OFFSET_MASK 0x003C0000
#define NB_SB2NB_PORT_ATTR_SEL_IOMMU_CONTEXT_USER_OFFSET_SHIFT 18
/*
 * Offset in AxAddr signal from which to take attribute
 * Reset: 0x0         Access: RW
 */
#define NB_SB2NB_PORT_ATTR_SEL_IOMMU_CONTEXT_ADDR_OFFSET_MASK 0x1F000000
#define NB_SB2NB_PORT_ATTR_SEL_IOMMU_CONTEXT_ADDR_OFFSET_SHIFT 24

/**** attr_sel_cache_hit_rd register ****/
/*
 * Bit-wise selects whether to take attribute from reg_value.
 * Reset: 0x1         Access: RW
 */
#define NB_SB2NB_PORT_ATTR_SEL_CACHE_HIT_RD_REG_OVRD (1 << 0)
/*
 * Attribute value if taken from register (reg_ovrd set)
 * Reset: 0x1         Access: RW
 */
#define NB_SB2NB_PORT_ATTR_SEL_CACHE_HIT_RD_REG_VALUE (1 << 6)
/*
 * Bit-wise selects whether to take attribute from AxUser signal (using user_offset)
 * Reset: 0x0         Access: RW
 */
#define NB_SB2NB_PORT_ATTR_SEL_CACHE_HIT_RD_USER_OVRD (1 << 12)
/*
 * Offset in AxUser signal from which to take attribute
 * Reset: 0x0         Access: RW
 */
#define NB_SB2NB_PORT_ATTR_SEL_CACHE_HIT_RD_USER_OFFSET_MASK 0x003C0000
#define NB_SB2NB_PORT_ATTR_SEL_CACHE_HIT_RD_USER_OFFSET_SHIFT 18
/*
 * Offset in AxAddr signal from which to take attribute
 * Reset: 0xa         Access: RW
 */
#define NB_SB2NB_PORT_ATTR_SEL_CACHE_HIT_RD_ADDR_OFFSET_MASK 0x1F000000
#define NB_SB2NB_PORT_ATTR_SEL_CACHE_HIT_RD_ADDR_OFFSET_SHIFT 24

/**** attr_sel_cache_alloc register ****/
/*
 * Bit-wise selects whether to take attribute from reg_value.
 * Reset: 0x0         Access: RW
 */
#define NB_SB2NB_PORT_ATTR_SEL_CACHE_ALLOC_REG_OVRD (1 << 0)
/*
 * Attribute value if taken from register (reg_ovrd set)
 * Reset: 0x0         Access: RW
 */
#define NB_SB2NB_PORT_ATTR_SEL_CACHE_ALLOC_REG_VALUE (1 << 6)
/*
 * Bit-wise selects whether to take attribute from AxUser signal (using user_offset)
 * Reset: 0x0         Access: RW
 */
#define NB_SB2NB_PORT_ATTR_SEL_CACHE_ALLOC_USER_OVRD (1 << 12)
/*
 * Offset in AxUser signal from which to take attribute
 * Reset: 0x0         Access: RW
 */
#define NB_SB2NB_PORT_ATTR_SEL_CACHE_ALLOC_USER_OFFSET_MASK 0x003C0000
#define NB_SB2NB_PORT_ATTR_SEL_CACHE_ALLOC_USER_OFFSET_SHIFT 18
/*
 * Offset in AxAddr signal from which to take attribute
 * Reset: 0xa         Access: RW
 */
#define NB_SB2NB_PORT_ATTR_SEL_CACHE_ALLOC_ADDR_OFFSET_MASK 0x1F000000
#define NB_SB2NB_PORT_ATTR_SEL_CACHE_ALLOC_ADDR_OFFSET_SHIFT 24

/**** cnt_control register ****/
/*
 * System counter enable
 * Counter is enabled after reset.
 * Reset: 0x1         Access: RW
 */
#define NB_SYSTEM_COUNTER_CNT_CONTROL_EN (1 << 0)
/*
 * System counter restart
 * Initial value is reloaded from Counter_Init_L and Counter_Init_H registers.
 * Transition from 0 to 1 reloads the register.
 * Reset: 0x0         Access: RW
 */
#define NB_SYSTEM_COUNTER_CNT_CONTROL_RESTART (1 << 1)
/*
 * Disable CTI trigger out that halt the counter progress
 * Reset: 0x0         Access: RW
 */
#define NB_SYSTEM_COUNTER_CNT_CONTROL_CTI_TRIGOUT_HALT_DIS (1 << 2)
/*
 * System counter tick
 * Specifies the counter tick rate relative to the Northbridge clock, e.g., the counter is
 * incremented every 16 NB cycles if programmed to 0x0f.
 * Reset: 0xf         Access: RW
 */
#define NB_SYSTEM_COUNTER_CNT_CONTROL_SCALE_MASK 0x0000FF00
#define NB_SYSTEM_COUNTER_CNT_CONTROL_SCALE_SHIFT 8

/**** ram register ****/
/*
 * I/O MMU TCU RAMs force power down
 * Reset: 0x0         Access: RW
 */
#define NB_PWR_CTL_RAM_IOMMU_TCU_RAM_FORCE_PD (1 << 0)
/*
 * GIC RAMs force power down
 * Reset: 0x0         Access: RW
 */
#define NB_PWR_CTL_RAM_GIC_RAM_FORCE_PD  (1 << 1)

/**** clocks register ****/
/*
 * Set to 0 to disable clock in DDRC (bit per channel)
 * Reset: 0x3         Access: RW
 */
#define NB_PWR_CTL_CLOCKS_DDRC_EN_MASK   0x00000003
#define NB_PWR_CTL_CLOCKS_DDRC_EN_SHIFT  0
/*
 * Set to 0 to disable clock in DDR PHY (bit per channel)
 * Reset: 0x3         Access: RW
 */
#define NB_PWR_CTL_CLOCKS_DDR_PHY_EN_MASK 0x0000000C
#define NB_PWR_CTL_CLOCKS_DDR_PHY_EN_SHIFT 2

/**** lockn register ****/
/*
 * Semaphore Lock
 * CPU reads it:
 * If current value ==0,  return 0 to CPU but set bit to 1. (CPU knows it captured the semaphore.)
 * If current value ==1, return 1 to CPU. (CPU knows it is already used and waits.)
 * CPU writes 0 to it to release the semaphore.
 * Reset: 0x0         Access: RW
 */
#define NB_SEMAPHORES_LOCKN_LOCK         (1 << 0)

/**** track_dump_ctrl register ****/
/*
 * [24:16]: Queue entry pointer
 * [2] Target queue:  1'b0: HazardTrack or 1'b1: AmiRMI queues
 * [1:0]: CCI target master: 2'b00: M0, 2'b01: M1, 2'b10: M2
 * Reset: 0x0         Access: RW
 */
#define NB_DEBUG_TRACK_DUMP_CTRL_PTR_MASK 0x7FFFFFFF
#define NB_DEBUG_TRACK_DUMP_CTRL_PTR_SHIFT 0
/*
 * Track Dump Request
 * If set, queue entry info is latched on track_dump_rdata register.
 * Program the pointer and target queue.
 * This is a full handshake register.
 * Read <valid> bit from track_dump_rdata register. If set, clear the request field before
 * triggering a new request.
 * Reset: 0x0         Access: RW
 */
#define NB_DEBUG_TRACK_DUMP_CTRL_REQ     (1 << 31)

/**** track_dump_rdata_0 register ****/
/*
 * Valid
 * Reset: 0x0         Access: RO
 */
#define NB_DEBUG_TRACK_DUMP_RDATA_0_VALID (1 << 0)
/*
 * Low data
 * Reset: 0x0         Access: RO
 */
#define NB_DEBUG_TRACK_DUMP_RDATA_0_DATA_MASK 0xFFFFFFFE
#define NB_DEBUG_TRACK_DUMP_RDATA_0_DATA_SHIFT 1

/**** buffers_empty register ****/
/*
 * Transaction logger TML empty (bit per port)
 * Reset: 0x0         Access: RO
 */
#define NB_DEBUG_BUFFERS_EMPTY_LOGGER_TML_MASK 0x0000000F
#define NB_DEBUG_BUFFERS_EMPTY_LOGGER_TML_SHIFT 0
/*
 * Transaction logger read fifo empty (bit per port)
 * Reset: 0x0         Access: RO
 */
#define NB_DEBUG_BUFFERS_EMPTY_LOGGER_RD_FIFO_MASK 0x000000F0
#define NB_DEBUG_BUFFERS_EMPTY_LOGGER_RD_FIFO_SHIFT 4
/*
 * Write splitter empty indication (bit per port)
 * Reset: 0x0         Access: RO
 */
#define NB_DEBUG_BUFFERS_EMPTY_WRSPLT_MASK 0x00000F00
#define NB_DEBUG_BUFFERS_EMPTY_WRSPLT_SHIFT 8
/*
 * I/O read rob empty indication (bit per port)
 * Reset: 0x0         Access: RO
 */
#define NB_DEBUG_BUFFERS_EMPTY_IOROB_MASK 0x0000F000
#define NB_DEBUG_BUFFERS_EMPTY_IOROB_SHIFT 12
/*
 * Write buffer empty indication
 * Reset: 0x0         Access: RO
 */
#define NB_DEBUG_BUFFERS_EMPTY_C2SWB     (1 << 16)
/*
 * PoS empty indication
 * Reset: 0x0         Access: RO
 */
#define NB_DEBUG_BUFFERS_EMPTY_POS       (1 << 17)

/**** pos_track_dump_ctrl register ****/
/*
 * [24:16]: queue entry pointer
 * Reset: 0x0         Access: RW
 */
#define NB_DEBUG_POS_TRACK_DUMP_CTRL_PTR_MASK 0x7FFFFFFF
#define NB_DEBUG_POS_TRACK_DUMP_CTRL_PTR_SHIFT 0
/*
 * Track Dump Request
 * If set, queue entry info is latched on track_dump_rdata register.
 * Program the pointer and target queue.
 * This is a  full handshake register
 * Read <valid> bit from track_dump_rdata register. If set, clear the request field before
 * triggering a new request.
 * Reset: 0x0         Access: RW
 */
#define NB_DEBUG_POS_TRACK_DUMP_CTRL_REQ (1 << 31)

/**** pos_track_dump_rdata_0 register ****/
/*
 * Valid
 * Reset: 0x0         Access: RO
 */
#define NB_DEBUG_POS_TRACK_DUMP_RDATA_0_VALID (1 << 0)
/*
 * Low data
 * Reset: 0x0         Access: RO
 */
#define NB_DEBUG_POS_TRACK_DUMP_RDATA_0_DATA_MASK 0xFFFFFFFE
#define NB_DEBUG_POS_TRACK_DUMP_RDATA_0_DATA_SHIFT 1

/**** c2swb_track_dump_ctrl register ****/
/*
 * [24:16]: Queue entry pointer
 * Reset: 0x0         Access: RW
 */
#define NB_DEBUG_C2SWB_TRACK_DUMP_CTRL_PTR_MASK 0x7FFFFFFF
#define NB_DEBUG_C2SWB_TRACK_DUMP_CTRL_PTR_SHIFT 0
/*
 * Track Dump Request
 * If set, queue entry info is latched on track_dump_rdata register.
 * Program the pointer and target queue.
 * This is a full handshake register
 * Read <valid> bit from track_dump_rdata register. If set, clear the request field before
 * triggering a new request.
 * Reset: 0x0         Access: RW
 */
#define NB_DEBUG_C2SWB_TRACK_DUMP_CTRL_REQ (1 << 31)

/**** c2swb_track_dump_rdata_0 register ****/
/*
 * Valid
 * Reset: 0x0         Access: RO
 */
#define NB_DEBUG_C2SWB_TRACK_DUMP_RDATA_0_VALID (1 << 0)
/*
 * Low data
 * Reset: 0x0         Access: RO
 */
#define NB_DEBUG_C2SWB_TRACK_DUMP_RDATA_0_DATA_MASK 0xFFFFFFFE
#define NB_DEBUG_C2SWB_TRACK_DUMP_RDATA_0_DATA_SHIFT 1

/**** pmu register ****/
/*
 * If set, track events of I/O MMU. Else, track logger events
 * Reset: 0x0         Access: RW
 */
#define NB_DEBUG_PMU_TRACK_IOMMU         (1 << 0)

/**** pmu_sec register ****/
/*
 * If set, allow only secure transactions to access the PMU
 * Reset: 0x1         Access: RW
 */
#define NB_DEBUG_PMU_SEC_TRACK_SECURED_ONLY (1 << 0)

/**** conf register ****/
/*
 * Mask which interrupts to send to SB
 * Reset: 0x0         Access: RW
 */
#define NB_SB_INT_OUT_CONF_MASK_MASK     0x000003FF
#define NB_SB_INT_OUT_CONF_MASK_SHIFT    0
/*
 * Indicate which interrupt was triggered
 * Reset: 0x0         Access: RO
 */
#define NB_SB_INT_OUT_CONF_STATUS_MASK   0x03FF0000
#define NB_SB_INT_OUT_CONF_STATUS_SHIFT  16

/**** version register ****/
/*
 * Revision number (Minor)
 * Reset: 0x0         Access: RO
 */
#define NB_NB_VERSION_VERSION_RELEASE_NUM_MINOR_MASK 0x000000FF
#define NB_NB_VERSION_VERSION_RELEASE_NUM_MINOR_SHIFT 0
/*
 * Revision number (Major)
 * Reset: 0x4         Access: RO
 */
#define NB_NB_VERSION_VERSION_RELEASE_NUM_MAJOR_MASK 0x0000FF00
#define NB_NB_VERSION_VERSION_RELEASE_NUM_MAJOR_SHIFT 8
/*
 * Date of release
 * Reset: 0x0         Access: RO
 */
#define NB_NB_VERSION_VERSION_DATE_DAY_MASK 0x001F0000
#define NB_NB_VERSION_VERSION_DATE_DAY_SHIFT 16
/*
 * Month of release
 * Reset: 0x0         Access: RO
 */
#define NB_NB_VERSION_VERSION_DATA_MONTH_MASK 0x01E00000
#define NB_NB_VERSION_VERSION_DATA_MONTH_SHIFT 21
/*
 * Year of release (starting from 2000)
 * Reset: 0x0         Access: RO
 */
#define NB_NB_VERSION_VERSION_DATE_YEAR_MASK 0x3E000000
#define NB_NB_VERSION_VERSION_DATE_YEAR_SHIFT 25
/*
 * Reserved
 * Reset: 0x0         Access: RO
 */
#define NB_NB_VERSION_VERSION_RESERVED_MASK 0xC0000000
#define NB_NB_VERSION_VERSION_RESERVED_SHIFT 30

/**** pp_config register ****/
/*
 * Bypass PP module (formality equivalent)
 * Reset: 0x1         Access: RW
 */
#define NB_PUSH_PACKET_PP_CONFIG_FM_BYPASS (1 << 0)
/*
 * Bypass PP module
 * Reset: 0x0         Access: RW
 */
#define NB_PUSH_PACKET_PP_CONFIG_BYPASS  (1 << 1)
/*
 * Force Cleanup of entries
 * Reset: 0x0         Access: RW
 */
#define NB_PUSH_PACKET_PP_CONFIG_CLEAR   (1 << 2)
/*
 * Enable forwarding DECERR response
 * Reset: 0x1         Access: RW
 */
#define NB_PUSH_PACKET_PP_CONFIG_DECERR_EN (1 << 3)
/*
 * Enable forwarding SLVERR response
 * Reset: 0x1         Access: RW
 */
#define NB_PUSH_PACKET_PP_CONFIG_SLVERR_EN (1 << 4)
/*
 * Enable forwarding of data parity generation
 * Reset: 0x1         Access: RW
 */
#define NB_PUSH_PACKET_PP_CONFIG_PAR_GEN_EN (1 << 5)
/*
 * Select channel on 8K boundaries ([15:13]) instead of 64k boundaries ([18:16]).
 * Reset: 0x1         Access: RW
 */
#define NB_PUSH_PACKET_PP_CONFIG_SEL_8K  (1 << 6)
/*
 * Forces aattribute to be as configured in ext_attr register.
 * Not functional
 * Reset: 0x0         Access: RW
 */
#define NB_PUSH_PACKET_PP_CONFIG_SEL_EXT_ATTR (1 << 7)
/*
 * parity reporting of the sram output
 * Reset: 0x1         Access: RW
 */
#define NB_PUSH_PACKET_PP_CONFIG_PAR_ERR_EN (1 << 8)
/*
 * data parity invert if parity error was detected on the data beat coming from the sram
 * Reset: 0x1         Access: RW
 */
#define NB_PUSH_PACKET_PP_CONFIG_PAR_ERR_FWD_EN (1 << 9)
/*
 * Power down push packet memory
 * Reset: 0x0         Access: RW
 */
#define NB_PUSH_PACKET_PP_CONFIG_RAM_PD  (1 << 31)

/**** pp_ext_attr register ****/
/*
 * Attribute to use on PP transactions
 * Only applicable if <sel_ext_attr> is set to 1'b1
 * Parity bits are still generated per transaction
 * Reset: 0x0         Access: RW
 */
#define NB_PUSH_PACKET_PP_EXT_ATTR_VAL_MASK 0x03FFFFFF
#define NB_PUSH_PACKET_PP_EXT_ATTR_VAL_SHIFT 0

/**** pp_sel_attr register ****/
/*
 * Select whether to use addr[63:48] or PP awmisc as tgtid.
 * Each bit if set to 1 selects the corresponding address bit. Otherwise, selects the corersponding
 * awmisc bit.
 * Reset: 0x0         Access: RW
 */
#define NB_PUSH_PACKET_PP_SEL_ATTR_VAL_MASK 0x0000FFFF
#define NB_PUSH_PACKET_PP_SEL_ATTR_VAL_SHIFT 0

/**** pp_err_log register ****/
/*
 * Indicate parity error in push packet SRAM
 * Reset: 0x0         Access: RO, RtoClr
 */
#define NB_PUSH_PACKET_PP_ERR_LOG_VALID  (1 << 0)
/*
 * SRAM address that caused the parity error
 * Reset: 0x0         Access: RO
 */
#define NB_PUSH_PACKET_PP_ERR_LOG_PTR_MASK 0x003F0000
#define NB_PUSH_PACKET_PP_ERR_LOG_PTR_SHIFT 16

/**** cfg register ****/
/*
 * Enables PP channel.
 * Reset: 0x0         Access: RW
 */
#define NB_PUSH_PACKET_CHANNEL_CFG_ENABLE (1 << 0)

/**** ddr_cpu_bar0_low register ****/
/*
 * Window size = 2 ^ (15 + win_size). Zero value: disable the window.
 * Reset: 0x10        Access: RW
 */
#define NB_ADDRESS_MAP_DDR_CPU_BAR0_LOW_WIN_SIZE_MASK 0x0000003F
#define NB_ADDRESS_MAP_DDR_CPU_BAR0_LOW_WIN_SIZE_SHIFT 0
/*
 * DRAM channel
 * 1: DRAM0
 * 2: DRAM1
 * 3: Interleave DRAM0 / DRAM1
 * Reset: 0x1         Access: RW
 */
#define NB_ADDRESS_MAP_DDR_CPU_BAR0_LOW_PORT_MASK 0x00000F00
#define NB_ADDRESS_MAP_DDR_CPU_BAR0_LOW_PORT_SHIFT 8
/*
 * Target Memory
 * 0: DRAM
 * 1: SRAM
 * Reset: 0x0         Access: RW
 */
#define NB_ADDRESS_MAP_DDR_CPU_BAR0_LOW_TARGET_MEMORY (1 << 12)
/*
 * Bar low address bits [31:16]
 * Reset: 0x0         Access: RW
 */
#define NB_ADDRESS_MAP_DDR_CPU_BAR0_LOW_ADDR_LOW_MASK 0xFFFF0000
#define NB_ADDRESS_MAP_DDR_CPU_BAR0_LOW_ADDR_LOW_SHIFT 16

/**** ddr_cpu_bar0_high register ****/
/*
 * Bar high address bits
 * Reset: 0x0         Access: RW
 */
#define NB_ADDRESS_MAP_DDR_CPU_BAR0_HIGH_ADDR_HIGH_MASK 0x000000FF
#define NB_ADDRESS_MAP_DDR_CPU_BAR0_HIGH_ADDR_HIGH_SHIFT 0

/**** ddr_cpu_bar1_low register ****/
/*
 * Window size = 2 ^ (15 + win_size). Zero value: disable the window.
 * Reset: 0xf         Access: RW
 */
#define NB_ADDRESS_MAP_DDR_CPU_BAR1_LOW_WIN_SIZE_MASK 0x0000003F
#define NB_ADDRESS_MAP_DDR_CPU_BAR1_LOW_WIN_SIZE_SHIFT 0
/*
 * DRAM channel
 * 1: DRAM0
 * 2: DRAM1
 * 3: Interleave DRAM0 / DRAM1
 * Reset: 0x1         Access: RW
 */
#define NB_ADDRESS_MAP_DDR_CPU_BAR1_LOW_PORT_MASK 0x00000F00
#define NB_ADDRESS_MAP_DDR_CPU_BAR1_LOW_PORT_SHIFT 8
/*
 * Target Memory
 * 0: DRAM
 * 1: SRAM
 * Reset: 0x0         Access: RW
 */
#define NB_ADDRESS_MAP_DDR_CPU_BAR1_LOW_TARGET_MEMORY (1 << 12)
/*
 * Bar low address bits [31:16]
 * Reset: 0x8000      Access: RW
 */
#define NB_ADDRESS_MAP_DDR_CPU_BAR1_LOW_ADDR_LOW_MASK 0xFFFF0000
#define NB_ADDRESS_MAP_DDR_CPU_BAR1_LOW_ADDR_LOW_SHIFT 16

/**** ddr_cpu_bar1_high register ****/
/*
 * Bar high address bits
 * Reset: 0x0         Access: RW
 */
#define NB_ADDRESS_MAP_DDR_CPU_BAR1_HIGH_ADDR_HIGH_MASK 0x000000FF
#define NB_ADDRESS_MAP_DDR_CPU_BAR1_HIGH_ADDR_HIGH_SHIFT 0

/**** ddr_cpu_bar2_low register ****/
/*
 * Window size = 2 ^ (15 + win_size). Zero value: disable the window.
 * Reset: 0x11        Access: RW
 */
#define NB_ADDRESS_MAP_DDR_CPU_BAR2_LOW_WIN_SIZE_MASK 0x0000003F
#define NB_ADDRESS_MAP_DDR_CPU_BAR2_LOW_WIN_SIZE_SHIFT 0
/*
 * DRAM channel
 * 1: DRAM0
 * 2: DRAM1
 * 3: Interleave DRAM0 / DRAM1
 * Reset: 0x1         Access: RW
 */
#define NB_ADDRESS_MAP_DDR_CPU_BAR2_LOW_PORT_MASK 0x00000F00
#define NB_ADDRESS_MAP_DDR_CPU_BAR2_LOW_PORT_SHIFT 8
/*
 * Target Memory
 * 0: DRAM
 * 1: SRAM
 * Reset: 0x0         Access: RW
 */
#define NB_ADDRESS_MAP_DDR_CPU_BAR2_LOW_TARGET_MEMORY (1 << 12)
/*
 * Bar low address bits [31:16]
 * Reset: 0x0         Access: RW
 */
#define NB_ADDRESS_MAP_DDR_CPU_BAR2_LOW_ADDR_LOW_MASK 0xFFFF0000
#define NB_ADDRESS_MAP_DDR_CPU_BAR2_LOW_ADDR_LOW_SHIFT 16

/**** ddr_cpu_bar2_high register ****/
/*
 * Bar high address bits
 * Reset: 0x1         Access: RW
 */
#define NB_ADDRESS_MAP_DDR_CPU_BAR2_HIGH_ADDR_HIGH_MASK 0x000000FF
#define NB_ADDRESS_MAP_DDR_CPU_BAR2_HIGH_ADDR_HIGH_SHIFT 0

/**** ddr_cpu_bar3_low register ****/
/*
 * Window size = 2 ^ (15 + win_size). Zero value: disable the window.
 * Reset: 0xf         Access: RW
 */
#define NB_ADDRESS_MAP_DDR_CPU_BAR3_LOW_WIN_SIZE_MASK 0x0000003F
#define NB_ADDRESS_MAP_DDR_CPU_BAR3_LOW_WIN_SIZE_SHIFT 0
/*
 * DRAM channel
 * 1: DRAM0
 * 2: DRAM1
 * 3: Interleave DRAM0 / DRAM1
 * Reset: 0x1         Access: RW
 */
#define NB_ADDRESS_MAP_DDR_CPU_BAR3_LOW_PORT_MASK 0x00000F00
#define NB_ADDRESS_MAP_DDR_CPU_BAR3_LOW_PORT_SHIFT 8
/*
 * Target Memory
 * 0: DRAM
 * 1: SRAM
 * Reset: 0x0         Access: RW
 */
#define NB_ADDRESS_MAP_DDR_CPU_BAR3_LOW_TARGET_MEMORY (1 << 12)
/*
 * Bar low address bits [31:16]
 * Reset: 0x0         Access: RW
 */
#define NB_ADDRESS_MAP_DDR_CPU_BAR3_LOW_ADDR_LOW_MASK 0xFFFF0000
#define NB_ADDRESS_MAP_DDR_CPU_BAR3_LOW_ADDR_LOW_SHIFT 16

/**** ddr_cpu_bar3_high register ****/
/*
 * Bar high address bits
 * Reset: 0x2         Access: RW
 */
#define NB_ADDRESS_MAP_DDR_CPU_BAR3_HIGH_ADDR_HIGH_MASK 0x000000FF
#define NB_ADDRESS_MAP_DDR_CPU_BAR3_HIGH_ADDR_HIGH_SHIFT 0

/**** ddr_cpu_bar4_low register ****/
/*
 * Window size = 2 ^ (15 + win_size). Zero value: disable the window.
 * Reset: 0x0         Access: RW
 */
#define NB_ADDRESS_MAP_DDR_CPU_BAR4_LOW_WIN_SIZE_MASK 0x0000003F
#define NB_ADDRESS_MAP_DDR_CPU_BAR4_LOW_WIN_SIZE_SHIFT 0
/*
 * DRAM channel
 * 1: DRAM0
 * 2: DRAM1
 * 3: Interleave DRAM0 / DRAM1
 * Reset: 0x1         Access: RW
 */
#define NB_ADDRESS_MAP_DDR_CPU_BAR4_LOW_PORT_MASK 0x00000F00
#define NB_ADDRESS_MAP_DDR_CPU_BAR4_LOW_PORT_SHIFT 8
/*
 * Target Memory
 * 0: DRAM
 * 1: SRAM
 * Reset: 0x0         Access: RW
 */
#define NB_ADDRESS_MAP_DDR_CPU_BAR4_LOW_TARGET_MEMORY (1 << 12)
/*
 * Bar low address bits [31:16]
 * Reset: 0x0         Access: RW
 */
#define NB_ADDRESS_MAP_DDR_CPU_BAR4_LOW_ADDR_LOW_MASK 0xFFFF0000
#define NB_ADDRESS_MAP_DDR_CPU_BAR4_LOW_ADDR_LOW_SHIFT 16

/**** ddr_cpu_bar4_high register ****/
/*
 * Bar high address bits
 * Reset: 0x0         Access: RW
 */
#define NB_ADDRESS_MAP_DDR_CPU_BAR4_HIGH_ADDR_HIGH_MASK 0x000000FF
#define NB_ADDRESS_MAP_DDR_CPU_BAR4_HIGH_ADDR_HIGH_SHIFT 0

/**** ddr_cpu_bar5_low register ****/
/*
 * Window size = 2 ^ (15 + win_size). Zero value: disable the window.
 * Reset: 0x0         Access: RW
 */
#define NB_ADDRESS_MAP_DDR_CPU_BAR5_LOW_WIN_SIZE_MASK 0x0000003F
#define NB_ADDRESS_MAP_DDR_CPU_BAR5_LOW_WIN_SIZE_SHIFT 0
/*
 * DRAM channel
 * 1: DRAM0
 * 2: DRAM1
 * 3: Interleave DRAM0 / DRAM1
 * Reset: 0x1         Access: RW
 */
#define NB_ADDRESS_MAP_DDR_CPU_BAR5_LOW_PORT_MASK 0x00000F00
#define NB_ADDRESS_MAP_DDR_CPU_BAR5_LOW_PORT_SHIFT 8
/*
 * Target Memory
 * 0: DRAM
 * 1: SRAM
 * Reset: 0x0         Access: RW
 */
#define NB_ADDRESS_MAP_DDR_CPU_BAR5_LOW_TARGET_MEMORY (1 << 12)
/*
 * Bar low address bits [31:16]
 * Reset: 0x0         Access: RW
 */
#define NB_ADDRESS_MAP_DDR_CPU_BAR5_LOW_ADDR_LOW_MASK 0xFFFF0000
#define NB_ADDRESS_MAP_DDR_CPU_BAR5_LOW_ADDR_LOW_SHIFT 16

/**** ddr_cpu_bar5_high register ****/
/*
 * Bar high address bits
 * Reset: 0x0         Access: RW
 */
#define NB_ADDRESS_MAP_DDR_CPU_BAR5_HIGH_ADDR_HIGH_MASK 0x000000FF
#define NB_ADDRESS_MAP_DDR_CPU_BAR5_HIGH_ADDR_HIGH_SHIFT 0

/**** ddr_io_bar0_low register ****/
/*
 * Window size = 2 ^ (15 + win_size). Zero value: disable the window.
 * Reset: 0x10        Access: RW
 */
#define NB_ADDRESS_MAP_DDR_IO_BAR0_LOW_WIN_SIZE_MASK 0x0000003F
#define NB_ADDRESS_MAP_DDR_IO_BAR0_LOW_WIN_SIZE_SHIFT 0
/*
 * DRAM channel
 * 1: DRAM0
 * 2: DRAM1
 * 3: Interleave DRAM0 / DRAM1
 * Reset: 0x1         Access: RW
 */
#define NB_ADDRESS_MAP_DDR_IO_BAR0_LOW_PORT_MASK 0x00000F00
#define NB_ADDRESS_MAP_DDR_IO_BAR0_LOW_PORT_SHIFT 8
/*
 * Target Memory
 * 0: DRAM
 * 1: SRAM
 * Reset: 0x0         Access: RW
 */
#define NB_ADDRESS_MAP_DDR_IO_BAR0_LOW_TARGET_MEMORY (1 << 12)
/*
 * Bar low address bits [31:16]
 * Reset: 0x0         Access: RW
 */
#define NB_ADDRESS_MAP_DDR_IO_BAR0_LOW_ADDR_LOW_MASK 0xFFFF0000
#define NB_ADDRESS_MAP_DDR_IO_BAR0_LOW_ADDR_LOW_SHIFT 16

/**** ddr_io_bar0_high register ****/
/*
 * Bar high address bits
 * Reset: 0x0         Access: RW
 */
#define NB_ADDRESS_MAP_DDR_IO_BAR0_HIGH_ADDR_HIGH_MASK 0x000000FF
#define NB_ADDRESS_MAP_DDR_IO_BAR0_HIGH_ADDR_HIGH_SHIFT 0

/**** ddr_io_bar1_low register ****/
/*
 * Window size = 2 ^ (15 + win_size). Zero value: disable the window.
 * Reset: 0xf         Access: RW
 */
#define NB_ADDRESS_MAP_DDR_IO_BAR1_LOW_WIN_SIZE_MASK 0x0000003F
#define NB_ADDRESS_MAP_DDR_IO_BAR1_LOW_WIN_SIZE_SHIFT 0
/*
 * DRAM channel
 * 1: DRAM0
 * 2: DRAM1
 * 3: Interleave DRAM0 / DRAM1
 * Reset: 0x1         Access: RW
 */
#define NB_ADDRESS_MAP_DDR_IO_BAR1_LOW_PORT_MASK 0x00000F00
#define NB_ADDRESS_MAP_DDR_IO_BAR1_LOW_PORT_SHIFT 8
/*
 * Target Memory
 * 0: DRAM
 * 1: SRAM
 * Reset: 0x0         Access: RW
 */
#define NB_ADDRESS_MAP_DDR_IO_BAR1_LOW_TARGET_MEMORY (1 << 12)
/*
 * Bar low address bits [31:16]
 * Reset: 0x8000      Access: RW
 */
#define NB_ADDRESS_MAP_DDR_IO_BAR1_LOW_ADDR_LOW_MASK 0xFFFF0000
#define NB_ADDRESS_MAP_DDR_IO_BAR1_LOW_ADDR_LOW_SHIFT 16

/**** ddr_io_bar1_high register ****/
/*
 * Bar high address bits
 * Reset: 0x0         Access: RW
 */
#define NB_ADDRESS_MAP_DDR_IO_BAR1_HIGH_ADDR_HIGH_MASK 0x000000FF
#define NB_ADDRESS_MAP_DDR_IO_BAR1_HIGH_ADDR_HIGH_SHIFT 0

/**** ddr_io_bar2_low register ****/
/*
 * Window size = 2 ^ (15 + win_size). Zero value: disable the window.
 * Reset: 0x11        Access: RW
 */
#define NB_ADDRESS_MAP_DDR_IO_BAR2_LOW_WIN_SIZE_MASK 0x0000003F
#define NB_ADDRESS_MAP_DDR_IO_BAR2_LOW_WIN_SIZE_SHIFT 0
/*
 * DRAM channel
 * 1: DRAM0
 * 2: DRAM1
 * 3: Interleave DRAM0 / DRAM1
 * Reset: 0x1         Access: RW
 */
#define NB_ADDRESS_MAP_DDR_IO_BAR2_LOW_PORT_MASK 0x00000F00
#define NB_ADDRESS_MAP_DDR_IO_BAR2_LOW_PORT_SHIFT 8
/*
 * Target Memory
 * 0: DRAM
 * 1: SRAM
 * Reset: 0x0         Access: RW
 */
#define NB_ADDRESS_MAP_DDR_IO_BAR2_LOW_TARGET_MEMORY (1 << 12)
/*
 * Bar low address bits [31:16]
 * Reset: 0x0         Access: RW
 */
#define NB_ADDRESS_MAP_DDR_IO_BAR2_LOW_ADDR_LOW_MASK 0xFFFF0000
#define NB_ADDRESS_MAP_DDR_IO_BAR2_LOW_ADDR_LOW_SHIFT 16

/**** ddr_io_bar2_high register ****/
/*
 * Bar high address bits
 * Reset: 0x1         Access: RW
 */
#define NB_ADDRESS_MAP_DDR_IO_BAR2_HIGH_ADDR_HIGH_MASK 0x000000FF
#define NB_ADDRESS_MAP_DDR_IO_BAR2_HIGH_ADDR_HIGH_SHIFT 0

/**** ddr_io_bar3_low register ****/
/*
 * Window size = 2 ^ (15 + win_size). Zero value: disable the window.
 * Reset: 0xf         Access: RW
 */
#define NB_ADDRESS_MAP_DDR_IO_BAR3_LOW_WIN_SIZE_MASK 0x0000003F
#define NB_ADDRESS_MAP_DDR_IO_BAR3_LOW_WIN_SIZE_SHIFT 0
/*
 * DRAM channel
 * 1: DRAM0
 * 2: DRAM1
 * 3: Interleave DRAM0 / DRAM1
 * Reset: 0x1         Access: RW
 */
#define NB_ADDRESS_MAP_DDR_IO_BAR3_LOW_PORT_MASK 0x00000F00
#define NB_ADDRESS_MAP_DDR_IO_BAR3_LOW_PORT_SHIFT 8
/*
 * Target Memory
 * 0: DRAM
 * 1: SRAM
 * Reset: 0x0         Access: RW
 */
#define NB_ADDRESS_MAP_DDR_IO_BAR3_LOW_TARGET_MEMORY (1 << 12)
/*
 * Bar low address bits [31:16]
 * Reset: 0x0         Access: RW
 */
#define NB_ADDRESS_MAP_DDR_IO_BAR3_LOW_ADDR_LOW_MASK 0xFFFF0000
#define NB_ADDRESS_MAP_DDR_IO_BAR3_LOW_ADDR_LOW_SHIFT 16

/**** ddr_io_bar3_high register ****/
/*
 * Bar high address bits
 * Reset: 0x2         Access: RW
 */
#define NB_ADDRESS_MAP_DDR_IO_BAR3_HIGH_ADDR_HIGH_MASK 0x000000FF
#define NB_ADDRESS_MAP_DDR_IO_BAR3_HIGH_ADDR_HIGH_SHIFT 0

/**** ddr_io_bar4_low register ****/
/*
 * Window size = 2 ^ (15 + win_size). Zero value: disable the window.
 * Reset: 0x0         Access: RW
 */
#define NB_ADDRESS_MAP_DDR_IO_BAR4_LOW_WIN_SIZE_MASK 0x0000003F
#define NB_ADDRESS_MAP_DDR_IO_BAR4_LOW_WIN_SIZE_SHIFT 0
/*
 * DRAM channel
 * 1: DRAM0
 * 2: DRAM1
 * 3: Interleave DRAM0 / DRAM1
 * Reset: 0x1         Access: RW
 */
#define NB_ADDRESS_MAP_DDR_IO_BAR4_LOW_PORT_MASK 0x00000F00
#define NB_ADDRESS_MAP_DDR_IO_BAR4_LOW_PORT_SHIFT 8
/*
 * Target Memory
 * 0: DRAM
 * 1: SRAM
 * Reset: 0x0         Access: RW
 */
#define NB_ADDRESS_MAP_DDR_IO_BAR4_LOW_TARGET_MEMORY (1 << 12)
/*
 * Bar low address bits [31:16]
 * Reset: 0x0         Access: RW
 */
#define NB_ADDRESS_MAP_DDR_IO_BAR4_LOW_ADDR_LOW_MASK 0xFFFF0000
#define NB_ADDRESS_MAP_DDR_IO_BAR4_LOW_ADDR_LOW_SHIFT 16

/**** ddr_io_bar4_high register ****/
/*
 * Bar high address bits
 * Reset: 0x0         Access: RW
 */
#define NB_ADDRESS_MAP_DDR_IO_BAR4_HIGH_ADDR_HIGH_MASK 0x000000FF
#define NB_ADDRESS_MAP_DDR_IO_BAR4_HIGH_ADDR_HIGH_SHIFT 0

/**** ddr_io_bar5_low register ****/
/*
 * Window size = 2 ^ (15 + win_size). Zero value: disable the window.
 * Reset: 0x0         Access: RW
 */
#define NB_ADDRESS_MAP_DDR_IO_BAR5_LOW_WIN_SIZE_MASK 0x0000003F
#define NB_ADDRESS_MAP_DDR_IO_BAR5_LOW_WIN_SIZE_SHIFT 0
/*
 * DRAM channel
 * 1: DRAM0
 * 2: DRAM1
 * 3: Interleave DRAM0 / DRAM1
 * Reset: 0x1         Access: RW
 */
#define NB_ADDRESS_MAP_DDR_IO_BAR5_LOW_PORT_MASK 0x00000F00
#define NB_ADDRESS_MAP_DDR_IO_BAR5_LOW_PORT_SHIFT 8
/*
 * Target Memory
 * 0: DRAM
 * 1: SRAM
 * Reset: 0x0         Access: RW
 */
#define NB_ADDRESS_MAP_DDR_IO_BAR5_LOW_TARGET_MEMORY (1 << 12)
/*
 * Bar low address bits [31:16]
 * Reset: 0x0         Access: RW
 */
#define NB_ADDRESS_MAP_DDR_IO_BAR5_LOW_ADDR_LOW_MASK 0xFFFF0000
#define NB_ADDRESS_MAP_DDR_IO_BAR5_LOW_ADDR_LOW_SHIFT 16

/**** ddr_io_bar5_high register ****/
/*
 * Bar high address bits
 * Reset: 0x0         Access: RW
 */
#define NB_ADDRESS_MAP_DDR_IO_BAR5_HIGH_ADDR_HIGH_MASK 0x000000FF
#define NB_ADDRESS_MAP_DDR_IO_BAR5_HIGH_ADDR_HIGH_SHIFT 0

/**** msix_bar_low register ****/
/*
 * Window size = 2 ^ (15 + win_size). Zero value: disable the window.
 * Reset: 0x5         Access: RW
 */
#define NB_ADDRESS_MAP_MSIX_BAR_LOW_WIN_SIZE_MASK 0x0000003F
#define NB_ADDRESS_MAP_MSIX_BAR_LOW_WIN_SIZE_SHIFT 0
/*
 * Bar low address bits [31:16]
 * Reset: 0xfbe0      Access: RW
 */
#define NB_ADDRESS_MAP_MSIX_BAR_LOW_ADDR_LOW_MASK 0xFFFF0000
#define NB_ADDRESS_MAP_MSIX_BAR_LOW_ADDR_LOW_SHIFT 16

/**** msix_bar_high register ****/
/*
 * Bar high address bits
 * Reset: 0x0         Access: RW
 */
#define NB_ADDRESS_MAP_MSIX_BAR_HIGH_ADDR_HIGH_MASK 0x000000FF
#define NB_ADDRESS_MAP_MSIX_BAR_HIGH_ADDR_HIGH_SHIFT 0

/**** dram_remap register ****/
/*
 * Window size = 2^(28 + win_size). Zero value: disable the window.
 * Reset: 0x2         Access: RW
 */
#define NB_ADDRESS_MAP_DRAM_REMAP_WIN_SIZE_MASK 0x0000000F
#define NB_ADDRESS_MAP_DRAM_REMAP_WIN_SIZE_SHIFT 0
/*
 * Base Address window corresponding to address bits [39:29].
 * Reset: 0x10        Access: RW
 */
#define NB_ADDRESS_MAP_DRAM_REMAP_ADDR_MASK 0x0000FFE0
#define NB_ADDRESS_MAP_DRAM_REMAP_ADDR_SHIFT 5
/*
 * Translated Base Address corresponding to address bits [39:29].
 * Reset: 0x6         Access: RW
 */
#define NB_ADDRESS_MAP_DRAM_REMAP_TRANS_ADDR_MASK 0xFFE00000
#define NB_ADDRESS_MAP_DRAM_REMAP_TRANS_ADDR_SHIFT 21

/**** config register ****/
/*
 * Stripe bit
 * Determines on which granularity the DRAM's are interleaved
 * Address bit = 5+stripe_bit. Zero value: no interleave
 * Reset: 0x0         Access: RW
 */
#define NB_ADDRESS_MAP_CONFIG_STRIPE_BIT_MASK 0x0000000F
#define NB_ADDRESS_MAP_CONFIG_STRIPE_BIT_SHIFT 0
/*
 * Determines if address decoder will override the SRAM access attribute.
 * If not set, allow propagation of attribute from incoming transaction.
 * Reset: 0x1         Access: RW
 */
#define NB_ADDRESS_MAP_CONFIG_SRAM_OVRD  (1 << 4)
/*
 * Determines to which MSIx distributor to send the MSIx transaction.
 * One bit per each CCU slave port.
 * 0: send to distributor 0
 * 1: send to distributor 1
 * Reset: 0x0         Access: RW
 */
#define NB_ADDRESS_MAP_CONFIG_MSIX_TARGET_MASK 0x00007F00
#define NB_ADDRESS_MAP_CONFIG_MSIX_TARGET_SHIFT 8

/**** latch_bars register ****/
/*
 * Software clears this bit before any bar update, and set it after all bars updated.
 * Reset: 0x1         Access: RW
 */
#define NB_ADDRESS_MAP_LATCH_BARS_ENABLE (1 << 0)

#ifdef __cplusplus
}
#endif

#endif

/** @} */
