/*
 * Copyright 2018, Amazon.com, Inc. or its affiliates. All Rights Reserved
 */

/**
 *  @{
 * @file   al_hal_anpa_regs.h
 *
 * @brief anpa registers
 *
 * This file was auto-generated by RegGen v1.2.1
 *
 */

#ifndef __AL_HAL_ANPA_REGS_H__
#define __AL_HAL_ANPA_REGS_H__

#include "al_hal_plat_types.h"

#ifdef __cplusplus
extern "C" {
#endif

/*
 * Unit Registers
 */

struct al_anpa_global {
	/* [0x0] ANPA Revision */
	uint32_t ver;
	/*
	 * [0x4] Allow non-secure access to secure registers.
	 * Each bit disables security for one register
	 * This register is accessible in secure mode only
	 * Reset: 0x0         Access: RW
	 */
	uint32_t cluster_sec_ovrd;
	/* [0x8] */
	uint32_t cluster_config;
	/* [0xc] */
	uint32_t clusterid;
	/* [0x10] Force init reset. */
	uint32_t cpus_init_control;
	/* [0x14] Force init reset per DECEI mode. */
	uint32_t cpus_init_status;
	/* [0x18] */
	uint32_t rsrvd_0[2];
	/* [0x20] */
	uint32_t cpus_hold_reset;
	/* [0x24] */
	uint32_t cpus_software_reset;
	/* [0x28] */
	uint32_t rsrvd_1[2];
	/* [0x30] */
	uint32_t wd_timer0_reset;
	/* [0x34] */
	uint32_t wd_timer1_reset;
	/* [0x38] */
	uint32_t wd_timer2_reset;
	/* [0x3c] */
	uint32_t wd_timer3_reset;
	/* [0x40] */
	uint32_t wd_timer4_reset;
	/* [0x44] */
	uint32_t wd_timer5_reset;
	/* [0x48] */
	uint32_t wd_timer6_reset;
	/* [0x4c] */
	uint32_t wd_timer7_reset;
	/* [0x50] */
	uint32_t rsrvd_2[4];
	/* [0x60] */
	uint32_t cpus_power_ctrl;
	/*
	 * [0x64] Timers between switch shut downs
	 * Reset: 0xfff       Access: RW
	 */
	uint32_t core_max_pd_timer;
	/*
	 * [0x68] Timers between switch wake ups
	 * Reset: 0xfff       Access: RW
	 */
	uint32_t core_max_pu_timer;
	/* [0x6c] */
	uint32_t ram_pu_pause;
	/*
	 * [0x70] Timeout after which request to external power controller will not be sent until
	 * all current power sequences in cluster are complete.
	 * Set to zero to disable the timeout.
	 * Reset: 0xffffffff  Access: RW
	 */
	uint32_t ext_power_ctrl_timeout;
	/* [0x74] */
	uint32_t rsrvd_3[3];
	/* [0x80] */
	uint32_t axi_parity;
	/* [0x84] */
	uint32_t rsrvd_4[31];
	/*
	 * [0x100] General config bus to cpu
	 * [2:0] Select feedback VDD-V from {NonCPU, CPU3,2,1,0}, ordered 4 to 0 binary
	 * [3] Enable VDD Vir feedback
	 * [6:4] Select feedback VDD-V from {NonCPU, CPU3,2,1,0}, ordered 4 to 0 binary
	 * [7] Enable VDD Real feedback
	 * [27:26] ATCLKEN ratio - 00=1:2, 01=1:1, 10=1:4, 11=1:3
	 * [28] Disable barrier broadcasting
	 * [31] Romtable override disable
	 * Reset: 0x0         Access: RW
	 */
	uint32_t general;
	/*
	 * [0x104] General config bus to cpu
	 * Reset: 0x0         Access: RW
	 */
	uint32_t general_1;
	/*
	 * [0x108] For ECO
	 * Reset: 0x0         Access: RW
	 */
	uint32_t rsv0;
	/*
	 * [0x10c] For ECO
	 * Reset: 0x0         Access: RW
	 */
	uint32_t rsv1;
	/*
	 * [0x110] For ECO
	 * Reset: 0xffffffff  Access: RW
	 */
	uint32_t rsv2;
	/*
	 * [0x114] For ECO
	 * Reset: 0xffffffff  Access: RW
	 */
	uint32_t rsv3;
	/* [0x118] */
	uint32_t rsrvd_5[186];
};

struct al_anpa_rams_control {
	/*
	 * [0x0]
	 * Reset: 0xffffffff  Access: RW
	 */
	uint32_t rf_0;
	/*
	 * [0x4]
	 * Reset: 0xffffffff  Access: RW
	 */
	uint32_t rf_1;
	/*
	 * [0x8]
	 * Reset: 0xffffffff  Access: RW
	 */
	uint32_t rf_2;
	/* [0xc] */
	uint32_t rf_misc;
};

struct al_anpa_cluster_debug {
	/* [0x0] */
	uint32_t rsrvd_0;
	/* [0x4] */
	uint32_t outputs;
	/* [0x8] */
	uint32_t rsrvd_1[2];
	/* [0x10] */
	uint32_t latch_pc_req;
	/* [0x14] */
	uint32_t rsrvd_2;
	/* [0x18] */
	uint32_t latch_pc_low;
	/*
	 * [0x1c] Latched PC value [63:32]
	 * Reset: 0x0         Access: RW
	 */
	uint32_t latch_pc_high;
	/* [0x20] */
	uint32_t track_dump_ctrl;
	/* [0x24] */
	uint32_t track_dump_rdata_0;
	/*
	 * [0x28] High data
	 * Reset: 0x0         Access: RO
	 */
	uint32_t track_dump_rdata_1;
	/* [0x2c] */
	uint32_t rsrvd_3[5];
	/* [0x40] */
	uint32_t pmu;
	/* [0x44] */
	uint32_t pmu_sec;
	/* [0x48] */
	uint32_t pmu_pd;
	/* [0x4c] */
	uint32_t rsrvd_4[109];
};

struct al_anpa_coresight {
	/* [0x0] */
	uint32_t pd;
	/* [0x4] */
	uint32_t ctm;
	/* [0x8] */
	uint32_t rsrvd_0[2];
	/*
	 * [0x10] [31:28] Peripheral ID2 [7:4]
	 * [27:24] Peripheral ID1 [3:0]
	 * [23:16] Peripheral ID0 [7:0]
	 * [15:12] Drive LOW
	 * [11:8] Peripheral ID4 [3:0]
	 * [7:5] Peripheral ID2 [2:0]
	 * [4:1] Peripheral ID1 [7:4]
	 * [0] Drive HIGH
	 * Reset: 0x29080877  Access: RW
	 */
	uint32_t targetid;
	/* [0x14] */
	uint32_t rsrvd_1;
	/* [0x18] */
	uint32_t cti_0;
	/* [0x1c] */
	uint32_t cti_1;
	/* [0x20] */
	uint32_t rsrvd_2[120];
};

struct al_anpa_per_core {
	/*
	 * [0x0] Allow non-secure access to secure registers.
	 * Each bit disables security for one register
	 * This register is accessible only in secure mode
	 * Reset: 0x0         Access: RW
	 */
	uint32_t sec_ovrd;
	/* [0x4] This configuration is only sampled during reset of the processor. */
	uint32_t config;
	/* [0x8] This configuration is only sampled during reset of the processor. */
	uint32_t aarch64;
	/* [0xc] */
	uint32_t debug_sec;
	/* [0x10] */
	uint32_t rsrvd_0[4];
	/* [0x20] Specifies the state of the CPU with reference to power modes. */
	uint32_t power_ctrl;
	/* [0x24] */
	uint32_t power_status;
	/* [0x28] */
	uint32_t rsrvd_1[2];
	/*
	 * [0x30] Resume address low
	 * Reset: 0x0         Access: RW
	 */
	uint32_t resume_addr_l;
	/*
	 * [0x34] Resume address high
	 * Reset: 0x0         Access: RW
	 */
	uint32_t resume_addr_h;
	/* [0x38] */
	uint32_t rsrvd_2[2];
	/* [0x40] */
	uint32_t warm_rst_ctl;
	/* [0x44] */
	uint32_t rsrvd_3;
	/* [0x48] */
	uint32_t rvbar_low;
	/* [0x4c] */
	uint32_t rvbar_high;
	/* [0x50] */
	uint32_t rsrvd_4[4];
	/* [0x60] */
	uint32_t outputs_status;
	/* [0x64] */
	uint32_t rsrvd_5[11];
	/* [0x90] */
	uint32_t msg_in;
	/* [0x94] */
	uint32_t msg_out;
	/* [0x98] */
	uint32_t rsrvd_6[26];
	/*
	 * [0x100] For ECO
	 * Reset: 0x0         Access: RW
	 */
	uint32_t rsrv0;
	/*
	 * [0x104] For ECO
	 * Reset: 0xffffffff  Access: RW
	 */
	uint32_t rsrv1;
	/* [0x108] */
	uint32_t rsrvd_7[16318];
};

struct al_anpa_regs {
	/* [0x0] */
	struct al_anpa_global global;
	/* [0x400] */
	uint32_t rsrvd_0[64];
	/* [0x500] */
	struct al_anpa_rams_control rams_control[5];
	/* [0x550] */
	uint32_t rsrvd_1[172];
	/* [0x800] */
	struct al_anpa_cluster_debug cluster_debug;
	/* [0xa00] */
	uint32_t rsrvd_2[384];
	/* [0x1000] */
	struct al_anpa_coresight coresight;
	/* [0x1200] */
	uint32_t rsrvd_3[2944];
	/* [0x4000] */
	uint32_t pmu[4096];
	/* [0x8000] */
	uint32_t rsrvd_4[8192];
	/* [0x10000] */
	struct al_anpa_per_core per_core[4];
	/* [0x50000] */
	uint32_t rsrvd_5[49152];
};


/*
 * Registers Fields
 */

/**** ver register ****/
/*
 * Revision number (Minor)
 * Reset: 0x0         Access: RO
 */
#define ANPA_GLOBAL_VER_DEVICE_REV_ID_MASK 0x0000FFFF
#define ANPA_GLOBAL_VER_DEVICE_REV_ID_SHIFT 0
/*
 * Revision number (Major)
 * Reset: 0x2         Access: RO
 */
#define ANPA_GLOBAL_VER_DEVICE_ID_MASK   0xFFFF0000
#define ANPA_GLOBAL_VER_DEVICE_ID_SHIFT  16

/**** cluster_config register ****/
/*
 * Disable broadcast of barrier onto system bus.
 * Connect to Processor Cluster SYSBARDISABLE.
 * Reset: 0x1         Access: RW
 */
#define ANPA_GLOBAL_CLUSTER_CONFIG_SYSBARDISABLE (1 << 0)
/*
 * Enable broadcast of inner shareable transactions from CPUs.
 * Connect to Processor Cluster BROADCASTINNER.
 * Reset: 0x1         Access: RW
 */
#define ANPA_GLOBAL_CLUSTER_CONFIG_BROADCASTINNER (1 << 1)
/*
 * Disable broadcast of cache maintenance system bus.
 * Connect to Processor Cluster BROADCASTCACHEMAIN
 * Reset: 0x1         Access: RW
 */
#define ANPA_GLOBAL_CLUSTER_CONFIG_BROADCASTCACHEMAINT (1 << 2)
/*
 * Enable broadcast of outer shareable transactions from CPUs.
 * Connect to Processor Cluster  BROADCASTOUTER.
 * Reset: 0x1         Access: RW
 */
#define ANPA_GLOBAL_CLUSTER_CONFIG_BROADCASTOUTER (1 << 3)
/*
 * Disables the GIC CPU interface logic and routes the legacy nIRQ, nFIQ, nVIRQ, and nVFIQ
 * signals directly to the processor:
 * 0 Enable the GIC CPU interface logic.
 * 1 Disable the GIC CPU interface logic.
 * The processor only samples this signal as it exits reset.
 * Reset: 0x0         Access: RW
 */
#define ANPA_GLOBAL_CLUSTER_CONFIG_GIC_DISABLE (1 << 6)
/*
 * Disable L1 data cache and L2 snoop tag RAMs automatic invalidate on reset functionality
 * Reset: 0x0         Access: RW
 */
#define ANPA_GLOBAL_CLUSTER_CONFIG_DBG_L1_RESET_DISABLE (1 << 7)

/**** clusterid register ****/
/*
 * Value read in the Cluster ID Affinity Level-1 field, bits[15:8], of the Multiprocessor Affinity
 * Register (MPIDR).
 * This signal is only sampled during reset of the processor.
 * Reset: 0x0         Access: RW
 */
#define ANPA_GLOBAL_CLUSTERID_AFF1_MASK  0x00FF0000
#define ANPA_GLOBAL_CLUSTERID_AFF1_SHIFT 16
/*
 * Value read in the Cluster ID Affinity Level-2 field, bits[23:16], of the Multiprocessor Affinity
 * Register (MPIDR).
 * This signal is only sampled during reset of the processor..
 * Reset: 0x0         Access: RW
 */
#define ANPA_GLOBAL_CLUSTERID_AFF2_MASK  0xFF000000
#define ANPA_GLOBAL_CLUSTERID_AFF2_SHIFT 24

/**** cpus_init_control register ****/
/*
 * CPU Init Done
 * Specifies which CPUs' inits are done and can exit poreset.
 * By default, CPU0 only exits poreset when the CPUs cluster exits power-on-reset and then kicks
 * other CPUs.
 * If this bit is cleared for a specific CPU, setting it by primary CPU as part of the
 * initialization process will initiate power-on-reset to this specific CPU.
 * Reset: 0x1         Access: RW
 */
#define ANPA_GLOBAL_CPUS_INIT_CONTROL_CPUS_INITDONE_MASK 0x0000000F
#define ANPA_GLOBAL_CPUS_INIT_CONTROL_CPUS_INITDONE_SHIFT 0
/*
 * DBGPWRDNREQ Mask
 * When CPU does not exist, its DBGPWRDNREQ must be asserted.
 * If corresponding mask bit is set, the DBGPWDNREQ is deasserted.
 * Reset: 0x0         Access: RW
 */
#define ANPA_GLOBAL_CPUS_INIT_CONTROL_DBGPWRDNREQ_MASK_MASK 0x000000F0
#define ANPA_GLOBAL_CPUS_INIT_CONTROL_DBGPWRDNREQ_MASK_SHIFT 4
/*
 * Force CPU init power-on-reset exit.
 * For debug purposes only.
 * Reset: 0x0         Access: RW
 */
#define ANPA_GLOBAL_CPUS_INIT_CONTROL_FORCE_CPUPOR_MASK 0x00000F00
#define ANPA_GLOBAL_CPUS_INIT_CONTROL_FORCE_CPUPOR_SHIFT 8
/*
 * Force dbgpwrdup signal high
 * If dbgpwrdup is clear on the processor interface it indicates that the process debug resources
 * are not available for APB access.
 * Reset: 0x0         Access: RW
 */
#define ANPA_GLOBAL_CPUS_INIT_CONTROL_FORCE_DBGPWRDUP_MASK 0x0000F000
#define ANPA_GLOBAL_CPUS_INIT_CONTROL_FORCE_DBGPWRDUP_SHIFT 12

/**** cpus_init_status register ****/
/*
 * Specifies which CPUs are enabled in the device configuration.
 * sample at rst_cpus_exist[3:0] reset strap.
 * Reset: 0xf         Access: RO
 */
#define ANPA_GLOBAL_CPUS_INIT_STATUS_CPUS_EXIST_MASK 0x0000000F
#define ANPA_GLOBAL_CPUS_INIT_STATUS_CPUS_EXIST_SHIFT 0

/**** cpus_hold_reset register ****/
/*
 * Shared L2 memory system, interrupt controller and timer logic reset.
 * Reset is applied only when all processors are in STNDBYWFI state.
 * Reset: 0x0         Access: RW
 */
#define ANPA_GLOBAL_CPUS_HOLD_RESET_L2RESET (1 << 0)
/*
 * Shared debug domain reset
 * Reset: 0x0         Access: RW
 */
#define ANPA_GLOBAL_CPUS_HOLD_RESET_PRESETDBG (1 << 1)
/*
 * Individual CPU debug, PTM, watchpoint and breakpoint logic reset
 * Reset: 0x0         Access: RW
 */
#define ANPA_GLOBAL_CPUS_HOLD_RESET_CPU_DBGRESET_MASK 0x000000F0
#define ANPA_GLOBAL_CPUS_HOLD_RESET_CPU_DBGRESET_SHIFT 4
/*
 * Individual CPU core and VFP/NEON logic reset.
 * Reset is applied only when specific CPU is in STNDBYWFI state.
 * Reset: 0x0         Access: RW
 */
#define ANPA_GLOBAL_CPUS_HOLD_RESET_CPU_CORERESET_MASK 0x00000F00
#define ANPA_GLOBAL_CPUS_HOLD_RESET_CPU_CORERESET_SHIFT 8
/*
 * Individual CPU por-on-reset.
 * Reset is applied only when specific CPU is in STNDBYWFI state.
 * Reset: 0x0         Access: RW
 */
#define ANPA_GLOBAL_CPUS_HOLD_RESET_CPU_PORESET_MASK 0x0000F000
#define ANPA_GLOBAL_CPUS_HOLD_RESET_CPU_PORESET_SHIFT 12
/*
 * Wait for interrupt mask.
 * If set, reset is applied without waiting for the specified CPU's STNDBYWFI state.
 * Reset: 0x0         Access: RW
 */
#define ANPA_GLOBAL_CPUS_HOLD_RESET_WFI_MASK_MASK 0x000F0000
#define ANPA_GLOBAL_CPUS_HOLD_RESET_WFI_MASK_SHIFT 16

/**** cpus_software_reset register ****/
/*
 * Write 1. Apply the software reset.
 * Reset: 0x0         Access: WO
 */
#define ANPA_GLOBAL_CPUS_SOFTWARE_RESET_SWRESET_REQ (1 << 0)
/*
 * Defines the level of software reset.
 * 0x0 - cpu_core: Individual CPU core reset.
 * 0x1 - cpu_poreset: Individual CPU power-on-reset.
 * 0x2 - cpu_dbg: Individual CPU debug reset.
 * 0x3 - cluster_no_dbg: A Cluster reset puts each core into core reset (no dbg) and also resets the
 * interrupt controller and L2 logic.
 * 0x4 - cluster: A Cluster reset puts each core into power-on-reset and also resets the interrupt
 * controller and L2 logic. Debug is active.
 * 0x5 - cluster_poreset: A Cluster power-on-reset puts each core into power-on-reset and also
 * resets the interrupt controller and L2 logic. This include the cluster debug logic.
 * Reset: 0x0         Access: WO
 */
#define ANPA_GLOBAL_CPUS_SOFTWARE_RESET_LEVEL_MASK 0x0000000E
#define ANPA_GLOBAL_CPUS_SOFTWARE_RESET_LEVEL_SHIFT 1
/*
 * Defines which cores to reset when no cluster_poreset is requested.
 * Reset: 0x0         Access: WO
 */
#define ANPA_GLOBAL_CPUS_SOFTWARE_RESET_CORES_MASK 0x000000F0
#define ANPA_GLOBAL_CPUS_SOFTWARE_RESET_CORES_SHIFT 4
/*
 * CPUn wait for interrupt enable.
 * Defines which CPU WFI indication to wait for before applying the software reset.
 * Reset: 0x0         Access: WO
 */
#define ANPA_GLOBAL_CPUS_SOFTWARE_RESET_WFI_MASK_MASK 0x000F0000
#define ANPA_GLOBAL_CPUS_SOFTWARE_RESET_WFI_MASK_SHIFT 16

/**** wd_timer0_reset register ****/
/*
 * Shared L2 memory system, interrupt controller and timer logic reset
 * Reset: 0x0         Access: RW
 */
#define ANPA_GLOBAL_WD_TIMER0_RESET_L2RESET (1 << 0)
/*
 * Shared debug domain reset
 * Reset: 0x0         Access: RW
 */
#define ANPA_GLOBAL_WD_TIMER0_RESET_PRESETDBG (1 << 1)
/*
 * Individual CPU debug ETM, watchpoint and breakpoint logic reset
 * Reset: 0x0         Access: RW
 */
#define ANPA_GLOBAL_WD_TIMER0_RESET_CPU_DBGRESET_MASK 0x000000F0
#define ANPA_GLOBAL_WD_TIMER0_RESET_CPU_DBGRESET_SHIFT 4
/*
 * Individual CPU core and VFP/NEON logic reset
 * Reset: 0x0         Access: RW
 */
#define ANPA_GLOBAL_WD_TIMER0_RESET_CPU_CORERESET_MASK 0x00000F00
#define ANPA_GLOBAL_WD_TIMER0_RESET_CPU_CORERESET_SHIFT 8
/*
 * Individual CPU por-on-reset
 * Reset: 0x0         Access: RW
 */
#define ANPA_GLOBAL_WD_TIMER0_RESET_CPU_PORESET_MASK 0x0000F000
#define ANPA_GLOBAL_WD_TIMER0_RESET_CPU_PORESET_SHIFT 12

/**** wd_timer1_reset register ****/
/*
 * Shared L2 memory system, interrupt controller and timer logic reset
 * Reset: 0x0         Access: RW
 */
#define ANPA_GLOBAL_WD_TIMER1_RESET_L2RESET (1 << 0)
/*
 * Shared debug domain reset
 * Reset: 0x0         Access: RW
 */
#define ANPA_GLOBAL_WD_TIMER1_RESET_PRESETDBG (1 << 1)
/*
 * Individual CPU debug ETM, watchpoint and breakpoint logic reset
 * Reset: 0x0         Access: RW
 */
#define ANPA_GLOBAL_WD_TIMER1_RESET_CPU_DBGRESET_MASK 0x000000F0
#define ANPA_GLOBAL_WD_TIMER1_RESET_CPU_DBGRESET_SHIFT 4
/*
 * Individual CPU core and VFP/NEON logic reset
 * Reset: 0x0         Access: RW
 */
#define ANPA_GLOBAL_WD_TIMER1_RESET_CPU_CORERESET_MASK 0x00000F00
#define ANPA_GLOBAL_WD_TIMER1_RESET_CPU_CORERESET_SHIFT 8
/*
 * Individual CPU por-on-reset
 * Reset: 0x0         Access: RW
 */
#define ANPA_GLOBAL_WD_TIMER1_RESET_CPU_PORESET_MASK 0x0000F000
#define ANPA_GLOBAL_WD_TIMER1_RESET_CPU_PORESET_SHIFT 12

/**** wd_timer2_reset register ****/
/*
 * Shared L2 memory system, interrupt controller and timer logic reset
 * Reset: 0x0         Access: RW
 */
#define ANPA_GLOBAL_WD_TIMER2_RESET_L2RESET (1 << 0)
/*
 * Shared debug domain reset
 * Reset: 0x0         Access: RW
 */
#define ANPA_GLOBAL_WD_TIMER2_RESET_PRESETDBG (1 << 1)
/*
 * Individual CPU debug, ETM, watchpoint and breakpoint logic reset
 * Reset: 0x0         Access: RW
 */
#define ANPA_GLOBAL_WD_TIMER2_RESET_CPU_DBGRESET_MASK 0x000000F0
#define ANPA_GLOBAL_WD_TIMER2_RESET_CPU_DBGRESET_SHIFT 4
/*
 * Individual CPU core and VFP/NEON logic reset
 * Reset: 0x0         Access: RW
 */
#define ANPA_GLOBAL_WD_TIMER2_RESET_CPU_CORERESET_MASK 0x00000F00
#define ANPA_GLOBAL_WD_TIMER2_RESET_CPU_CORERESET_SHIFT 8
/*
 * Individual CPU por-on-reset
 * Reset: 0x0         Access: RW
 */
#define ANPA_GLOBAL_WD_TIMER2_RESET_CPU_PORESET_MASK 0x0000F000
#define ANPA_GLOBAL_WD_TIMER2_RESET_CPU_PORESET_SHIFT 12

/**** wd_timer3_reset register ****/
/*
 * Shared L2 memory system, interrupt controller and timer logic reset
 * Reset: 0x0         Access: RW
 */
#define ANPA_GLOBAL_WD_TIMER3_RESET_L2RESET (1 << 0)
/*
 * Shared debug domain reset
 * Reset: 0x0         Access: RW
 */
#define ANPA_GLOBAL_WD_TIMER3_RESET_PRESETDBG (1 << 1)
/*
 * Individual CPU debug, ETM, watchpoint and breakpoint logic reset
 * Reset: 0x0         Access: RW
 */
#define ANPA_GLOBAL_WD_TIMER3_RESET_CPU_DBGRESET_MASK 0x000000F0
#define ANPA_GLOBAL_WD_TIMER3_RESET_CPU_DBGRESET_SHIFT 4
/*
 * Individual CPU core and VFP/NEON logic reset
 * Reset: 0x0         Access: RW
 */
#define ANPA_GLOBAL_WD_TIMER3_RESET_CPU_CORERESET_MASK 0x00000F00
#define ANPA_GLOBAL_WD_TIMER3_RESET_CPU_CORERESET_SHIFT 8
/*
 * Individual CPU por-on-reset
 * Reset: 0x0         Access: RW
 */
#define ANPA_GLOBAL_WD_TIMER3_RESET_CPU_PORESET_MASK 0x0000F000
#define ANPA_GLOBAL_WD_TIMER3_RESET_CPU_PORESET_SHIFT 12

/**** wd_timer4_reset register ****/
/*
 * Shared L2 memory system, interrupt controller and timer logic reset
 * Reset: 0x0         Access: RW
 */
#define ANPA_GLOBAL_WD_TIMER4_RESET_L2RESET (1 << 0)
/*
 * Shared debug domain reset
 * Reset: 0x0         Access: RW
 */
#define ANPA_GLOBAL_WD_TIMER4_RESET_PRESETDBG (1 << 1)
/*
 * Individual CPU debug ETM, watchpoint and breakpoint logic reset
 * Reset: 0x0         Access: RW
 */
#define ANPA_GLOBAL_WD_TIMER4_RESET_CPU_DBGRESET_MASK 0x000000F0
#define ANPA_GLOBAL_WD_TIMER4_RESET_CPU_DBGRESET_SHIFT 4
/*
 * Individual CPU core and VFP/NEON logic reset
 * Reset: 0x0         Access: RW
 */
#define ANPA_GLOBAL_WD_TIMER4_RESET_CPU_CORERESET_MASK 0x00000F00
#define ANPA_GLOBAL_WD_TIMER4_RESET_CPU_CORERESET_SHIFT 8
/*
 * Individual CPU por-on-reset
 * Reset: 0x0         Access: RW
 */
#define ANPA_GLOBAL_WD_TIMER4_RESET_CPU_PORESET_MASK 0x0000F000
#define ANPA_GLOBAL_WD_TIMER4_RESET_CPU_PORESET_SHIFT 12

/**** wd_timer5_reset register ****/
/*
 * Shared L2 memory system, interrupt controller and timer logic reset
 * Reset: 0x0         Access: RW
 */
#define ANPA_GLOBAL_WD_TIMER5_RESET_L2RESET (1 << 0)
/*
 * Shared debug domain reset
 * Reset: 0x0         Access: RW
 */
#define ANPA_GLOBAL_WD_TIMER5_RESET_PRESETDBG (1 << 1)
/*
 * Individual CPU debug ETM, watchpoint and breakpoint logic reset
 * Reset: 0x0         Access: RW
 */
#define ANPA_GLOBAL_WD_TIMER5_RESET_CPU_DBGRESET_MASK 0x000000F0
#define ANPA_GLOBAL_WD_TIMER5_RESET_CPU_DBGRESET_SHIFT 4
/*
 * Individual CPU core and VFP/NEON logic reset
 * Reset: 0x0         Access: RW
 */
#define ANPA_GLOBAL_WD_TIMER5_RESET_CPU_CORERESET_MASK 0x00000F00
#define ANPA_GLOBAL_WD_TIMER5_RESET_CPU_CORERESET_SHIFT 8
/*
 * Individual CPU por-on-reset
 * Reset: 0x0         Access: RW
 */
#define ANPA_GLOBAL_WD_TIMER5_RESET_CPU_PORESET_MASK 0x0000F000
#define ANPA_GLOBAL_WD_TIMER5_RESET_CPU_PORESET_SHIFT 12

/**** wd_timer6_reset register ****/
/*
 * Shared L2 memory system, interrupt controller and timer logic reset
 * Reset: 0x0         Access: RW
 */
#define ANPA_GLOBAL_WD_TIMER6_RESET_L2RESET (1 << 0)
/*
 * Shared debug domain reset
 * Reset: 0x0         Access: RW
 */
#define ANPA_GLOBAL_WD_TIMER6_RESET_PRESETDBG (1 << 1)
/*
 * Individual CPU debug, ETM, watchpoint and breakpoint logic reset
 * Reset: 0x0         Access: RW
 */
#define ANPA_GLOBAL_WD_TIMER6_RESET_CPU_DBGRESET_MASK 0x000000F0
#define ANPA_GLOBAL_WD_TIMER6_RESET_CPU_DBGRESET_SHIFT 4
/*
 * Individual CPU core and VFP/NEON logic reset
 * Reset: 0x0         Access: RW
 */
#define ANPA_GLOBAL_WD_TIMER6_RESET_CPU_CORERESET_MASK 0x00000F00
#define ANPA_GLOBAL_WD_TIMER6_RESET_CPU_CORERESET_SHIFT 8
/*
 * Individual CPU por-on-reset
 * Reset: 0x0         Access: RW
 */
#define ANPA_GLOBAL_WD_TIMER6_RESET_CPU_PORESET_MASK 0x0000F000
#define ANPA_GLOBAL_WD_TIMER6_RESET_CPU_PORESET_SHIFT 12

/**** wd_timer7_reset register ****/
/*
 * Shared L2 memory system, interrupt controller and timer logic reset
 * Reset: 0x0         Access: RW
 */
#define ANPA_GLOBAL_WD_TIMER7_RESET_L2RESET (1 << 0)
/*
 * Shared debug domain reset
 * Reset: 0x0         Access: RW
 */
#define ANPA_GLOBAL_WD_TIMER7_RESET_PRESETDBG (1 << 1)
/*
 * Individual CPU debug, ETM, watchpoint and breakpoint logic reset
 * Reset: 0x0         Access: RW
 */
#define ANPA_GLOBAL_WD_TIMER7_RESET_CPU_DBGRESET_MASK 0x000000F0
#define ANPA_GLOBAL_WD_TIMER7_RESET_CPU_DBGRESET_SHIFT 4
/*
 * Individual CPU core and VFP/NEON logic reset
 * Reset: 0x0         Access: RW
 */
#define ANPA_GLOBAL_WD_TIMER7_RESET_CPU_CORERESET_MASK 0x00000F00
#define ANPA_GLOBAL_WD_TIMER7_RESET_CPU_CORERESET_SHIFT 8
/*
 * Individual CPU por-on-reset
 * Reset: 0x0         Access: RW
 */
#define ANPA_GLOBAL_WD_TIMER7_RESET_CPU_PORESET_MASK 0x0000F000
#define ANPA_GLOBAL_WD_TIMER7_RESET_CPU_PORESET_SHIFT 12

/**** cpus_power_ctrl register ****/
/*
 * L2 WFI enable
 * When all the processors are in WFI mode or powered-down, the shared L2 memory system Power
 * Management controller resumes clock on any interrupt.
 * Power management controller resumes clock on snoop request.
 * NOT IMPLEMENTED
 * Reset: 0x0         Access: RW
 */
#define ANPA_GLOBAL_CPUS_POWER_CTRL_L2WFI_EN (1 << 0)
/*
 * L2 WFI status
 * Reset: 0x0         Access: RO
 */
#define ANPA_GLOBAL_CPUS_POWER_CTRL_L2WFI_STATUS (1 << 1)
/*
 * L2 RAMs Power Down
 * Power down the L2 RAMs. L2 caches must be flushed prior to entering this state.
 * Reset: 0x0         Access: RW
 */
#define ANPA_GLOBAL_CPUS_POWER_CTRL_L2RAMS_PWRDN_EN (1 << 2)
/*
 * L2 RAMs power down status
 * Reset: 0x0         Access: RO
 */
#define ANPA_GLOBAL_CPUS_POWER_CTRL_L2RAMS_PWRDN_STATUS (1 << 3)
/*
 * CPU state condition to enable L2 RAM power down
 * 0 - Power down
 * 1 - WFI
 * NOT IMPLEMENTED
 * Reset: 0x0         Access: RW
 */
#define ANPA_GLOBAL_CPUS_POWER_CTRL_L2RAMS_PWRDN_CPUS_STATE_MASK 0x000000F0
#define ANPA_GLOBAL_CPUS_POWER_CTRL_L2RAMS_PWRDN_CPUS_STATE_SHIFT 4
/*
 * Enable external debugger over power-down.
 * Provides support for external debug over power down. If any or all of the processors are powered
 * down, the SoC can still use the debug facilities if the debug PCLKDBG domain is powered up.
 * Reset: 0x1         Access: RW
 */
#define ANPA_GLOBAL_CPUS_POWER_CTRL_EXT_DEBUGGER_OVER_PD_EN (1 << 8)
/*
 * L2 hardware flush request. This signal indicates:
 * 0 L2 hardware flush request is not asserted. flush is performed by SW
 * 1 L2 hardware flush request is asserted by power management block as part of cluster rams power
 * down flow. HW starts L2 flush flow when all CPUs are in WFI
 * Reset: 0x0         Access: RW
 */
#define ANPA_GLOBAL_CPUS_POWER_CTRL_L2FLUSH_EN (1 << 9)
/*
 * Non-CPU Power Down
 * Power down the non-CPU. L2 caches must be flushed prior to entering this state.
 * Reset: 0x0         Access: RW
 */
#define ANPA_GLOBAL_CPUS_POWER_CTRL_NONCPU_PWRDN_EN (1 << 10)
/*
 * Non-CPU power down status
 * Reset: 0x0         Access: RO
 */
#define ANPA_GLOBAL_CPUS_POWER_CTRL_NONCPU_PWRDN_STATUS (1 << 11)
/*
 * Non-CPU power down SM status
 * Reset: 0x0         Access: RO
 */
#define ANPA_GLOBAL_CPUS_POWER_CTRL_NONCPU_PWRDN_SM_STATUS_MASK 0x0000F000
#define ANPA_GLOBAL_CPUS_POWER_CTRL_NONCPU_PWRDN_SM_STATUS_SHIFT 12
/*
 * Disable handshake with external power controller (to manage multi cluster power sequences)
 * Reset: 0x0         Access: RW
 */
#define ANPA_GLOBAL_CPUS_POWER_CTRL_NONCPU_EXT_DIS (1 << 26)
/*
 * Force wakeup the CPU in L2RAM power down
 * INTERNAL DEBUG PURPOSE ONLY
 * Reset: 0x0         Access: RW
 */
#define ANPA_GLOBAL_CPUS_POWER_CTRL_FORCE_CPUS_OK_PWRUP (1 << 27)
/*
 * L2 RAMs power down SM status
 * Reset: 0x0         Access: RO
 */
#define ANPA_GLOBAL_CPUS_POWER_CTRL_L2RAMS_PWRDN_SM_STATUS_MASK 0xF0000000
#define ANPA_GLOBAL_CPUS_POWER_CTRL_L2RAMS_PWRDN_SM_STATUS_SHIFT 28

/**** ram_pu_pause register ****/
/*
 * Pause for CPUs from the time all power is up to the time the SRAMs start opening.
 * Reset: 0xa         Access: RW
 */
#define ANPA_GLOBAL_RAM_PU_PAUSE_PWR_UP_PAUSE_MASK 0x0000001F
#define ANPA_GLOBAL_RAM_PU_PAUSE_PWR_UP_PAUSE_SHIFT 0

/**** axi_parity register ****/
/*
 * Replace RRESP response to CPU once received parity or RDATA is incorrect
 * Reset: 0x0         Access: RW
 */
#define ANPA_GLOBAL_AXI_PARITY_REPLACE_RRESP_ON_ERR (1 << 0)
/*
 * RRESP to send to CPU once encountering parity error on RDATA
 * Reset: 0x2         Access: RW
 */
#define ANPA_GLOBAL_AXI_PARITY_ERR_RESP_MASK 0x00000006
#define ANPA_GLOBAL_AXI_PARITY_ERR_RESP_SHIFT 1
/*
 * Set to clear parity error interrupt. SW must return this value to 0 to allow further interrupts.
 * Reset: 0x0         Access: RW
 */
#define ANPA_GLOBAL_AXI_PARITY_INTR_CLR  (1 << 3)

/**** rf_misc register ****/
/* Reset: 0x44        Access: RW */
#define ANPA_RAMS_CONTROL_RF_MISC_RM_MASK 0x0000007F
#define ANPA_RAMS_CONTROL_RF_MISC_RM_SHIFT 0

/**** outputs register ****/
/* Reset: 0x0         Access: RO */
#define ANPA_CLUSTER_DEBUG_OUTPUTS_STANDBYWFIL2 (1 << 0)
/* Reset: 0x0         Access: RO */
#define ANPA_CLUSTER_DEBUG_OUTPUTS_L2RAM_PWR_DN_ACK (1 << 1)

/**** latch_pc_req register ****/
/*
 * If set, request to latch execution  PC from processor cluster
 * Reset: 0x0         Access: RW
 */
#define ANPA_CLUSTER_DEBUG_LATCH_PC_REQ_EN (1 << 0)
/*
 * target CPU id to latch its execution PC
 * Reset: 0x0         Access: RW
 */
#define ANPA_CLUSTER_DEBUG_LATCH_PC_REQ_CPU_ID_MASK 0x000000F0
#define ANPA_CLUSTER_DEBUG_LATCH_PC_REQ_CPU_ID_SHIFT 4

/**** latch_pc_low register ****/
/*
 * Set by hardware when the processor cluster ack the PC latch request.
 * Clear on read latch_pc_high
 * Reset: 0x0         Access: RW
 */
#define ANPA_CLUSTER_DEBUG_LATCH_PC_LOW_VALID (1 << 0)
/*
 * Latched PC value [31:1]
 * Reset: 0x0         Access: RW
 */
#define ANPA_CLUSTER_DEBUG_LATCH_PC_LOW_VAL_MASK 0xFFFFFFFE
#define ANPA_CLUSTER_DEBUG_LATCH_PC_LOW_VAL_SHIFT 1

/**** track_dump_ctrl register ****/
/*
 * [24:16]: Queue entry pointer
 * [3:2] Target queue - 0:ASI, 1: AMI
 * [1:0]: Target Processor Cluster - 0: Cluster0, 1: Cluster1
 * Reset: 0x0         Access: RW
 */
#define ANPA_CLUSTER_DEBUG_TRACK_DUMP_CTRL_PTR_MASK 0x7FFFFFFF
#define ANPA_CLUSTER_DEBUG_TRACK_DUMP_CTRL_PTR_SHIFT 0
/*
 * Track Dump Request
 * If set, queue entry info is latched on track_dump_rdata register.
 * Program the pointer and target queue.
 * This is a  full handshake register
 * Read <valid> bit from track_dump_rdata register. If set, clear the request field before
 * triggering a new request.
 * Reset: 0x0         Access: RW
 */
#define ANPA_CLUSTER_DEBUG_TRACK_DUMP_CTRL_REQ (1 << 31)

/**** track_dump_rdata_0 register ****/
/*
 * Valid
 * Reset: 0x0         Access: RO
 */
#define ANPA_CLUSTER_DEBUG_TRACK_DUMP_RDATA_0_VALID (1 << 0)
/*
 * Low data
 * Reset: 0x0         Access: RO
 */
#define ANPA_CLUSTER_DEBUG_TRACK_DUMP_RDATA_0_DATA_MASK 0xFFFFFFFE
#define ANPA_CLUSTER_DEBUG_TRACK_DUMP_RDATA_0_DATA_SHIFT 1

/**** pmu register ****/
/*
 * If set, track snoop channel instead of read/write
 * Reset: 0x0         Access: RW
 */
#define ANPA_CLUSTER_DEBUG_PMU_TRACK_SNOOP (1 << 0)
/*
 * If set, will release the pc capture once PMU trigger is cleared
 * Reset: 0x0         Access: RW
 */
#define ANPA_CLUSTER_DEBUG_PMU_RELEASE_PC_CAPTURE (1 << 1)
/*
 * AXI tracking will start after this bit is set, and the number of outstanding is zero. Must be set
 * only after finishing configuration of AXI monitor in PMU and enabling tracking there.
 * Reset: 0x0         Access: RW
 */
#define ANPA_CLUSTER_DEBUG_PMU_AXI_TRACK_EN (1 << 2)
/*
 * If set, will sample the PC into the ELA once PMU trig is asserted
 * Reset: 0x0         Access: RW
 */
#define ANPA_CLUSTER_DEBUG_PMU_PC_CAPTURE_EN (1 << 3)
/*
 * If set, will stop fast DRO once getting external pause indication
 * Reset: 0x0         Access: RW
 */
#define ANPA_CLUSTER_DEBUG_PMU_FAST_DRO_FREEZE (1 << 4)
/*
 * If set, AXI monitor will also track DVM messages
 * Reset: 0x0         Access: RW
 */
#define ANPA_CLUSTER_DEBUG_PMU_AXI_TRACK_DVM_EN (1 << 5)

/**** pmu_sec register ****/
/*
 * If set, allow only secure transactions to access the PMU
 * Reset: 0x0         Access: RW
 */
#define ANPA_CLUSTER_DEBUG_PMU_SEC_TRACK_SECURED_ONLY (1 << 0)

/**** pmu_pd register ****/
/*
 * If set, powers down the PMU SRAM
 * Reset: 0x0         Access: RW
 */
#define ANPA_CLUSTER_DEBUG_PMU_PD_RAM_MASK 0x00000003
#define ANPA_CLUSTER_DEBUG_PMU_PD_RAM_SHIFT 0

/**** pd register ****/
/*
 * Forces RAM powerdown for ETF RAM's (bit per ram)
 * Reset: 0x0         Access: RW
 */
#define ANPA_CORESIGHT_PD_ETF_RAM_MASK   0x00000003
#define ANPA_CORESIGHT_PD_ETF_RAM_SHIFT  0

/**** ctm register ****/
/*
 * CPU CTM and CoreSight CTM operate according to the same clock.
 * Bypass modes can be enabled
 * Reset: 0x1         Access: RW
 */
#define ANPA_CORESIGHT_CTM_CISBYPASS_0   (1 << 0)
/*
 * CPU CTM and CoreSight CTM operate according to the same clock.
 * Bypass modes can be enabled
 * Reset: 0xf         Access: RW
 */
#define ANPA_CORESIGHT_CTM_CIHSBYPASS_0_MASK 0x000000F0
#define ANPA_CORESIGHT_CTM_CIHSBYPASS_0_SHIFT 4
/*
 * CoreSight CTI and CoreSight CTM operate according to the same clock.
 * Bypass modes can be enabled
 * Reset: 0x1         Access: RW
 */
#define ANPA_CORESIGHT_CTM_CISBYPASS_1   (1 << 8)
/*
 * CoreSight CTI and CoreSight CTM operate according to the same clock.
 * Bypass modes can be enabled
 * Reset: 0xf         Access: RW
 */
#define ANPA_CORESIGHT_CTM_CIHSBYPASS_1_MASK 0x0000F000
#define ANPA_CORESIGHT_CTM_CIHSBYPASS_1_SHIFT 12
/*
 * Not Used
 * Reset: 0x1         Access: RW
 */
#define ANPA_CORESIGHT_CTM_CISBYPASS_3   (1 << 24)
/*
 * Not Used
 * Reset: 0xf         Access: RW
 */
#define ANPA_CORESIGHT_CTM_CIHSBYPASS_3_MASK 0xF0000000
#define ANPA_CORESIGHT_CTM_CIHSBYPASS_3_SHIFT 28

/**** cti_0 register ****/
/*
 * Trigger interface handshake bypass
 * Reset: 0xff        Access: RW
 */
#define ANPA_CORESIGHT_CTI_0_TIHSBYPASS_MASK 0x000000FF
#define ANPA_CORESIGHT_CTI_0_TIHSBYPASS_SHIFT 0
/*
 * Synchronization bypass between APB and CTI clock
 * Reset: 0x1         Access: RW
 */
#define ANPA_CORESIGHT_CTI_0_APBSBYPASS  (1 << 8)
/*
 * Trigger out acknowledge sync bypass
 * Reset: 0xff        Access: RW
 */
#define ANPA_CORESIGHT_CTI_0_TISBYPASSACK_MASK 0x00FF0000
#define ANPA_CORESIGHT_CTI_0_TISBYPASSACK_SHIFT 16
/*
 * Trigger in sync bypass
 * Reset: 0xff        Access: RW
 */
#define ANPA_CORESIGHT_CTI_0_TISBYPASSIN_MASK 0xFF000000
#define ANPA_CORESIGHT_CTI_0_TISBYPASSIN_SHIFT 24

/**** cti_1 register ****/
/*
 * Masks when dbgen is LOW
 * Reset: 0x0         Access: RW
 */
#define ANPA_CORESIGHT_CTI_1_TODBGENSEL_MASK 0x000000FF
#define ANPA_CORESIGHT_CTI_1_TODBGENSEL_SHIFT 0
/*
 * Masks when NIDEN is LOW
 * Reset: 0x0         Access: RW
 */
#define ANPA_CORESIGHT_CTI_1_TINIDENSEL_MASK 0x0000FF00
#define ANPA_CORESIGHT_CTI_1_TINIDENSEL_SHIFT 8

/**** config register ****/
/*
 * Individual processor control of the endianness configuration at reset. It sets the initial value
 * of the EE bit in the CP15 System Control Register (SCTLR) related to CFGEND<n> input:
 * little - 0x0: Little endian
 * bit - 0x1: Bit endian
 * Reset: 0x0         Access: RW
 */
#define ANPA_PER_CORE_CONFIG_ENDIAN      (1 << 0)
/*
 * Individual processor control of the default exception handling state. It sets the initial value
 * of the TE bit in the CP15 System Control Register (SCTLR) related to CFGTE<n> input:
 * arm: 0x0: Exception operates ARM code.
 * Thumb: 0x1: Exception operates Thumb code.
 * Reset: 0x0         Access: RW
 */
#define ANPA_PER_CORE_CONFIG_TE          (1 << 1)
/*
 * Individual processor control of the location of the exception vectors at reset. It sets the
 * initial value of the V bit in the CP15 System Control Register (SCTLR).
 * Connected to VINITHIGH<n> input.
 * low - 0x0: Exception vectors start at address 0x00000000.
 * high - 0x1: Exception vectors start at address 0xFFFF0000.
 * Reset: 0x1         Access: RW
 */
#define ANPA_PER_CORE_CONFIG_VINITHI     (1 << 2)
/*
 * Individual processor control to disable write access to some secure CP15 registers
 * connected to CP15SDISABLE<n> input.
 * Reset: 0x0         Access: RW, WInit
 */
#define ANPA_PER_CORE_CONFIG_CP15DISABLE (1 << 3)
/*
 * Force Write init implementation to ConfigAARch64 register
 * Reset: 0x0         Access: RW, WInit
 */
#define ANPA_PER_CORE_CONFIG_AARCH64_REG_FORCE_WINIT (1 << 4)
/*
 * Force Write Once implementation to ConfigAARch64 register.
 * Reset: 0x1         Access: RW, WInit
 */
#define ANPA_PER_CORE_CONFIG_AARCH64_REG_FORCE_WONCE (1 << 5)
/*
 * Use nSEI indication
 * Reset: 0x0         Access: RW
 */
#define ANPA_PER_CORE_CONFIG_USE_NSEI    (1 << 6)
/*
 * Use nREI indication
 * Reset: 0x0         Access: RW
 */
#define ANPA_PER_CORE_CONFIG_USE_NREI    (1 << 7)
/*
 * Use nVSEI indication
 * Reset: 0x0         Access: RW
 */
#define ANPA_PER_CORE_CONFIG_USE_NVSEI   (1 << 8)

/**** aarch64 register ****/
/*
 * Individual processor register width state. The register width states are:
 * 0 AArch32.
 * 1 AArch64.
 * This signal is only sampled during reset of the processor.
 * This is Write Init or Write Once based on config register (aarch64_reg_force_wonce,
 * aarch64_reg_force_winit)
 * Reset: 0x0         Access: RW
 */
#define ANPA_PER_CORE_AARCH64_AA64_NAA32 (1 << 0)
/*
 * Individual processor Cryptography engine disable:
 * 0 Enable the Cryptography engine.
 * 1 Disable the Cryptography engine.
 * This signal is only sampled during reset of the processor
 * Reset: 0x0         Access: RW
 */
#define ANPA_PER_CORE_AARCH64_CRYPTO_DIS (1 << 1)

/**** debug_sec register ****/
/*
 * DBGEN
 * Reset: 0x1         Access: RW
 */
#define ANPA_PER_CORE_DEBUG_SEC_DBGEN    (1 << 0)
/*
 * NIDEN
 * Reset: 0x1         Access: RW
 */
#define ANPA_PER_CORE_DEBUG_SEC_NIDEN    (1 << 1)
/*
 * SPIDEN
 * Reset: 0x0         Access: RW
 */
#define ANPA_PER_CORE_DEBUG_SEC_SPIDEN   (1 << 2)
/*
 * SPNIDEN
 * Reset: 0x0         Access: RW
 */
#define ANPA_PER_CORE_DEBUG_SEC_SPNIDEN  (1 << 3)

/**** power_ctrl register ****/
/*
 * Individual CPU power mode transition request
 * If requested to enter power mode other than normal mode, low power state is resumed whenever CPU
 * reenters STNDBYWFI state:
 * normal: 0x0: normal power state
 * deep_idle: 0x2: Dormant power mode state
 * poweredoff: 0x3: Powered-off power mode
 * Reset: 0x0         Access: RW
 */
#define ANPA_PER_CORE_POWER_CTRL_PM_REQ_MASK 0x00000003
#define ANPA_PER_CORE_POWER_CTRL_PM_REQ_SHIFT 0
/*
 * Power down regret disable
 * When power down regret is enabled, the powerdown enter flow can be halted whenever a valid wakeup
 * event occurs.
 * Reset: 0x0         Access: RW
 */
#define ANPA_PER_CORE_POWER_CTRL_PWRDN_RGRT_DIS (1 << 16)
/*
 * Power down emulation enable
 * If set, the entire power down sequence is applied, but the CPU is placed in soft reset instead of
 * hardware power down.
 * Reset: 0x0         Access: RW
 */
#define ANPA_PER_CORE_POWER_CTRL_PWRDN_EMULATE (1 << 17)
/*
 * Disable wakeup from Local--GIC FIQ.
 * Reset: 0x0         Access: RW
 */
#define ANPA_PER_CORE_POWER_CTRL_WU_LGIC_FIQ_DIS (1 << 18)
/*
 * Disable wakeup from Local-GIC IRQ.
 * Reset: 0x0         Access: RW
 */
#define ANPA_PER_CORE_POWER_CTRL_WU_LGIC_IRQ_DIS (1 << 19)
/*
 * Disable scheduling of interrupts in GIC(500) to non-active CPU
 * Reset: 0x0         Access: RW
 */
#define ANPA_PER_CORE_POWER_CTRL_GIC_DIS_CPU (1 << 22)
/*
 * Disable handshake with external power controller (to manage multi cluster power sequences)
 * Reset: 0x0         Access: RW
 */
#define ANPA_PER_CORE_POWER_CTRL_EXT_DIS (1 << 23)

/**** power_status register ****/
/*
 * Read-only bits that reflect the individual CPU power mode status.
 * Default value for non-exist CPU is 2b11:
 * normal - 0x0: Normal mode
 * por - 0x1: por on reset mode
 * deep_idle - 0x2: Dormant power mode state
 * poweredoff - 0x3: Powered-off power mode
 * Reset: 0x0         Access: RO
 */
#define ANPA_PER_CORE_POWER_STATUS_CPU_PM_MASK 0x00000003
#define ANPA_PER_CORE_POWER_STATUS_CPU_PM_SHIFT 0
/*
 * WFI status
 * Reset: 0x0         Access: RO
 */
#define ANPA_PER_CORE_POWER_STATUS_WFI   (1 << 2)
/*
 * WFE status
 * Reset: 0x0         Access: RO
 */
#define ANPA_PER_CORE_POWER_STATUS_WFE   (1 << 3)

/**** warm_rst_ctl register ****/
/*
 * Disable CPU Warm Reset when warmrstreq is asserted
 *
 * When the Reset Request bit in the RMR or RMR_EL3 register is set to 1 in the CPU Core , the
 * processor asserts the WARMRSTREQ signal and the SoC reset controller use this request to trigger
 * a Warm reset of the processor and change the register width state.
 * Reset: 0x0         Access: RW
 */
#define ANPA_PER_CORE_WARM_RST_CTL_REQ_DIS (1 << 0)
/*
 * Disable waiting WFI on Warm Reset
 * Reset: 0x0         Access: RW
 */
#define ANPA_PER_CORE_WARM_RST_CTL_WFI_DIS (1 << 1)

/**** rvbar_low register ****/
/*
 * CPU Core AARach64 reset vector bar
 * This is Write Once register (controlled by aarch64_reg_force_* fields)
 * Reset: 0x0         Access: RW
 */
#define ANPA_PER_CORE_RVBAR_LOW_ADDR_31_2_MASK 0xFFFFFFFC
#define ANPA_PER_CORE_RVBAR_LOW_ADDR_31_2_SHIFT 2

/**** rvbar_high register ****/
/*
 * CPU Core AARach64 reset vector bar high bits
 * This is Write Once register (controlled by aarch64_reg_force_* fields)
 * Reset: 0x0         Access: RW
 */
#define ANPA_PER_CORE_RVBAR_HIGH_ADDR_43_32_MASK 0x00000FFF
#define ANPA_PER_CORE_RVBAR_HIGH_ADDR_43_32_SHIFT 0

/**** outputs_status register ****/
/* Reset: 0x0         Access: RO */
#define ANPA_PER_CORE_OUTPUTS_STATUS_STANDBYWFI (1 << 0)
/* Reset: 0x0         Access: RO */
#define ANPA_PER_CORE_OUTPUTS_STATUS_CPU_PWR_DN_ACK (1 << 1)
/* Reset: 0x0         Access: RO */
#define ANPA_PER_CORE_OUTPUTS_STATUS_CNTHPIRQ_N (1 << 2)
/* Reset: 0x0         Access: RO */
#define ANPA_PER_CORE_OUTPUTS_STATUS_NCNTPNSIRQ_N (1 << 3)
/* Reset: 0x0         Access: RO */
#define ANPA_PER_CORE_OUTPUTS_STATUS_NCNTPSIRQ_N (1 << 4)
/* Reset: 0x0         Access: RO */
#define ANPA_PER_CORE_OUTPUTS_STATUS_NCNTVIRQ_N (1 << 5)
/*
 * Indicates for each CPU if coherency is enabled
 * Reset: 0x0         Access: RO
 */
#define ANPA_PER_CORE_OUTPUTS_STATUS_SMPEN (1 << 6)
/* Reset: 0x0         Access: RO */
#define ANPA_PER_CORE_OUTPUTS_STATUS_VIRQ_N (1 << 7)
/* Reset: 0x0         Access: RO */
#define ANPA_PER_CORE_OUTPUTS_STATUS_VFIQ_N (1 << 8)

/**** msg_in register ****/
/*
 * CPU read this register to receive input (char) from simulation.
 * Reset: 0x0         Access: RW
 */
#define ANPA_PER_CORE_MSG_IN_DATA_MASK   0x000000FF
#define ANPA_PER_CORE_MSG_IN_DATA_SHIFT  0
/*
 * Indicates the data is valid.
 * Cleared on read
 * Reset: 0x0         Access: RW, RtoClr
 */
#define ANPA_PER_CORE_MSG_IN_VALID       (1 << 8)

/**** msg_out register ****/
/*
 * CPU writes to this register to broadcast signaling to simulation.
 * Reset: 0x0         Access: RW
 */
#define ANPA_PER_CORE_MSG_OUT_VEC_MASK   0x0000FFFF
#define ANPA_PER_CORE_MSG_OUT_VEC_SHIFT  0

#ifdef __cplusplus
}
#endif

#endif

/** @} */
