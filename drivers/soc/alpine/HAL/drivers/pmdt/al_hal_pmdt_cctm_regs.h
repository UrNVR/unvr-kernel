/*
 * Copyright 2018, Amazon.com, Inc. or its affiliates. All Rights Reserved
 */

/**
 *  @{
 * @file   al_hal_pmdt_cctm_regs.h
 *
 * @brief pmdt_cctm registers
 *
 * This file was auto-generated by RegGen v1.2.1
 *
 */

#ifndef __AL_HAL_PMDT_CCTM_REGS_H__
#define __AL_HAL_PMDT_CCTM_REGS_H__

#include "al_hal_plat_types.h"

#ifdef __cplusplus
extern "C" {
#endif

/*
 * Unit Registers
 */

/*
 * General Configuration
 */
struct al_pmdt_cctm_cctm_cfg {
	/* [0x0] status register */
	uint32_t status;
	/*
	 * [0x4] Pause delay configuration
	 * Pause start delay from pause trigger assert
	 * Reset: 0x0         Access: RW
	 */
	uint32_t cfg_pause_delay;
	/* [0x8] Pause delay configuration */
	uint32_t cfg_pause_ctrl;
	/* [0xc] */
	uint32_t rsrvd_0;
	/*
	 * [0x10] Active image at the time
	 * active incoming triggers image
	 * Reset: 0x0         Access: RO
	 */
	uint32_t triggers_0;
	/*
	 * [0x14] Active image at the time
	 * active incoming triggers image
	 * Reset: 0x0         Access: RO
	 */
	uint32_t triggers_1;
	/*
	 * [0x18] Active image at the time
	 * active incoming triggers image
	 * Reset: 0x0         Access: RO
	 */
	uint32_t triggers_2;
	/*
	 * [0x1c] Active image at the time
	 * active incoming triggers image
	 * Reset: 0x0         Access: RO
	 */
	uint32_t triggers_3;
	/*
	 * [0x20] Active image at the time
	 * active imcoming gpio triggers image
	 * Reset: 0x0         Access: RO
	 */
	uint32_t gpio_0;
	/*
	 * [0x24] Active image at the time
	 * active imcoming gpio triggers image
	 * Reset: 0x0         Access: RO
	 */
	uint32_t gpio_1;
	/*
	 * [0x28] Active image at the time
	 * active imcoming gpio triggers image
	 * Reset: 0x0         Access: RO
	 */
	uint32_t gpio_2;
	/*
	 * [0x2c] Active image at the time
	 * active imcoming gpio triggers image
	 * Reset: 0x0         Access: RO
	 */
	uint32_t gpio_3;
	/*
	 * [0x30] Inferred Pause at the time
	 * active pause instructions downstream
	 * Reset: 0x0         Access: RO
	 */
	uint32_t pause_0;
	/*
	 * [0x34] Inferred Pause at the time
	 * active pause instructions downstream
	 * Reset: 0x0         Access: RO
	 */
	uint32_t pause_1;
	/*
	 * [0x38] Inferred Pause at the time
	 * active pause instructions downstream
	 * Reset: 0x0         Access: RO
	 */
	uint32_t pause_2;
	/*
	 * [0x3c] Inferred Pause at the time
	 * active pause instructions downstream
	 * Reset: 0x0         Access: RO
	 */
	uint32_t pause_3;
	/*
	 * [0x40] Downstream sources enable
	 * Events enable
	 * Reset: 0x0         Access: RW
	 */
	uint32_t event_en_0;
	/*
	 * [0x44] Downstream sources enable
	 * Events enable
	 * Reset: 0x0         Access: RW
	 */
	uint32_t event_en_1;
	/*
	 * [0x48] Downstream sources enable
	 * Events enable
	 * Reset: 0x0         Access: RW
	 */
	uint32_t event_en_2;
	/*
	 * [0x4c] Downstream sources enable
	 * Events enable
	 * Reset: 0x0         Access: RW
	 */
	uint32_t event_en_3;
	/*
	 * [0x50] GPIO selection
	 * selection of incoming gpio to be routed out
	 * Reset: 0x0         Access: RW
	 */
	uint32_t gpio_en_0;
	/*
	 * [0x54] GPIO selection
	 * selection of incoming gpio to be routed out
	 * Reset: 0x0         Access: RW
	 */
	uint32_t gpio_en_1;
	/*
	 * [0x58] GPIO selection
	 * selection of incoming gpio to be routed out
	 * Reset: 0x0         Access: RW
	 */
	uint32_t gpio_en_2;
	/*
	 * [0x5c] GPIO selection
	 * selection of incoming gpio to be routed out
	 * Reset: 0x0         Access: RW
	 */
	uint32_t gpio_en_3;
	/*
	 * [0x60] Pause instruction
	 * SW forced pause downstream
	 * Reset: 0x0         Access: RW
	 */
	uint32_t pause_en_0;
	/*
	 * [0x64] Pause instruction
	 * SW forced pause downstream
	 * Reset: 0x0         Access: RW
	 */
	uint32_t pause_en_1;
	/*
	 * [0x68] Pause instruction
	 * SW forced pause downstream
	 * Reset: 0x0         Access: RW
	 */
	uint32_t pause_en_2;
	/*
	 * [0x6c] Pause instruction
	 * SW forced pause downstream
	 * Reset: 0x0         Access: RW
	 */
	uint32_t pause_en_3;
	/*
	 * [0x70] Clear instruction
	 * Clear downstream sources.
	 * Reset: 0x0         Access: WO
	 */
	uint32_t clear_en_0;
	/*
	 * [0x74] Clear instruction
	 * Clear downstream sources.
	 * Reset: 0x0         Access: WO
	 */
	uint32_t clear_en_1;
	/*
	 * [0x78] Clear instruction
	 * Clear downstream sources.
	 * Reset: 0x0         Access: WO
	 */
	uint32_t clear_en_2;
	/*
	 * [0x7c] Clear instruction
	 * Clear downstream sources.
	 * Reset: 0x0         Access: WO
	 */
	uint32_t clear_en_3;
	/*
	 * [0x80] SW Set command
	 * local trigger set by SW.
	 * Reset: 0x0         Access: RW
	 */
	uint32_t sw_set_0;
	/*
	 * [0x84] SW Set command
	 * local trigger set by SW.
	 * Reset: 0x0         Access: RW
	 */
	uint32_t sw_set_1;
	/*
	 * [0x88] SW Set command
	 * local trigger set by SW.
	 * Reset: 0x0         Access: RW
	 */
	uint32_t sw_set_2;
	/*
	 * [0x8c] SW Set command
	 * local trigger set by SW.
	 * Reset: 0x0         Access: RW
	 */
	uint32_t sw_set_3;
	/* [0x90] Misc setups */
	uint32_t tstamp_ctl0;
	/* [0x94] Misc setups */
	uint32_t tstamp_ctl1;
	/*
	 * [0x98] Tstamp0
	 * Time stamp low 32 bits
	 * Reset: 0x0         Access: RO
	 */
	uint32_t tstamp_low;
	/*
	 * [0x9c] Tstamp1
	 * Time stamp high 32 bits
	 * Reset: 0x0         Access: RO
	 */
	uint32_t tstamp_high;
	/*
	 * [0xa0] Tstamp offset low
	 * Time stamp offset low 32 bits
	 * Reset: 0x0         Access: RW
	 */
	uint32_t tstamp_offset_low;
	/*
	 * [0xa4] Tstamp offset high
	 * Time stamp offset high 32 bits
	 * Reset: 0x0         Access: RW
	 */
	uint32_t tstamp_offset_high;
	/* [0xa8] */
	uint32_t rsrvd_1[22];
};

/*
 * Cross Reference between events
 */
struct al_pmdt_cctm_cross_matrix {
	/*
	 * [0x0] Pause reflected by other sources
	 * Event pause dependency on other triggers. [31:0]
	 * Reset: 0x0         Access: RW
	 */
	uint32_t infer_pause_0;
	/*
	 * [0x4] Pause reflected by other sources
	 * Event pause dependency on other triggers. [63:32]
	 * Reset: 0x0         Access: RW
	 */
	uint32_t infer_pause_1;
	/*
	 * [0x8] Pause reflected by other sources
	 * Event pause dependency on other triggers. [95:64]
	 * Reset: 0x0         Access: RW
	 */
	uint32_t infer_pause_2;
	/*
	 * [0xc] Pause reflected by other sources
	 * Event pause dependency on other triggers. [127:96]
	 * Reset: 0x0         Access: RW
	 */
	uint32_t infer_pause_3;
};

struct al_pmdt_cctm_regs {
	/* [0x0] Global interrupt controller */
	uint32_t interrupt_ctl[64];
	/* [0x100] General Configuration */
	struct al_pmdt_cctm_cctm_cfg cctm_cfg;
	/* [0x200] */
	uint32_t rsrvd_0[384];
	/* [0x800] Cross Reference between events */
	struct al_pmdt_cctm_cross_matrix cross_matrix[128];
	/* [0x1000] */
	uint32_t rsrvd_1[15360];
};


/*
 * Registers Fields
 */

/**** status register ****/
/*
 * Number of implemented counters
 * Reset: 0x0         Access: RO
 */
#define PMDT_CCTM_CCTM_CFG_STATUS_EVENTS_IMPL_MASK 0x000000FF
#define PMDT_CCTM_CCTM_CFG_STATUS_EVENTS_IMPL_SHIFT 0
/*
 * Number of active tracked events
 * Reset: 0x0         Access: RO
 */
#define PMDT_CCTM_CCTM_CFG_STATUS_EVENT_SUM_MASK 0x0000FF00
#define PMDT_CCTM_CCTM_CFG_STATUS_EVENT_SUM_SHIFT 8
/*
 * The event number field is valid
 * Reset: 0x0         Access: RO
 */
#define PMDT_CCTM_CCTM_CFG_STATUS_EVENTS_VALID (1 << 16)
/*
 * Reserved
 * Reset: 0x0         Access: RO
 */
#define PMDT_CCTM_CCTM_CFG_STATUS_RSRVD_23_17_MASK 0x00FE0000
#define PMDT_CCTM_CCTM_CFG_STATUS_RSRVD_23_17_SHIFT 17
/*
 * PMU/CCTM revision
 * Reset: 0x0         Access: RO
 */
#define PMDT_CCTM_CCTM_CFG_STATUS_REVISION_MASK 0xFF000000
#define PMDT_CCTM_CCTM_CFG_STATUS_REVISION_SHIFT 24

/**** cfg_pause_ctrl register ****/
/*
 * enable pause start delay from software pause assert
 * Reset: 0x0         Access: RW
 */
#define PMDT_CCTM_CCTM_CFG_CFG_PAUSE_CTRL_SW_SET_DELAY (1 << 0)
/*
 * enable pause start delay from pause inferred trigger assert
 * Reset: 0x0         Access: RW
 */
#define PMDT_CCTM_CCTM_CFG_CFG_PAUSE_CTRL_INFER_DELAY (1 << 1)
/*
 * reserved
 * Reset: 0x0         Access: RW
 */
#define PMDT_CCTM_CCTM_CFG_CFG_PAUSE_CTRL_RSVD_27_2_MASK 0x0FFFFFFC
#define PMDT_CCTM_CCTM_CFG_CFG_PAUSE_CTRL_RSVD_27_2_SHIFT 2
/*
 * Reset-deassertion pause extend. Power of two of the value.
 * Reset: 0x0         Access: RW
 */
#define PMDT_CCTM_CCTM_CFG_CFG_PAUSE_CTRL_PAUSE_EXTEND_MASK 0xF0000000
#define PMDT_CCTM_CCTM_CFG_CFG_PAUSE_CTRL_PAUSE_EXTEND_SHIFT 28

/**** tstamp_ctl0 register ****/
/*
 * Time Stamp window ratio vs. the local clock.
 * Reset: 0x1f4       Access: RW
 */
#define PMDT_CCTM_CCTM_CFG_TSTAMP_CTL0_TSTAMP_RATIO_MASK 0x0FFFFFFF
#define PMDT_CCTM_CCTM_CFG_TSTAMP_CTL0_TSTAMP_RATIO_SHIFT 0
/*
 * reserved
 * Reset: 0x0         Access: RW
 */
#define PMDT_CCTM_CCTM_CFG_TSTAMP_CTL0_RSVD_31_28_MASK 0xF0000000
#define PMDT_CCTM_CCTM_CFG_TSTAMP_CTL0_RSVD_31_28_SHIFT 28

/**** tstamp_ctl1 register ****/
/*
 * Time Stamp Clear trigger
 * Reset: 0x0         Access: WO
 */
#define PMDT_CCTM_CCTM_CFG_TSTAMP_CTL1_TSTAMP_CLEAR (1 << 0)
/*
 * reserved
 * Reset: 0x0         Access: RO
 */
#define PMDT_CCTM_CCTM_CFG_TSTAMP_CTL1_RSVD_29_1_MASK 0x3FFFFFFE
#define PMDT_CCTM_CCTM_CFG_TSTAMP_CTL1_RSVD_29_1_SHIFT 1
/*
 * Time Stamp counter pause
 * Reset: 0x0         Access: RW
 */
#define PMDT_CCTM_CCTM_CFG_TSTAMP_CTL1_TSTAMP_PAUSE (1 << 30)
/*
 * Time Stamp counter enable.
 * Reset: 0x0         Access: RW
 */
#define PMDT_CCTM_CCTM_CFG_TSTAMP_CTL1_TSTAMP_EN (1 << 31)

#ifdef __cplusplus
}
#endif

#endif

/** @} */
