/*
 * Copyright 2018, Amazon.com, Inc. or its affiliates. All Rights Reserved
 */

/**
 *  @{
 * @file   al_hal_pmdt_pmu_regs.h
 *
 * @brief pmdt_pmu registers
 *
 * This file was auto-generated by RegGen v1.2.1
 *
 */

#ifndef __AL_HAL_PMDT_PMU_REGS_H__
#define __AL_HAL_PMDT_PMU_REGS_H__

#include "al_hal_plat_types.h"

#ifdef __cplusplus
extern "C" {
#endif

/*
 * Unit Registers
 */

/*
 * General Configuration - Shared PMU setup and status
 */
struct al_pmdt_pmu_pmu_cfg {
	/* [0x0] Misc setups */
	uint32_t general;
	/*
	 * [0x4] Window  size
	 * Window  size
	 * Reset: 0x0         Access: RW
	 */
	uint32_t window;
	/*
	 * [0x8] current time stamp low
	 * low 32 bits
	 * Reset: 0x0         Access: RO
	 */
	uint32_t tstamp_low;
	/*
	 * [0xc] current time stamp high
	 * high 32 bits
	 * Reset: 0x0         Access: RO
	 */
	uint32_t tstamp_high;
	/*
	 * [0x10] current window count low
	 * low 32 bits
	 * Reset: 0x0         Access: RO
	 */
	uint32_t window_low;
	/*
	 * [0x14] current window count high
	 * high 32 bits
	 * Reset: 0x0         Access: RO
	 */
	uint32_t window_high;
	/* [0x18] Logged report Trigger information */
	uint32_t report_status;
	/*
	 * [0x1c] logged violation count
	 * number of violations accumulated for the logged event so far.
	 * Reset: 0x0         Access: RO
	 */
	uint32_t report_viol_cnt;
	/*
	 * [0x20] The report logged time stamp low
	 * low 32 bits
	 * Reset: 0x0         Access: RO
	 */
	uint32_t report_tstamp_low;
	/*
	 * [0x24] The report logged time stamp high
	 * high 32 bits
	 * Reset: 0x0         Access: RO
	 */
	uint32_t report_tstamp_high;
	/*
	 * [0x28] The report logged window count low
	 * low 32 bits
	 * Reset: 0x0         Access: RO
	 */
	uint32_t report_window_low;
	/*
	 * [0x2c] The report logged window count high
	 * high 32 bits
	 * Reset: 0x0         Access: RO
	 */
	uint32_t report_window_high;
	/*
	 * [0x30] Delay enable
	 * max value for delaying the enable start from the time it is asserted by software or by
	 * CCTM
	 * Reset: 0x0         Access: RW
	 */
	uint32_t delayed_enable;
	/*
	 * [0x34] Delay pause
	 * Once paused from upstream CCTM - delay pause assertion by this muber of clock cycles,
	 * Reset: 0x0         Access: RW
	 */
	uint32_t delayed_pause;
	/* [0x38] */
	uint32_t rsrvd_0;
	/* [0x3c] Clear instruction */
	uint32_t pmu_status;
};

/*
 * Per Bit (Event) setup and statuses
 */
struct al_pmdt_pmu_events {
	/*
	 * [0x0] Event counters enable
	 * enabling the event counters
	 * Reset: 0x0         Access: RW
	 */
	uint32_t event;
	/*
	 * [0x4] Window usage
	 * Per event ignore window frame and assume accumulation forever (till cleared)
	 * Reset: 0x0         Access: RW
	 */
	uint32_t window_disable;
	/*
	 * [0x8] GPIO selection
	 * selection of incoming events to be routed out to GPIO
	 * Reset: 0xffffffff  Access: RW
	 */
	uint32_t gpio;
	/*
	 * [0xc] Pause instruction
	 * reflect incoming upstream pause command to the associated group, otherwise, ignore.
	 * Reset: 0xffffffff  Access: RW
	 */
	uint32_t pause_group;
	/*
	 * [0x10] Clear instruction
	 * reflect incoming upstream clear command to the associated group, otherwise, ignore.
	 * Reset: 0xffffffff  Access: RW
	 */
	uint32_t clear_group;
	/*
	 * [0x14] SW Events set assist register
	 * SW set of the local triggers (Pulse)
	 * Reset: 0x0         Access: WO
	 */
	uint32_t sw_set_trig;
	/*
	 * [0x18] Cross Pause
	 * Accumulative local pause image
	 * Reset: 0x0         Access: RO
	 */
	uint32_t cross_freeze;
	/*
	 * [0x1c] Violation image
	 * Current violation image of the local events
	 * Reset: 0x0         Access: RO
	 */
	uint32_t local_viol;
};

struct al_pmdt_pmu_specials {
	/* [0x0] Trace Vector assembly */
	uint32_t trace_select;
	/* [0x4] */
	uint32_t rsrvd_0;
	/*
	 * [0x8] Time Stamp Offset Low
	 * Time Stamp Offset Low
	 * Reset: 0x0         Access: RW
	 */
	uint32_t tstamp_offset_low;
	/*
	 * [0xc] Time Stamp Offset High
	 * Time Stamp Offset High
	 * Reset: 0x0         Access: RW
	 */
	uint32_t tstamp_offset_high;
	/* [0x10] */
	uint32_t rsrvd_1[4];
};

/*
 * Cross Reference between events
 */
struct al_pmdt_pmu_cross_matrix {
	/* [0x0] Trigger associated with this counter */
	uint32_t event_map;
	/*
	 * [0x4] Local pause cross relation
	 * local pause refection by other event triggers
	 * Reset: 0x0         Access: RW
	 */
	uint32_t cross_trig;
	/* [0x8] */
	uint32_t rsrvd_0[2];
	/*
	 * [0x10] Threshold Registers
	 * Event threshold low - low 32 bits
	 * Reset: 0x0         Access: RW
	 */
	uint32_t threshold_low_lo;
	/*
	 * [0x14] Threshold Registers
	 * Event threshold low - high 32 bits
	 * Reset: 0x0         Access: RW
	 */
	uint32_t threshold_low_hi;
	/*
	 * [0x18] Threshold Registers
	 * Event threshold high - low 32 bits
	 * Reset: 0x0         Access: RW
	 */
	uint32_t threshold_high_lo;
	/*
	 * [0x1c] Threshold Registers
	 * Event threshold high - high 32 bits
	 * Reset: 0x0         Access: RW
	 */
	uint32_t threshold_high_hi;
	/* [0x20] Event Status */
	uint32_t event_status;
	/*
	 * [0x24] Current Event Violations
	 * accumulative violation count
	 * Reset: 0x0         Access: RO
	 */
	uint32_t violation_count;
	/* [0x28] */
	uint32_t rsrvd_1[2];
	/*
	 * [0x30] Current Event count registers
	 * low 32 bits
	 * Reset: 0x0         Access: RO
	 */
	uint32_t current_cnt_lo;
	/*
	 * [0x34] Current Event count registers
	 * high 32 bits
	 * Reset: 0x0         Access: RO
	 */
	uint32_t current_cnt_hi;
	/*
	 * [0x38] Last window frame Event count snapshot
	 * low 32 bits
	 * Reset: 0x0         Access: RO
	 */
	uint32_t previous_cnt_lo;
	/*
	 * [0x3c] Last window frame Event count snapshot
	 * high 32 bits
	 * Reset: 0x0         Access: RO
	 */
	uint32_t previous_cnt_hi;
};

struct al_pmdt_pmu_regs {
	/* [0x0] General Configuration - Shared PMU setup and status */
	struct al_pmdt_pmu_pmu_cfg pmu_cfg;
	/* [0x40] Per Bit (Event) setup and statuses */
	struct al_pmdt_pmu_events events;
	/* [0x60] */
	struct al_pmdt_pmu_specials specials;
	/*
	 * [0x80] local interrupt controller. Group A presents the events violations, while Group B
	 * presents errors assembled from the local complex.
	 */
	uint32_t interrupt_ctl[32];
	/* [0x100] */
	uint32_t rsrvd_0[448];
	/* [0x800] Cross Reference between events */
	struct al_pmdt_pmu_cross_matrix cross_matrix[32];
	/* [0x1000] */
	uint32_t rsrvd_1[15360];
};


/*
 * Registers Fields
 */

/**** general register ****/
/*
 * Enable the local PMU module.
 * Reset: 0x0         Access: RW
 */
#define PMDT_PMU_PMU_CFG_GENERAL_PMU_ENABLE (1 << 0)
/*
 * Enable windows framing. Otherwise - accumulate with an infinite window frame
 * Reset: 0x0         Access: RW
 */
#define PMDT_PMU_PMU_CFG_GENERAL_WINDOWS_EN (1 << 1)
/*
 * Saturate enable. If set - saturate the window counter. Otherwise - wraps around
 * Reset: 0x0         Access: RW
 */
#define PMDT_PMU_PMU_CFG_GENERAL_SATURATE_EN (1 << 2)
/*
 * if set - enable external increment value per event. Other - increment by one.
 * Reset: 0x0         Access: RW
 */
#define PMDT_PMU_PMU_CFG_GENERAL_INC_VAL_EN (1 << 3)
/*
 * Reset-deassertion pause extend. Power of two of the value.
 * Reset: 0x0         Access: RW
 */
#define PMDT_PMU_PMU_CFG_GENERAL_PAUSE_EXTEND_MASK 0x000000F0
#define PMDT_PMU_PMU_CFG_GENERAL_PAUSE_EXTEND_SHIFT 4
/*
 * enable overflow interrupt
 * Reset: 0x0         Access: RW
 */
#define PMDT_PMU_PMU_CFG_GENERAL_OVF_INTR_EN (1 << 8)
/*
 * enable underflow interrupt
 * Reset: 0x0         Access: RW
 */
#define PMDT_PMU_PMU_CFG_GENERAL_UNF_INTR_EN (1 << 9)
/*
 * enable overflow triggering
 * Reset: 0x0         Access: RW
 */
#define PMDT_PMU_PMU_CFG_GENERAL_OVF_TRIG_EN (1 << 10)
/*
 * enable underflow triggering
 * Reset: 0x0         Access: RW
 */
#define PMDT_PMU_PMU_CFG_GENERAL_UNF_TRIG_EN (1 << 11)
/*
 * Use Pulse triggers, otherwise Level triggers. For better integration - leave as zero (level
 * triggers)
 * Reset: 0x0         Access: RW
 */
#define PMDT_PMU_PMU_CFG_GENERAL_PULSE_TRIG (1 << 12)
/*
 * Enable routing to GPIO from this PMU
 * Reset: 0x0         Access: RW
 */
#define PMDT_PMU_PMU_CFG_GENERAL_GPIO_EN (1 << 13)
/*
 * Start tracking at window position (otherwise start immediately once enabled).
 * Reset: 0x0         Access: RW
 */
#define PMDT_PMU_PMU_CFG_GENERAL_START_BOUNDARY (1 << 14)
/*
 * Detach CCTM enable from affecting locally. If set - use only local enable located at bit[0] of
 * this register
 * Reset: 0x0         Access: RW
 */
#define PMDT_PMU_PMU_CFG_GENERAL_ENABLE_OVERRIDE (1 << 15)
/*
 * Base time scale for the frame windows clocking
 * Reset: 0x0         Access: RW
 */
#define PMDT_PMU_PMU_CFG_GENERAL_TIMER_RATIO_MASK 0x0FFF0000
#define PMDT_PMU_PMU_CFG_GENERAL_TIMER_RATIO_SHIFT 16
/*
 * Error indications from monitors also cause a trigger
 * Reset: 0x0         Access: RW
 */
#define PMDT_PMU_PMU_CFG_GENERAL_ERROR_TRIG_EN (1 << 28)
/*
 * Error indications from monitors also cause a GPIO
 * Reset: 0x0         Access: RW
 */
#define PMDT_PMU_PMU_CFG_GENERAL_ERROR_GPIO_EN (1 << 29)
/*
 * Reserved
 * Reset: 0x0         Access: RW
 */
#define PMDT_PMU_PMU_CFG_GENERAL_RSVD_30_28 (1 << 30)
/*
 * SW clear parallel to HW central clear
 * Reset: 0x0         Access: WO
 */
#define PMDT_PMU_PMU_CFG_GENERAL_CLEAR   (1 << 31)

/**** report_status register ****/
/*
 * The trigger represents this event counter number
 * Reset: 0x0         Access: RO
 */
#define PMDT_PMU_PMU_CFG_REPORT_STATUS_EVENT_NUM_MASK 0x0000003F
#define PMDT_PMU_PMU_CFG_REPORT_STATUS_EVENT_NUM_SHIFT 0
/*
 * reserved
 * Reset: 0x0         Access: RO
 */
#define PMDT_PMU_PMU_CFG_REPORT_STATUS_RSVD_27_6_MASK 0x0FFFFFC0
#define PMDT_PMU_PMU_CFG_REPORT_STATUS_RSVD_27_6_SHIFT 6
/*
 * The trigger log reported an underflow
 * Reset: 0x0         Access: RO
 */
#define PMDT_PMU_PMU_CFG_REPORT_STATUS_UNF (1 << 28)
/*
 * The trigger log reported an overflow
 * Reset: 0x0         Access: RO
 */
#define PMDT_PMU_PMU_CFG_REPORT_STATUS_OVF (1 << 29)
/*
 * reserved
 * Reset: 0x0         Access: RO
 */
#define PMDT_PMU_PMU_CFG_REPORT_STATUS_RSVD_30 (1 << 30)
/*
 * logged information is valid
 * Reset: 0x0         Access: RO
 */
#define PMDT_PMU_PMU_CFG_REPORT_STATUS_VALID (1 << 31)

/**** pmu_status register ****/
/*
 * Number of implemented counters
 * Reset: 0x0         Access: RO
 */
#define PMDT_PMU_PMU_CFG_PMU_STATUS_EVENTS_IMPL_MASK 0x0000003F
#define PMDT_PMU_PMU_CFG_PMU_STATUS_EVENTS_IMPL_SHIFT 0
/*
 * Reserved
 * Reset: 0x0         Access: RO
 */
#define PMDT_PMU_PMU_CFG_PMU_STATUS_RSRVD_7_6_MASK 0x000000C0
#define PMDT_PMU_PMU_CFG_PMU_STATUS_RSRVD_7_6_SHIFT 6
/*
 * Number of active tracked events
 * Reset: 0x0         Access: RO
 */
#define PMDT_PMU_PMU_CFG_PMU_STATUS_EVENT_SUM_MASK 0x00003F00
#define PMDT_PMU_PMU_CFG_PMU_STATUS_EVENT_SUM_SHIFT 8
/*
 * Reserved
 * Reset: 0x0         Access: RO
 */
#define PMDT_PMU_PMU_CFG_PMU_STATUS_RSRVD_15_14_MASK 0x0000C000
#define PMDT_PMU_PMU_CFG_PMU_STATUS_RSRVD_15_14_SHIFT 14
/*
 * The event number field is valid
 * Reset: 0x0         Access: RO
 */
#define PMDT_PMU_PMU_CFG_PMU_STATUS_EVENTS_VALID (1 << 16)
/*
 * In case of a combined PMU complex, the number of tracked event channels per AXI monitor.
 * Otherwise reserved
 * Reset: 0x0         Access: RO
 */
#define PMDT_PMU_PMU_CFG_PMU_STATUS_TRC_NUM_MASK 0x000E0000
#define PMDT_PMU_PMU_CFG_PMU_STATUS_TRC_NUM_SHIFT 17
/*
 * In case of a combined PMU complex, the number of tracked event channels per AXI monitor.
 * Otherwise reserved
 * Reset: 0x0         Access: RO
 */
#define PMDT_PMU_PMU_CFG_PMU_STATUS_TRK_NUM_MASK 0x00F00000
#define PMDT_PMU_PMU_CFG_PMU_STATUS_TRK_NUM_SHIFT 20
/*
 * In case of a combined PMU complex, the number of AXI monitors attached. Otherwise reserved
 * Reset: 0x0         Access: RO
 */
#define PMDT_PMU_PMU_CFG_PMU_STATUS_MON_NUM_MASK 0x03000000
#define PMDT_PMU_PMU_CFG_PMU_STATUS_MON_NUM_SHIFT 24
/*
 * In case of a combined PMU complex, the number of ELA tracers attached. Otherwise reserved
 * Reset: 0x0         Access: RO
 */
#define PMDT_PMU_PMU_CFG_PMU_STATUS_ELA_NUM_MASK 0x0C000000
#define PMDT_PMU_PMU_CFG_PMU_STATUS_ELA_NUM_SHIFT 26
/*
 * PMU revision
 * Reset: 0x0         Access: RO
 */
#define PMDT_PMU_PMU_CFG_PMU_STATUS_REVISION_MASK 0xF0000000
#define PMDT_PMU_PMU_CFG_PMU_STATUS_REVISION_SHIFT 28

/**** trace_select register ****/
/*
 * Select event counter to be traced once per window.
 * Reset: 0x0         Access: RW
 */
#define PMDT_PMU_SPECIALS_TRACE_SELECT_SEL_MASK 0x000000FF
#define PMDT_PMU_SPECIALS_TRACE_SELECT_SEL_SHIFT 0
/*
 * Reserved
 * Reset: 0x0         Access: RW
 */
#define PMDT_PMU_SPECIALS_TRACE_SELECT_RSRVD_15_8_MASK 0x0000FF00
#define PMDT_PMU_SPECIALS_TRACE_SELECT_RSRVD_15_8_SHIFT 8
/*
 * Auxiliary controls to be used outside of the PMU but use the local powered up domain
 * configuration infrastructure
 * Reset: 0x0         Access: RW
 */
#define PMDT_PMU_SPECIALS_TRACE_SELECT_AUXILIARY_MASK 0x00FF0000
#define PMDT_PMU_SPECIALS_TRACE_SELECT_AUXILIARY_SHIFT 16
/*
 * Reserved
 * Reset: 0x0         Access: RW
 */
#define PMDT_PMU_SPECIALS_TRACE_SELECT_RSRVD_30_23_MASK 0x7F000000
#define PMDT_PMU_SPECIALS_TRACE_SELECT_RSRVD_30_23_SHIFT 24
/*
 * Enable routing to Trace Buffer (ELA)
 * Reset: 0x0         Access: RW
 */
#define PMDT_PMU_SPECIALS_TRACE_SELECT_TRACE_EN (1 << 31)

/**** event_map register ****/
/*
 * The trigger numeric position associated with the specific event counter. Events 63..0 are
 * external, events 127..64 are internal. If trig-reroute is asserted then the event number is the
 * rerouted counter number
 * Reset: 0x0         Access: RW
 */
#define PMDT_PMU_CROSS_MATRIX_EVENT_MAP_TRIG_NUM_MASK 0x0000007F
#define PMDT_PMU_CROSS_MATRIX_EVENT_MAP_TRIG_NUM_SHIFT 0
/*
 * The trigger is a result of another event counter violation report. (recursive dependency).
 * Reset: 0x0         Access: RW
 */
#define PMDT_PMU_CROSS_MATRIX_EVENT_MAP_TRIG_REROUTE (1 << 7)
/*
 * reserved
 * Reset: 0x0         Access: RW
 */
#define PMDT_PMU_CROSS_MATRIX_EVENT_MAP_RSVD_31_8_MASK 0xFFFFFF00
#define PMDT_PMU_CROSS_MATRIX_EVENT_MAP_RSVD_31_8_SHIFT 8

/**** event_status register ****/
/*
 * 00=disabled, 01=active, 11=paused
 * Reset: 0x0         Access: RO
 */
#define PMDT_PMU_CROSS_MATRIX_EVENT_STATUS_STATUS_MASK 0x00000003
#define PMDT_PMU_CROSS_MATRIX_EVENT_STATUS_STATUS_SHIFT 0
/*
 * reserved
 * Reset: 0x0         Access: RO
 */
#define PMDT_PMU_CROSS_MATRIX_EVENT_STATUS_RSVD_15_2_MASK 0x0000FFFC
#define PMDT_PMU_CROSS_MATRIX_EVENT_STATUS_RSVD_15_2_SHIFT 2
/*
 * event mapped trigger pointer. Mapping to "MSB set" refers to rerouting of selected internal
 * violation into the counter, instead of external trigger.
 * Reset: 0x0         Access: RO
 */
#define PMDT_PMU_CROSS_MATRIX_EVENT_STATUS_TRIG_NUM_MASK 0x00FF0000
#define PMDT_PMU_CROSS_MATRIX_EVENT_STATUS_TRIG_NUM_SHIFT 16
/*
 * reserved
 * Reset: 0x0         Access: RO
 */
#define PMDT_PMU_CROSS_MATRIX_EVENT_STATUS_RSVD_26_24_MASK 0x07000000
#define PMDT_PMU_CROSS_MATRIX_EVENT_STATUS_RSVD_26_24_SHIFT 24
/*
 * local event local and global enabled
 * Reset: 0x0         Access: RO
 */
#define PMDT_PMU_CROSS_MATRIX_EVENT_STATUS_VALID (1 << 27)
/*
 * paused for any reason
 * Reset: 0x0         Access: RO
 */
#define PMDT_PMU_CROSS_MATRIX_EVENT_STATUS_PAUSED (1 << 28)
/*
 * underflow violation
 * Reset: 0x0         Access: RO
 */
#define PMDT_PMU_CROSS_MATRIX_EVENT_STATUS_UNF (1 << 29)
/*
 * overflow violation
 * Reset: 0x0         Access: RO
 */
#define PMDT_PMU_CROSS_MATRIX_EVENT_STATUS_OVF (1 << 30)
/*
 * any violation
 * Reset: 0x0         Access: RO
 */
#define PMDT_PMU_CROSS_MATRIX_EVENT_STATUS_VIOL (1 << 31)

#ifdef __cplusplus
}
#endif

#endif

/** @} */
