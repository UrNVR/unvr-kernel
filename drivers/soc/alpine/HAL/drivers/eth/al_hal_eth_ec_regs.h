/*
 * Copyright 2018, Amazon.com, Inc. or its affiliates. All Rights Reserved
 */

/**
 *  @{
 * @file   al_hal_eth_ec_regs.h
 *
 * @brief ec registers
 *
 * This file was auto-generated by RegGen v1.2.1
 *
 */

#ifndef __AL_HAL_ETH_EC_REGS_H__
#define __AL_HAL_ETH_EC_REGS_H__

#include "al_hal_plat_types.h"

#ifdef __cplusplus
extern "C" {
#endif

/*
 * Unit Registers
 */

/*
 * General configuration of the system clock domain features in the Ethernet controller
 */
struct al_ec_gen {
	/* [0x0] Ethernet controller Version */
	uint32_t version;
	/* [0x4] Enable modules operation. */
	uint32_t en;
	/* [0x8] Enable FIFO operation on the EC side. */
	uint32_t fifo_en;
	/* [0xc] General L2 configuration for the Ethernet controller */
	uint32_t l2;
	/* [0x10] Configure protocol index values */
	uint32_t cfg_i;
	/* [0x14] Configure protocol index values (extended protocols) */
	uint32_t cfg_i_ext;
	/* [0x18] Enable modules operation (extended operations). */
	uint32_t en_ext;
	/* [0x1c] memory init */
	uint32_t mem_init;
	/* [0x20] sw reset */
	uint32_t sw_reset;
	/*
	 * [0x24] scratch pad register
	 * Reset: 0x0         Access: RW
	 */
	uint32_t scratch_pad_1;
	/*
	 * [0x28] scratch pad register
	 * Reset: 0x0         Access: RW
	 */
	uint32_t scratch_pad_2;
	/*
	 * [0x2c] scratch pad register
	 * Reset: 0x0         Access: RW
	 */
	uint32_t scratch_pad_3;
	/*
	 * [0x30] scratch pad register
	 * Reset: 0x0         Access: RW
	 */
	uint32_t scratch_pad_4;
	/*
	 * [0x34] scratch pad register
	 * Reset: 0x0         Access: RW
	 */
	uint32_t scratch_pad_5;
	/* [0x38] */
	uint32_t rsrvd_0[2];
};

/*
 * Configuration of the MAC clock domain features in the Ethernet controller
 */
struct al_ec_mac {
	/* [0x0] General configuration of the MAC side of the Ethernet controller */
	uint32_t gen;
	/* [0x4] Minimum packet size */
	uint32_t min_pkt;
	/* [0x8] Maximum packet size */
	uint32_t max_pkt;
	/* [0xc] */
	uint32_t rsrvd_0[13];
};

/*
 * Configuration of the Rx FIFO
 */
struct al_ec_rxf {
	/* [0x0] Rx FIFO input controller configuration 1 */
	uint32_t cfg_1;
	/* [0x4] Rx FIFO input controller configuration 2 */
	uint32_t cfg_2;
	/* [0x8] Threshold to start reading packet from the Rx FIFO. */
	uint32_t rd_fifo;
	/* [0xc] Threshold to stop writing packet to the Rx FIFO */
	uint32_t wr_fifo;
	/* [0x10] Threshold to stop writing packet to the loopback FIFO */
	uint32_t lb_fifo;
	/* [0x14] Rx FIFO input controller loopback FIFO configuration */
	uint32_t cfg_lb;
	/* [0x18] Configuration for dropping packet at the FIFO output */
	uint32_t out_drop;
	/* [0x1c] RXF data depth expose */
	uint32_t data;
	/* [0x20] RXF info depth expose */
	uint32_t info;
	/* [0x24] */
	uint32_t rsrvd_0[23];
};

/*
 * Ethernet Parsing Engine general configuration
 */
struct al_ec_epe {
	/* [0x0] Ethernet parsing engine configuration 1 */
	uint32_t parse_cfg;
	/* [0x4] Protocol index action table address */
	uint32_t act_table_addr;
	/* [0x8] Protocol index action table data */
	uint32_t act_table_data_1;
	/* [0xc] Protocol index action table data */
	uint32_t act_table_data_2;
	/* [0x10] Protocol index action table data */
	uint32_t act_table_data_3;
	/* [0x14] Protocol index action table data */
	uint32_t act_table_data_4;
	/*
	 * [0x18] Protocol index action table data
	 * Table data
	 * [0] - End of parsing
	 * [3:1] - Next stage
	 * [9:4] - Next branch ID set
	 * [15:10] - Next branch ID value
	 * [23:16] - Control bit set
	 * [31:24] - Control bit value
	 * Reset: 0x1         Access: RW
	 */
	uint32_t act_table_data_5;
	/* [0x1c] Protocol index action table data */
	uint32_t act_table_data_6;
	/*
	 * [0x20] Input result vector, default values for parser input
	 * Default data for parser result input vector
	 * Reset: 0x8000080   Access: RW
	 */
	uint32_t res_def;
	/* [0x24] Result input vector selection */
	uint32_t res_in;
	/* [0x28] */
	uint32_t rsrvd_0[6];
};

/*
 * Ethernet Parsing Engine, Result pointers
 */
struct al_ec_epe_res {
	/* [0x0] Parser result vector pointer */
	uint32_t p1;
	/* [0x4] Parser result vector pointer */
	uint32_t p2;
	/* [0x8] Parser result vector pointer */
	uint32_t p3;
	/* [0xc] Parser result vector pointer */
	uint32_t p4;
	/* [0x10] Parser result vector pointer */
	uint32_t p5;
	/* [0x14] Parser result vector pointer */
	uint32_t p6;
	/* [0x18] Parser result vector pointer */
	uint32_t p7;
	/* [0x1c] Parser result vector pointer */
	uint32_t p8;
	/* [0x20] Parser result vector pointer */
	uint32_t p9;
	/* [0x24] Parser result vector pointer */
	uint32_t p10;
	/* [0x28] Parser result vector pointer */
	uint32_t p11;
	/* [0x2c] Parser result vector pointer */
	uint32_t p12;
	/* [0x30] Parser result vector pointer */
	uint32_t p13;
	/* [0x34] Parser result vector pointer */
	uint32_t p14;
	/* [0x38] Parser result vector pointer */
	uint32_t p15;
	/* [0x3c] Parser result vector pointer */
	uint32_t p16;
	/* [0x40] Parser result vector pointer */
	uint32_t p17;
	/* [0x44] Parser result vector pointer */
	uint32_t p18;
	/* [0x48] Parser result vector pointer */
	uint32_t p19;
	/* [0x4c] Parser result vector pointer */
	uint32_t p20;
	/* [0x50] Parser result vector pointer */
	uint32_t p21;
	/* [0x54] Parser result vector pointer */
	uint32_t p22;
	/* [0x58] */
	uint32_t rsrvd_0[10];
};

/*
 * Ethernet parsing engine, header length configuration.
 * 4 tables, 2  for each parser,
 * 0-15 - Registers for tables of parser 1
 * 16-31 - Registers for tables of parser 2
 */
struct al_ec_epe_h {
	/*
	 * [0x0] Header length, support for header length table for up to 16 options based on packet
	 * data
	 */
	uint32_t hdr_len;
};

/*
 * Ethernet Parsing Engine protocol comparator configuration
 */
struct al_ec_epe_p {
	/* [0x0] Data  for comparison */
	uint32_t comp_data;
	/* [0x4] Mask for comparison */
	uint32_t comp_mask;
	/* [0x8] Compare control */
	uint32_t comp_ctrl;
	/* [0xc] */
	uint32_t rsrvd_0[4];
};

/*
 * Ethernet Parsing Engine action register per protocol index
 */
struct al_ec_epe_a {
	/* [0x0] Protocol index action register */
	uint32_t prot_act;
};

/*
 * Rx Forwarding engine general configuration
 */
struct al_ec_rfw {
	/* [0x0] Tuple (4/2) Hash configuration */
	uint32_t thash_cfg_1;
	/*
	 * [0x4] Tuple (4/2) Hash configuration
	 * Init value
	 * Reset: 0xffffffff  Access: RW
	 */
	uint32_t thash_cfg_2;
	/* [0x8] MAC Hash configuration */
	uint32_t mhash_cfg_1;
	/*
	 * [0xc] MAC Hash configuration
	 * Init value
	 * Reset: 0xffffffff  Access: RW
	 */
	uint32_t mhash_cfg_2;
	/* [0x10] MAC Hash configuration */
	uint32_t hdr_split;
	/*
	 * [0x14] Masking the errors described in  register rxf_drop for generating error indication
	 * in the received descriptor
	 */
	uint32_t meta_err;
	/* [0x18] Configuration for generating the MetaData for the Rx descriptor */
	uint32_t meta;
	/* [0x1c] Configuration for generating the MetaData for the Rx descriptor */
	uint32_t filter;
	/* [0x20] 4 tupple hash table address */
	uint32_t thash_table_addr;
	/* [0x24] 4 tupple hash table data */
	uint32_t thash_table_data;
	/* [0x28] MAC hash table address */
	uint32_t mhash_table_addr;
	/* [0x2c] MAC hash table data */
	uint32_t mhash_table_data;
	/* [0x30] VLAN table address */
	uint32_t vid_table_addr;
	/* [0x34] VLAN table data */
	uint32_t vid_table_data;
	/* [0x38] VLAN p-bits table address */
	uint32_t pbits_table_addr;
	/* [0x3c] VLAN p-bits table data */
	uint32_t pbits_table_data;
	/* [0x40] DSCP table address */
	uint32_t dscp_table_addr;
	/* [0x44] DSCP table data */
	uint32_t dscp_table_data;
	/* [0x48] TC table address */
	uint32_t tc_table_addr;
	/* [0x4c] TC table data */
	uint32_t tc_table_data;
	/* [0x50] Control table address */
	uint32_t ctrl_table_addr;
	/* [0x54] Control table data */
	uint32_t ctrl_table_data;
	/* [0x58] Forwarding output configuration */
	uint32_t out_cfg;
	/*
	 * [0x5c] Flow steering mechanism,
	 * Table address
	 */
	uint32_t fsm_table_addr;
	/*
	 * [0x60] Flow steering mechanism,
	 * Table data
	 */
	uint32_t fsm_table_data;
	/* [0x64] Selection for control table address */
	uint32_t ctrl_sel;
	/* [0x68] Default VLAN data, used for untagged packets */
	uint32_t default_vlan;
	/* [0x6c] Default HASH output values */
	uint32_t default_hash;
	/*
	 * [0x70] Default override values, if a packet was filtered but an override condition
	 * occurred.
	 */
	uint32_t default_or;
	/*
	 * [0x74] Latched information when a drop condition occurred.
	 * Latched information
	 * Reset: 0x0         Access: RO
	 */
	uint32_t drop_latch;
	/* [0x78] Check sum calculation configuration */
	uint32_t checksum;
	/* [0x7c] LRO offload engine configuration register */
	uint32_t lro_cfg_1;
	/* [0x80] LRO offload engine Check rules configurations for IPv4 header */
	uint32_t lro_check_ipv4;
	/* [0x84] LRO offload engine IPv4 values configuration */
	uint32_t lro_ipv4;
	/* [0x88] LRO offload engine Check rules configurations for IPv6 header */
	uint32_t lro_check_ipv6;
	/* [0x8c] LRO offload engine IPv6 values configuration */
	uint32_t lro_ipv6;
	/* [0x90] LRO offload engine Check rules configurations for TCP header */
	uint32_t lro_check_tcp;
	/* [0x94] LRO offload engine IPv6 values configuration */
	uint32_t lro_tcp;
	/* [0x98] LRO offload engine Check rules configurations for UDP header */
	uint32_t lro_check_udp;
	/* [0x9c] LRO offload engine Check rules configurations for UDP header. */
	uint32_t lro_check_l2;
	/* [0xa0] LRO offload engine Check rules configurations for UDP header */
	uint32_t lro_check_gen;
	/* [0xa4] Rules for storing packet information into the cache line */
	uint32_t lro_store;
	/* [0xa8] VLAN table default */
	uint32_t vid_table_def;
	/* [0xac] Control table default */
	uint32_t ctrl_table_def;
	/* [0xb0] Additional configuration 0 */
	uint32_t cfg_a_0;
	/* [0xb4] Tuple (4/2) Hash configuration (extended for RoCE and FcoE) */
	uint32_t thash_cfg_3;
	/* [0xb8] Tuple (4/2) Hash configuration, mask for the input data for outer IPv6 header */
	uint32_t thash_mask_outer_ipv6;
	/* [0xbc] Tuple (4/2) Hash configuration, mask for the input data for outer header */
	uint32_t thash_mask_outer;
	/* [0xc0] Tuple (4/2) Hash configuration, mask for the input data for inner IPv6 header */
	uint32_t thash_mask_inner_ipv6;
	/* [0xc4] Tuple (4/2) Hash configuration, mask for the input data for inner header */
	uint32_t thash_mask_inner;
	/* [0xc8] additional rx checksum configuration */
	uint32_t rx_checksum;
	/* [0xcc] L3 TLEN field validation */
	uint32_t l3_tlen_err;
	/* [0xd0] L3 TLEN field validation  table - register 1 */
	uint32_t l3_tlen_err_table_1;
	/* [0xd4] Tunnel L3 TLEN field validation  table - register 1 */
	uint32_t tunnel_l3_tlen_err_table_1;
	/* [0xd8] */
	uint32_t rsrvd_0[2];
};

/*
 * Rx Forwarding engine, per UDMA configuration
 */
struct al_ec_rfw_udma {
	/* [0x0] Per UDMA default configuration */
	uint32_t def_cfg;
};

/*
 * Rx Forwarding engine, HASH key configuration
 */
struct al_ec_rfw_hash {
	/*
	 * [0x0] key configuration (320 bits)
	 * HASH key value
	 * Reset: 0x0         Access: RW
	 */
	uint32_t key;
};

/*
 * Rx Forwarding engine, priority mapping configuration
 */
struct al_ec_rfw_priority {
	/* [0x0] Priority to queue mapping configuration */
	uint32_t queue;
};

/*
 * Rx Forwarding engine, priority mapping configuration
 */
struct al_ec_rfw_default {
	/* [0x0] Default forwarding configuration options */
	uint32_t opt_1;
};

/*
 * Forwarding engine, MAC address compare registers used in both Rx and Tx forwarding.
 */
struct al_ec_fwd_mac {
	/*
	 * [0x0] MAC address data [31:0]
	 * Reset: 0x0         Access: RW
	 */
	uint32_t data_l;
	/* [0x4] MAC address data [15:0] */
	uint32_t data_h;
	/*
	 * [0x8] MAC address mask [31:0]
	 * Reset: 0x0         Access: RW
	 */
	uint32_t mask_l;
	/* [0xc] MAC address mask [15:0] */
	uint32_t mask_h;
	/* [0x10] MAC compare control */
	uint32_t ctrl;
};

/*
 * Rx Multi-stream write general configuration
 */
struct al_ec_msw {
	/* [0x0] Configuration for unicast packets */
	uint32_t uc;
	/* [0x4] Configuration for multicast packets */
	uint32_t mc;
	/* [0x8] Configuration for broadcast packets */
	uint32_t bc;
	/* [0xc] */
	uint32_t rsrvd_0[3];
};

/*
 * TSO and stream interface configuration
 */
struct al_ec_tso {
	/* [0x0] Input configuration */
	uint32_t in_cfg;
	/* [0x4] MetaData default cache table address */
	uint32_t cache_table_addr;
	/*
	 * [0x8] MetaData default cache table data
	 * Reset: 0x0         Access: RW
	 */
	uint32_t cache_table_data_1;
	/*
	 * [0xc] MetaData default cache table data
	 * Reset: 0x0         Access: RW
	 */
	uint32_t cache_table_data_2;
	/*
	 * [0x10] MetaData default cache table data
	 * Reset: 0x0         Access: RW
	 */
	uint32_t cache_table_data_3;
	/*
	 * [0x14] MetaData default cache table data
	 * Reset: 0x0         Access: RW
	 */
	uint32_t cache_table_data_4;
	/* [0x18] TCP control bit operation for first segment */
	uint32_t ctrl_first;
	/* [0x1c] TCP control bit operation for middle segments */
	uint32_t ctrl_middle;
	/* [0x20] TCP control bit operation for last segment */
	uint32_t ctrl_last;
	/* [0x24] Additional TSO configurations */
	uint32_t cfg_add_0;
	/* [0x28] TSO configuration for tunnelled packets */
	uint32_t cfg_tunnel;
	/* [0x2c] */
	uint32_t arb_config;
	/* [0x30] */
	uint32_t arb_cred_level;
	/* [0x34] */
	uint32_t arb_cred_grant;
	/* [0x38] */
	uint32_t arb_sop_cost;
	/* [0x3c] */
	uint32_t arb_eop_cost;
	/* [0x40] */
	uint32_t arb_data_cost;
	/* [0x44] */
	uint32_t rsrvd_0[7];
};

/*
 * TSO selection for MSS value
 */
struct al_ec_tso_sel {
	/* [0x0] MSS value */
	uint32_t mss;
};

/*
 * Tx parsing engine configuration
 */
struct al_ec_tpe {
	/* [0x0] Parsing configuration */
	uint32_t parse;
	/* [0x4] */
	uint32_t rsrvd_0[15];
};

/*
 * Tx packet modification engine configuration
 */
struct al_ec_tpm_udma {
	/* [0x0] Default VLAN data */
	uint32_t vlan_data;
	/*
	 * [0x4] UDMA MAC SA information for spoofing
	 * MAC source address data [31:0]
	 * Reset: 0x0         Access: RW
	 */
	uint32_t mac_sa_1;
	/* [0x8] UDMA MAC SA information for spoofing */
	uint32_t mac_sa_2;
};

/*
 * Tx packet modification engine configuration
 */
struct al_ec_tpm_sel {
	/* [0x0] Ethertype values for VLAN modification */
	uint32_t etype;
};

/*
 * Tx Forwarding configuration
 */
struct al_ec_tfw {
	/* [0x0] Tx FIFO Wr configuration */
	uint32_t tx_wr_fifo;
	/* [0x4] VLAN table address */
	uint32_t tx_vid_table_addr;
	/* [0x8] VLAN table data */
	uint32_t tx_vid_table_data;
	/* [0xc] Tx FIFO Rd configuration */
	uint32_t tx_rd_fifo;
	/* [0x10] Tx FIFO Rd configuration, checksum insertion */
	uint32_t tx_checksum;
	/* [0x14] Tx forwarding general configuration register */
	uint32_t tx_gen;
	/* [0x18] Tx spoofing configuration */
	uint32_t tx_spf;
	/* [0x1c] TX data FIFO status */
	uint32_t data_fifo;
	/* [0x20] Tx control FIFO status */
	uint32_t ctrl_fifo;
	/* [0x24] Tx header FIFO status */
	uint32_t hdr_fifo;
	/* [0x28] tfw_out */
	uint32_t out;
	/* [0x2c] */
	uint32_t rsrvd_0[13];
};

/*
 * Tx forwarding engine
 * UDMA output bitmap configuration per UDMA
 */
struct al_ec_tfw_udma {
	/* [0x0] Default UDMA output bitmap for unicast packet */
	uint32_t uc_udma;
	/* [0x4] Default UDMA output bitmap for multicast packet */
	uint32_t mc_udma;
	/* [0x8] Default UDMA output bitmap for broadcast packet */
	uint32_t bc_udma;
	/* [0xc] Tx spoofing configuration */
	uint32_t spf_cmd;
	/* [0x10] Forwarding decision control */
	uint32_t fwd_dec;
	/* [0x14] */
	uint32_t rsrvd_0;
};

/*
 * Tx MAC interface
 */
struct al_ec_tmi {
	/* [0x0] Forward packets back to the Rx data path for local switching */
	uint32_t tx_cfg;
	/* [0x4] */
	uint32_t rsrvd_0[3];
};

/*
 * Ethernet flow control registers
 */
struct al_ec_efc {
	/* [0x0] Mask of pause_on  [7:0] for the Ethernet controller Tx interface */
	uint32_t ec_pause;
	/* [0x4] Mask of Ethernet controller Almost Full indication for generating XOFF [7:0] */
	uint32_t ec_xoff;
	/* [0x8] Mask for generating XON indication pulse */
	uint32_t xon;
	/* [0xc] Mask for generating GPIO output XOFF indication from XOFF[0] */
	uint32_t gpio;
	/*
	 * [0x10] Rx FIFO threshold for generating the Almost Full indication (used for generating
	 * XOFF/XON signals)
	 */
	uint32_t rx_fifo_af;
	/* [0x14] Rx FIFO threshold for generating the Almost Full indication with hysteresis */
	uint32_t rx_fifo_hyst;
	/* [0x18] Rx FIFO threshold for generating the Almost Full indication with hysteresis */
	uint32_t stat;
	/*
	 * [0x1c] XOFF timer for the 1G MAC
	 * Sets the interval (in SB_CLK units) between XOFF transmissions (needs to be aligned to
	 * the MAC configuration).
	 * Timer value
	 * Reset: 0x3e8       Access: RW
	 */
	uint32_t xoff_timer_1g;
	/* [0x20] PFC force flow control generation */
	uint32_t ec_pfc;
	/* [0x24] */
	uint32_t rsrvd_0[3];
};

/*
 * Ethernet flow control per UDMA configuration registers
 */
struct al_ec_fc_udma {
	/* [0x0] Mask of "pause_on"  [0] for all queues */
	uint32_t q_pause_0;
	/* [0x4] Mask of "pause_on"  [1] for all queues */
	uint32_t q_pause_1;
	/* [0x8] Mask of "pause_on"  [2] for all queues */
	uint32_t q_pause_2;
	/* [0xc] Mask of "pause_on"  [3] for all queues */
	uint32_t q_pause_3;
	/* [0x10] Mask of "pause_on"  [4] for all queues */
	uint32_t q_pause_4;
	/* [0x14] Mask of "pause_on"  [5] for all queues */
	uint32_t q_pause_5;
	/* [0x18] Mask of "pause_on"  [6] for all queues */
	uint32_t q_pause_6;
	/* [0x1c] Mask of "pause_on"  [7] for all queues */
	uint32_t q_pause_7;
	/* [0x20] Mask of external GPIO input pause [0] for all queues */
	uint32_t q_gpio_0;
	/* [0x24] Mask of external GPIO input pause [1] for all queues */
	uint32_t q_gpio_1;
	/* [0x28] Mask of external GPIO input pause [2] for all queues */
	uint32_t q_gpio_2;
	/* [0x2c] Mask of external GPIO input pause [3] for all queues */
	uint32_t q_gpio_3;
	/* [0x30] Mask of external GPIO input [4] for all queues */
	uint32_t q_gpio_4;
	/* [0x34] Mask of external GPIO input [5] for all queues */
	uint32_t q_gpio_5;
	/* [0x38] Mask of external GPIO input [6] for all queues */
	uint32_t q_gpio_6;
	/* [0x3c] Mask of external GPIO input [7] for all queues */
	uint32_t q_gpio_7;
	/* [0x40] Mask of "pause_on"  [7:0] for the UDMA stream interface */
	uint32_t s_pause;
	/* [0x44] Mask of Rx Almost Full indication for generating XOFF [0] */
	uint32_t q_xoff_0;
	/* [0x48] Mask of Rx Almost Full indication for generating XOFF [1] */
	uint32_t q_xoff_1;
	/* [0x4c] Mask of Rx Almost Full indication for generating XOFF [2] */
	uint32_t q_xoff_2;
	/* [0x50] Mask of Rx Almost Full indication for generating XOFF [3] */
	uint32_t q_xoff_3;
	/* [0x54] Mask of Rx Almost Full indication for generating XOFF [4] */
	uint32_t q_xoff_4;
	/* [0x58] Mask of Rx Almost Full indication for generating XOFF [5] */
	uint32_t q_xoff_5;
	/* [0x5c] Mask of Rx Almost Full indication for generating XOFF [6] */
	uint32_t q_xoff_6;
	/* [0x60] Mask of Rx Almost Full indication for generating XOFF [7] */
	uint32_t q_xoff_7;
	/* [0x64] */
	uint32_t rsrvd_0[7];
};

/*
 * TPG RPA address gap
 */
struct al_ec_tpg_rpa_res {
	/* [0x0] NOT used */
	uint32_t not_used;
	/* [0x4] */
	uint32_t rsrvd_0[63];
};

/*
 * EEE control and configuration
 */
struct al_ec_eee {
	/* [0x0] EEE configuration */
	uint32_t cfg_e;
	/*
	 * [0x4] Number of clocks to get into EEE mode.
	 * Threshold value
	 * Reset: 0x0         Access: RW
	 */
	uint32_t pre_cnt;
	/*
	 * [0x8] Number of clocks to stop MAC EEE mode after getting out of EEE mode.
	 * Threshold value
	 * Reset: 0x0         Access: RW
	 */
	uint32_t post_cnt;
	/*
	 * [0xc] Number of clocks to stop the Tx MAC interface after getting out of EEE mode.
	 * Threshold value
	 * Reset: 0x0         Access: RW
	 */
	uint32_t stop_cnt;
	/* [0x10] EEE status */
	uint32_t stat_eee;
	/* [0x14] */
	uint32_t rsrvd_0[59];
};

/*
 * Statistic counters
 */
struct al_ec_stat {
	/*
	 * [0x0] Rx Frequency adjust FIFO input packets
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t faf_in_rx_pkt;
	/*
	 * [0x4] Rx Frequency adjust FIFO input short error packets
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t faf_in_rx_short;
	/*
	 * [0x8] Rx Frequency adjust FIFO input long error packets
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t faf_in_rx_long;
	/*
	 * [0xc] Rx Frequency adjust FIFO output packets
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t faf_out_rx_pkt;
	/*
	 * [0x10] Rx Frequency adjust FIFO output short error packets
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t faf_out_rx_short;
	/*
	 * [0x14] Rx Frequency adjust FIFO output long error packets
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t faf_out_rx_long;
	/*
	 * [0x18] Rx Frequency adjust FIFO output drop packets
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t faf_out_drop;
	/*
	 * [0x1c] Number of packets written into the Rx FIFO (without FIFO error indication)
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t rxf_in_rx_pkt;
	/*
	 * [0x20] Number of error packets written into the Rx FIFO (with FIFO error indication, FIFO
	 * full indication during packet reception)
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t rxf_in_fifo_err;
	/*
	 * [0x24] Number of packets written into the loopback FIFO (without FIFO error indication)
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t lbf_in_rx_pkt;
	/*
	 * [0x28] Number of error packets written into the loopback FIFO (with FIFO error
	 * indication, FIFO full indication during packet reception)
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t lbf_in_fifo_err;
	/*
	 * [0x2c] Number of packets read from Rx FIFO 1
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t rxf_out_rx_1_pkt;
	/*
	 * [0x30] Number of packets read from Rx FIFO 2 (loopback FIFO)
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t rxf_out_rx_2_pkt;
	/*
	 * [0x34] Rx FIFO output drop packets from FIFO 1
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t rxf_out_drop_1_pkt;
	/*
	 * [0x38] Rx FIFO output drop packets from FIFO 2 (loopback)
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t rxf_out_drop_2_pkt;
	/*
	 * [0x3c] Rx Parser 1, input packet counter
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t rpe_1_in_rx_pkt;
	/*
	 * [0x40] Rx Parser 1, output packet counter
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t rpe_1_out_rx_pkt;
	/*
	 * [0x44] Rx Parser 2, input packet counter
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t rpe_2_in_rx_pkt;
	/*
	 * [0x48] Rx Parser 2, output packet counter
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t rpe_2_out_rx_pkt;
	/*
	 * [0x4c] Rx Parser 3 (MACsec), input packet counter
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t rpe_3_in_rx_pkt;
	/*
	 * [0x50] Rx Parser 3 (MACsec), output packet counter
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t rpe_3_out_rx_pkt;
	/*
	 * [0x54] Tx parser, input packet counter
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t tpe_in_tx_pkt;
	/*
	 * [0x58] Tx parser, output packet counter
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t tpe_out_tx_pkt;
	/*
	 * [0x5c] Tx packet modification, input packet counter
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t tpm_tx_pkt;
	/*
	 * [0x60] Tx forwarding input packet counter
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t tfw_in_tx_pkt;
	/*
	 * [0x64] Tx forwarding input packet counter
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t tfw_out_tx_pkt;
	/*
	 * [0x68] Rx forwarding input packet counter
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t rfw_in_rx_pkt;
	/*
	 * [0x6c] Rx Forwarding, packet with VLAN command drop indication
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t rfw_in_vlan_drop;
	/*
	 * [0x70] Rx Forwarding, packets with parse drop indication
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t rfw_in_parse_drop;
	/*
	 * [0x74] Rx Forwarding, multicast packets
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t rfw_in_mc;
	/*
	 * [0x78] Rx Forwarding, broadcast packets
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t rfw_in_bc;
	/*
	 * [0x7c] Rx Forwarding, tagged packets
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t rfw_in_vlan_exist;
	/*
	 * [0x80] Rx Forwarding, untagged packets
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t rfw_in_vlan_nexist;
	/*
	 * [0x84] Rx Forwarding, packets with MAC address drop indication (from the MAC address
	 * table)
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t rfw_in_mac_drop;
	/*
	 * [0x88] Rx Forwarding, packets with undetected MAC address
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t rfw_in_mac_ndet_drop;
	/*
	 * [0x8c] Rx Forwarding, packets with drop indication from the control table
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t rfw_in_ctrl_drop;
	/*
	 * [0x90] Rx Forwarding, packets with L3_protocol_index drop indication
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t rfw_in_prot_i_drop;
	/*
	 * [0x94] EEE, number of times the system went into EEE state
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t eee_in;
	/* [0x98] */
	uint32_t rsrvd_0[90];
};

/*
 * Statistic counters per UDMA
 */
struct al_ec_stat_udma {
	/*
	 * [0x0] Rx forwarding output packet counter
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t rfw_out_rx_pkt;
	/*
	 * [0x4] Rx forwarding output drop packet counter
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t rfw_out_drop;
	/*
	 * [0x8] Multi-stream write, number of Rx packets
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t msw_in_rx_pkt;
	/*
	 * [0xc] Multi-stream write, number of dropped packets at SOP, Q full indication
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t msw_drop_q_full;
	/*
	 * [0x10] Multi-stream write, number of dropped packets at SOP
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t msw_drop_sop;
	/*
	 * [0x14] Multi-stream write, number of dropped packets at EOP, EOP was written with error
	 * indication (not all packet data was written)
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t msw_drop_eop;
	/*
	 * [0x18] Multi-stream write, number of packets written to the stream FIFO with EOP and
	 * without packet loss
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t msw_wr_eop;
	/*
	 * [0x1c] Multi-stream write, number of packets read from the FIFO into the stream
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t msw_out_rx_pkt;
	/*
	 * [0x20] Number of transmitted packets without TSO enabled
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t tso_no_tso_pkt;
	/*
	 * [0x24] Number of transmitted packets with TSO enabled
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t tso_tso_pkt;
	/*
	 * [0x28] Number of TSO segments that were generated
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t tso_seg_pkt;
	/*
	 * [0x2c] Number of TSO segments that required padding
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t tso_pad_pkt;
	/*
	 * [0x30] Tx Packet modification, MAC SA spoof error
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t tpm_tx_spoof;
	/*
	 * [0x34] Tx MAC interface, input packet counter
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t tmi_in_tx_pkt;
	/*
	 * [0x38] Tx MAC interface, number of packets forwarded to the MAC
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t tmi_out_to_mac;
	/*
	 * [0x3c] Tx MAC interface, number of packets forwarded to the Rx data path
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t tmi_out_to_rx;
	/*
	 * [0x40] Tx MAC interface, number of transmitted bytes
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t tx_q0_bytes;
	/*
	 * [0x44] Tx MAC interface, number of transmitted bytes
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t tx_q1_bytes;
	/*
	 * [0x48] Tx MAC interface, number of transmitted bytes
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t tx_q2_bytes;
	/*
	 * [0x4c] Tx MAC interface, number of transmitted bytes
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t tx_q3_bytes;
	/*
	 * [0x50] Tx MAC interface, number of transmitted packets
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t tx_q0_pkts;
	/*
	 * [0x54] Tx MAC interface, number of transmitted packets
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t tx_q1_pkts;
	/*
	 * [0x58] Tx MAC interface, number of transmitted packets
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t tx_q2_pkts;
	/*
	 * [0x5c] Tx MAC interface, number of transmitted packets
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t tx_q3_pkts;
	/*
	 * [0x60] Tx MAC interface, number of transmitted bytes
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t tx_q4_bytes;
	/*
	 * [0x64] Tx MAC interface, number of transmitted bytes
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t tx_q5_bytes;
	/*
	 * [0x68] Tx MAC interface, number of transmitted bytes
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t tx_q6_bytes;
	/*
	 * [0x6c] Tx MAC interface, number of transmitted bytes
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t tx_q7_bytes;
	/*
	 * [0x70] Tx MAC interface, number of transmitted bytes
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t tx_q8_bytes;
	/*
	 * [0x74] Tx MAC interface, number of transmitted bytes
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t tx_q9_bytes;
	/*
	 * [0x78] Tx MAC interface, number of transmitted bytes
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t tx_q10_bytes;
	/*
	 * [0x7c] Tx MAC interface, number of transmitted bytes
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t tx_q11_bytes;
	/*
	 * [0x80] Tx MAC interface, number of transmitted bytes
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t tx_q12_bytes;
	/*
	 * [0x84] Tx MAC interface, number of transmitted bytes
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t tx_q13_bytes;
	/*
	 * [0x88] Tx MAC interface, number of transmitted bytes
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t tx_q14_bytes;
	/*
	 * [0x8c] Tx MAC interface, number of transmitted bytes
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t tx_q15_bytes;
	/*
	 * [0x90] Tx MAC interface, number of transmitted packets
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t tx_q4_pkts;
	/*
	 * [0x94] Tx MAC interface, number of transmitted packets
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t tx_q5_pkts;
	/*
	 * [0x98] Tx MAC interface, number of transmitted packets
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t tx_q6_pkts;
	/*
	 * [0x9c] Tx MAC interface, number of transmitted packets
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t tx_q7_pkts;
	/*
	 * [0xa0] Tx MAC interface, number of transmitted packets
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t tx_q8_pkts;
	/*
	 * [0xa4] Tx MAC interface, number of transmitted packets
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t tx_q9_pkts;
	/*
	 * [0xa8] Tx MAC interface, number of transmitted packets
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t tx_q10_pkts;
	/*
	 * [0xac] Tx MAC interface, number of transmitted packets
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t tx_q11_pkts;
	/*
	 * [0xb0] Tx MAC interface, number of transmitted packets
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t tx_q12_pkts;
	/*
	 * [0xb4] Tx MAC interface, number of transmitted packets
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t tx_q13_pkts;
	/*
	 * [0xb8] Tx MAC interface, number of transmitted packets
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t tx_q14_pkts;
	/*
	 * [0xbc] Tx MAC interface, number of transmitted packets
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t tx_q15_pkts;
	/* [0xc0] */
	uint32_t rsrvd_0[16];
};

/*
 * MACsec parsing engine general configuration
 */
struct al_ec_msp {
	/* [0x0] Ethernet parsing engine configuration 1 */
	uint32_t p_parse_cfg;
	/* [0x4] Protocol index action table address */
	uint32_t p_act_table_addr;
	/* [0x8] Protocol index action table data */
	uint32_t p_act_table_data_1;
	/* [0xc] Protocol index action table data */
	uint32_t p_act_table_data_2;
	/* [0x10] Protocol index action table data */
	uint32_t p_act_table_data_3;
	/* [0x14] Protocol index action table data */
	uint32_t p_act_table_data_4;
	/*
	 * [0x18] Protocol index action table data
	 * Table data [0] - End of parsing [3:1] - Next stage
	 * [9:4] - Next branch ID set
	 * [15:10] - Next branch ID value [23:16] - Control bit set [31:24] - control bit value
	 * Reset: 0x1         Access: RW
	 */
	uint32_t p_act_table_data_5;
	/* [0x1c] Protocol index action table data */
	uint32_t p_act_table_data_6;
	/*
	 * [0x20] Input result vector, default values for parser input
	 * Default data for parser result input vector
	 * Reset: 0x8000000   Access: RW
	 */
	uint32_t p_res_def;
	/* [0x24] Result input vector selection */
	uint32_t p_res_in;
	/* [0x28] */
	uint32_t rsrvd_0[6];
};

/*
 * MACsec parsing engine, header length configuration. 4 tables, 2  for each parser
 * 0 -15 - Registers for tables of parser 1
 * 16-31 - Registers for tables of parser 2
 */
struct al_ec_msp_p {
	/*
	 * [0x0] Header length, support for header length table for up to 16 options based on packet
	 * data
	 */
	uint32_t h_hdr_len;
};

/*
 * MACsec Parsing Engine protocol comparator  configuration
 */
struct al_ec_msp_c {
	/* [0x0] Data for comparison */
	uint32_t p_comp_data;
	/* [0x4] Mask for comparison */
	uint32_t p_comp_mask;
	/* [0x8] Compare control */
	uint32_t p_comp_ctrl;
	/* [0xc] */
	uint32_t rsrvd_0[4];
};

/*
 * CRC Engine (CRCE) configuration
 */
struct al_ec_crce {
	/* [0x0] */
	uint32_t rsrvd_0[8];
	/* [0x20] General CRC engine configuration */
	uint32_t gen_cfg;
	/* [0x24] */
	uint32_t rsrvd_1[7];
};

/*
 * Wake-on-LAN (WoL) configuration
 */
struct al_ec_wol {
	/*
	 * [0x0] WoL enable configuration,
	 * Packet forwarding and interrupt generation configuration
	 */
	uint32_t wol_en;
	/*
	 * [0x4] Password for magic_password packet detection - bits 31:0
	 * Reset: 0x0         Access: RW
	 */
	uint32_t magic_pswd_l;
	/* [0x8] Password for magic+password packet detection -  47:32 */
	uint32_t magic_pswd_h;
	/*
	 * [0xc] Configured L3 Destination IP address for WoL IPv6 packet detection - bits 31:0
	 * Reset: 0x0         Access: RW
	 */
	uint32_t ipv6_dip_word0;
	/*
	 * [0x10] Configured L3 Destination IP address for WoL IPv6 packet detection - bits 31:0
	 * Reset: 0x0         Access: RW
	 */
	uint32_t ipv6_dip_word1;
	/*
	 * [0x14] Configured L3 Destination IP address for WoL IPv6 packet detection - bits 95:64
	 * Reset: 0x0         Access: RW
	 */
	uint32_t ipv6_dip_word2;
	/*
	 * [0x18] Configured L3 Destination IP address for WoL IPv6 packet detection - bits 127:96
	 * Reset: 0x0         Access: RW
	 */
	uint32_t ipv6_dip_word3;
	/*
	 * [0x1c] Configured L3 Destination IP address for WoL IPv4 packet detection - bits 31:0
	 * Reset: 0x0         Access: RW
	 */
	uint32_t ipv4_dip;
	/* [0x20] Configured EtherType for WoL EtherType_da/EtherType_bc packet detection */
	uint32_t ethertype;
	/* [0x24] */
	uint32_t rsrvd_0[7];
};

/*
 * PTH configuration
 */
struct al_ec_pth {
	/*
	 * [0x0] System time counter (Time of Day)
	 * Seconds from 1/1/1970, 00:00 TAI, or from 31/12/1969 23:59:51.999918 UTC
	 * Reset: 0x0         Access: RO
	 */
	uint32_t system_time_seconds;
	/*
	 * [0x4] System time subseconds in a second (MSBs).
	 * Resolution of LSBs part (next register) is femtoseconds.
	 * Resolution of MSBs part (this register) is 2^18 femtoseconds, which is roughly 0.262
	 * nanoseconds
	 *
	 * Read protocol: To get system_time value (seconds + subseconds), follow this protocol:
	 * 1. Read system_time_subseconds_msb.
	 * 2. Read system_time_seconds.
	 *
	 * NOTE1:  system_time_subseconds_lsb should not be read, since it hold values that are less
	 * than a single CPU cycle (0.26ns)
	 * NOTE2: Read value will be system_time + read_compensation, to compensate for APB read
	 * transaction delay
	 * Reset: 0x0         Access: RO
	 */
	uint32_t system_time_subseconds_msb;
	/*
	 * [0x8] System time subseconds in a second (LSBs).
	 * Resolution is femtoseconds.
	 *
	 * Read protocol:  This value should not be read by software, since it holds values that are
	 * less than one CPU cycle (0.26ns)
	 */
	uint32_t system_time_subseconds_lsb;
	/*
	 * [0xc] Clock period in femtoseconds (MSB). Default is according to 375 MHz clock
	 * frequency.
	 *
	 * Write protocol: Both clock_period_lsb, and clock_period_msb, are updated upon write to
	 * clock_period_msb
	 * Reset: 0x0         Access: RW
	 */
	uint32_t clock_period_msb;
	/*
	 * [0x10] Clock period in femtoseconds (LSB). Default is according to 375 MHz clock
	 * frequency
	 *
	 * Write protocol: Both clock_period_lsb, and clock_period_msb, are updated upon write to
	 * clock_period_msb
	 */
	uint32_t clock_period_lsb;
	/*
	 * [0x14] Control register for internal updates to the system time counter.
	 * In this context, "internal" means a software-initiated update, w/o any trigger from GPIO
	 * or from other Ethernet units.
	 *
	 * As can be seen by the possible configurations below, there are two ways to trigger an
	 * update to the system time counter, either by an APB write, or by an internally generated
	 * trigger (which is always ingress_trigger[0])
	 */
	uint32_t int_update_ctrl;
	/*
	 * [0x18] Value to update system_time_seconds with.
	 * Time and method of update are determined by int_update_ctrl register.
	 *
	 * Write protocol: Regular write access. If int_update_ctrl[update_trig] is set to 1'b1,
	 * system time counter's update (both seconds & subseconds) will occur when writing this
	 * register.
	 * Reset: 0x0         Access: RW
	 */
	uint32_t int_update_seconds;
	/*
	 * [0x1c] Value to update system_time_subseconds_msb with.
	 * Time and method of update are determined by int_update_ctrl register
	 *
	 * Write protocol: Regular write access. If int_update_ctrl[update_trig] is set to 1'b1,
	 * system time counter's update (both seconds & subseconds) will occur when writing the
	 * int_update_seconds register.
	 * Reset: 0x0         Access: RW
	 */
	uint32_t int_update_subseconds_msb;
	/*
	 * [0x20] Value to update system_time_subseconds_lsb with.
	 * Time and method of update are determined by int_update_ctrl register
	 *
	 * Write protocol: Regular write access. If int_update_ctrl[update_trig] is set to 1'b1,
	 * system time counter's update (both seconds & subseconds) will occur when writing the
	 * int_update_seconds register.
	 */
	uint32_t int_update_subseconds_lsb;
	/*
	 * [0x24] Control register for external updates to the system time counter.
	 * In this context, "external" means a non-SW initiated updates, initiator can be either
	 * GPIO trigger, or trigger from other eth units.
	 *
	 * There are 5 external ingress triggers, and thus all fields below are 5-bits wide
	 */
	uint32_t ext_update_ctrl;
	/*
	 * [0x28] Value to update system_time_seconds with.
	 * Time and method of update are determined by ext_update_ctrl register.
	 *
	 * Write protocol: regular write access.
	 * Reset: 0x0         Access: RW
	 */
	uint32_t ext_update_seconds;
	/*
	 * [0x2c] Value to update system_time_subseconds_msb with.
	 * Time and method of update are determined by ext_update_ctrl register
	 *
	 * Write protocol: regular write access.
	 * Reset: 0x0         Access: RW
	 */
	uint32_t ext_update_subseconds_msb;
	/*
	 * [0x30] Value to update system_time_subseconds_lsb with.
	 * Time and method of update are determined by ext_update_ctrl register
	 *
	 * Write protocol: regular write access.
	 */
	uint32_t ext_update_subseconds_lsb;
	/*
	 * [0x34] This value represents the APB transaction delay from the PTH to the CPU (in fs).
	 * This field is added to the system_time_subseconds_msb field, when SW reads the current
	 * time, to compensate for the APB access time.
	 *
	 * Write protocol: To assure atomic writes, SW should first write
	 * read_compensation_subseconds_lsb, and then read_compensation_subseconds_msb
	 * Reset: 0x0         Access: RW
	 */
	uint32_t read_compensation_subseconds_msb;
	/*
	 * [0x38] This value represents the APB transaction delay from PTH to the CPU (in fs). This
	 * field is added to the system_time_subseconds_lsb field, when SW reads the current time,
	 * to compensate for the APB access time.
	 *
	 * Write protocol: To assure atomic writes, SW should first write
	 * read_compensation_subseconds_lsb, and then read_compensation_subseconds_msb
	 */
	uint32_t read_compensation_subseconds_lsb;
	/*
	 * [0x3c] This value is used for two purposes:
	 * 1. internal update through APB write: In this case, this value represents the APB
	 * transaction delay from the CPU to PTH (in fs). This field is added to the
	 * int_update_subseconds_msb field, when SW sets the current time, to compensate for the APB
	 * access time.
	 * 2. internal update through firing of internal ingress trigger: In this case, this value
	 * represents the number of cycles it takes to detect an ingress trigger.  It is added to
	 * the int_update_subseconds_msb field before updating the system_time counter.
	 *
	 * Write protocol: To assure atomic writes, SW should first write
	 * int_write_compensation_subseconds_lsb, and then int_write_compensation_subseconds_msb
	 * Reset: 0x0         Access: RW
	 */
	uint32_t int_write_compensation_subseconds_msb;
	/*
	 * [0x40] This value is used for two purposes:
	 * 1. internal update through APB write: in this case, this value represents the APB
	 * transaction delay from the CPU to PTH (in fs). This field is added to the
	 * int_update_subseconds_lsb field, when SW sets the current time, to compensate for the APB
	 * access time.
	 * 2. internal update through firing of internal ingress trigger: in this case, this value
	 * represents the number of cycles it takes to detect an ingress trigger. It is added to the
	 * int_update_subseconds_lsb field before updating the system_time counter.
	 *
	 * Write protocol: To assure atomic writes, SW should first write
	 * int_write_compensation_subseconds_lsb, and then int_write_compensation_subseconds_msb
	 */
	uint32_t int_write_compensation_subseconds_lsb;
	/*
	 * [0x44] This value represents the number of cycles it for a trigger to propagate from GPIO
	 * / other eth unit [*] to PTH.  It is added to the ext_update_subseconds_msb field before
	 * updating the system_time counter.
	 *
	 * [*] dependent on currently enabled external ingress triggers
	 *
	 * Write protocol: To assure atomic writes, SW should first write
	 * ext_write_compensation_subseconds_lsb, and then ext_write_compensation_subseconds_msb
	 * Reset: 0x0         Access: RW
	 */
	uint32_t ext_write_compensation_subseconds_msb;
	/*
	 * [0x48] This value represents the number of cycles it for a trigger to propagate from GPIO
	 * / other eth unit [*] to PTH.  It is added to the ext_update_subseconds_lsb field before
	 * updating the system_time counter.
	 *
	 * [*] dependent on currently enabled external ingress triggers
	 *
	 * Write protocol: To assure atomic writes, SW should first write
	 * ext_write_compensation_subseconds_lsb, and then ext_write_compensation_subseconds_msb
	 */
	uint32_t ext_write_compensation_subseconds_lsb;
	/*
	 * [0x4c] Value to be added to system_time before transferring to the MAC, to account for
	 * synchronization latency
	 *
	 * Write protocol: To assure atomic writes, SW should first write
	 * sync_compensation_subseconds_lsb, and then sync_compensation_subseconds_msb
	 * Reset: 0x0         Access: RW
	 */
	uint32_t sync_compensation_subseconds_msb;
	/*
	 * [0x50] Value to be added to system_time before transferring to the MAC, to account for
	 * synchronization latency
	 *
	 * Write protocol: To assure atomic writes, SW should first write
	 * sync_compensation_subseconds_lsb, and then sync_compensation_subseconds_msb
	 */
	uint32_t sync_compensation_subseconds_lsb;
	/* [0x54] align pth timestamp */
	uint32_t nanosec_align;
	/* [0x58] */
	uint32_t rsrvd_0[10];
};

/*
 * PTH egress trigger configurations
 */
struct al_ec_pth_egress {
	/* [0x0] Control register for egress trigger #k */
	uint32_t trigger_ctrl;
	/*
	 * [0x4] threshold for next egress trigger (#k) - seconds
	 *
	 * Write protocol: To assure atomic writes, software writes the threshold value in the
	 * following order:
	 * 1. egress_trigger_subseconds_lsb
	 * 2. egress_trigger_subseconds_msb
	 * 3. egress_trigger_seconds
	 * Seconds from 1/1/1970, 00:00 TAI, or from 31/12/1969 23:59:51.999918 UTC
	 * Reset: 0x0         Access: RW
	 */
	uint32_t trigger_seconds;
	/*
	 * [0x8] Threshold for next egress trigger (#k) - subseconds_msbs
	 *
	 * Write protocol: To assure atomic writes, software writes the threshold value in the
	 * following order:
	 * 1. egress_trigger_subseconds_lsb
	 * 2. egress_trigger_subseconds_msb
	 * 3. egress_trigger_seconds
	 * Reset: 0x0         Access: RW
	 */
	uint32_t trigger_subseconds_msb;
	/*
	 * [0xc] threshold for next egress trigger (#k) - subseconds_lsbs
	 *
	 * Write protocol: To assure atomic writes, SW write threshold  value in the following
	 * order:
	 * 1. egress_trigger_subseconds_lsb
	 * 2. egress_trigger_subseconds_msb
	 * 3. egress_trigger_seconds
	 */
	uint32_t trigger_subseconds_lsb;
	/*
	 * [0x10] External output pulse width (subseconds_msb)
	 * (Atomic writes are not guaranteed; this value is meant to be configured once, in boot
	 * time.)
	 * Reset: 0x0         Access: RW
	 */
	uint32_t pulse_width_subseconds_msb;
	/*
	 * [0x14] External output pulse width (subseconds_lsb)
	 * (Atomic writes are not guaranteed; this value is meant to be configured once, in boot
	 * time.)
	 */
	uint32_t pulse_width_subseconds_lsb;
	/* [0x18] */
	uint32_t rsrvd_0[2];
};

/*
 * DB of TX timestamp values
 * NOTE: when using 1G ports, only indices 1-7 can hold legal TS values
 */
struct al_ec_pth_db {
	/*
	 * [0x0] timestamp[k], in resolution of 2^18 femtosec =~ 0.25nsec.
	 * Reset: 0x0         Access: RW
	 */
	uint32_t ts;
	/* [0x4] Timestamp entry is valid */
	uint32_t qual;
	/* [0x8] */
	uint32_t rsrvd_0[4];
};

/*
 * Ethernet ontroller V3 General configuration
 */
struct al_ec_gen_v3 {
	/* [0x0] Bypass enable */
	uint32_t bypass;
	/* [0x4] Rx Completion descriptor */
	uint32_t rx_comp_desc;
	/* [0x8] general configuration */
	uint32_t conf;
	/* [0xc] tpm */
	uint32_t tpm;
	/* [0x10] Vlan modification  table address */
	uint32_t tpm_vlan_mod_table_addr;
	/*
	 * [0x14] Vlan modification  table register 1
	 * Note this is read trigger to the table
	 */
	uint32_t tpm_vlan_mod_table_1;
	/*
	 * [0x18] Vlan modification  table register 1
	 * Note this is write trigger to the table
	 */
	uint32_t tpm_vlan_mod_table_2;
	/* [0x1c] */
	uint32_t rsrvd_0[9];
};

/*
 * Tx Forwarding V3
 */
struct al_ec_tfw_v3 {
	/* [0x0] Generic protocol detect Cam compare table address */
	uint32_t tx_gpd_cam_addr;
	/*
	 * [0x4] Tx Generic protocol detect Cam compare data_1 (low)
	 * Note - this register is read trigger for entire table entry
	 * Reset: 0x0         Access: RW
	 */
	uint32_t tx_gpd_cam_data_1;
	/*
	 * [0x8] Tx Generic protocol detect Cam compare data_2 (high)
	 * Reset: 0x0         Access: RW
	 */
	uint32_t tx_gpd_cam_data_2;
	/*
	 * [0xc] Tx Generic protocol detect Cam compare mask_1 (low)
	 * Reset: 0x0         Access: RW
	 */
	uint32_t tx_gpd_cam_mask_1;
	/*
	 * [0x10] Tx Generic protocol detect Cam compare mask_1 (high)
	 * Reset: 0x0         Access: RW
	 */
	uint32_t tx_gpd_cam_mask_2;
	/* [0x14] Tx Generic protocol detect Cam compare control */
	uint32_t tx_gpd_cam_ctrl;
	/* [0x18] Tx Generic crc parameters legacy */
	uint32_t tx_gcp_legacy;
	/* [0x1c] Tx Generic crc prameters table address */
	uint32_t tx_gcp_table_addr;
	/* [0x20] Tx Generic crc prameters table general */
	uint32_t tx_gcp_table_gen;
	/*
	 * [0x24] Tx Generic crc parametrs tabel mask word 1
	 * mask data word 1 - 1 bit masks 4 data bits
	 * Reset: 0x0         Access: RW
	 */
	uint32_t tx_gcp_table_mask_1;
	/*
	 * [0x28] Tx Generic crc parametrs tabel mask word 2
	 * mask data word 2 - 1 bit masks 4 data bits
	 * Reset: 0x0         Access: RW
	 */
	uint32_t tx_gcp_table_mask_2;
	/*
	 * [0x2c] Tx Generic crc parametrs tabel mask word 3
	 * mask data word 3 - 1 bit masks 4 data bits
	 * Reset: 0x0         Access: RW
	 */
	uint32_t tx_gcp_table_mask_3;
	/*
	 * [0x30] Tx Generic crc parametrs tabel mask word 4
	 * mask data word 4 - 1 bit masks 4 data bits
	 * Reset: 0x0         Access: RW
	 */
	uint32_t tx_gcp_table_mask_4;
	/*
	 * [0x34] Tx Generic crc parametrs tabel mask word 5
	 * mask data word 5 - 1 bit masks 4 data bits
	 * Reset: 0x0         Access: RW
	 */
	uint32_t tx_gcp_table_mask_5;
	/*
	 * [0x38] Tx Generic crc parametrs tabel mask word 6
	 * mask data word 6 - 1 bit masks 4 data bits
	 * Reset: 0x0         Access: RW
	 */
	uint32_t tx_gcp_table_mask_6;
	/*
	 * [0x3c] Tx Generic crc parametrs tabel crc init
	 * crc32/crc32c init value
	 * Reset: 0x0         Access: RW
	 */
	uint32_t tx_gcp_table_crc_init;
	/* [0x40] Tx Generic crc parametrs tabel result configuration */
	uint32_t tx_gcp_table_res;
	/* [0x44] Tx Generic crc parameters table alu opcode */
	uint32_t tx_gcp_table_alu_opcode;
	/* [0x48] Tx Generic crc parameters table alu opsel */
	uint32_t tx_gcp_table_alu_opsel;
	/*
	 * [0x4c] Tx Generic crc parameters table alu constant value
	 * Note - this register is write trigger for entire table entry
	 */
	uint32_t tx_gcp_table_alu_val;
	/* [0x50] Tx CRC/Checksum replace */
	uint32_t crc_csum_replace;
	/* [0x54] CRC/Checksum replace table address */
	uint32_t crc_csum_replace_table_addr;
	/* [0x58] CRC/Checksum replace table */
	uint32_t crc_csum_replace_table;
	/*
	 * [0x5c] protocol numebr selcetion table entries 31-0
	 * protocol number selection
	 * 0 - from Tx buffer descriptor
	 * 1 - from protocol detect cam
	 * Reset: 0x0         Access: RW
	 */
	uint32_t tx_protocol_num_sel_table_1;
	/*
	 * [0x60] protocol numebr selcetion table entries 63:32
	 * protocol number selection
	 * 0 - from Tx buffer descriptor
	 * 1 - from protocol detect cam
	 * Reset: 0x0         Access: RW
	 */
	uint32_t tx_protocol_num_sel_table_2;
	/* [0x64] */
	uint32_t rsrvd_0[7];
};

/*
 * Rx Forwarding V3
 */
struct al_ec_rfw_v3 {
	/* [0x0] Rx Generic protocol detect Cam compare table address */
	uint32_t rx_gpd_cam_addr;
	/*
	 * [0x4] Rx Generic protocol detect Cam compare data_1 (low)
	 * Note - this register is read/write trigger for entire table entry
	 * Reset: 0x0         Access: RW
	 */
	uint32_t rx_gpd_cam_data_1;
	/*
	 * [0x8] Rx Generic protocol detect Cam compare data_2 (high)
	 * Reset: 0x0         Access: RW
	 */
	uint32_t rx_gpd_cam_data_2;
	/*
	 * [0xc] Rx Generic protocol detect Cam compare mask_1 (low)
	 * Reset: 0x0         Access: RW
	 */
	uint32_t rx_gpd_cam_mask_1;
	/*
	 * [0x10] Rx Generic protocol detect Cam compare mask_1 (high)
	 * Reset: 0x0         Access: RW
	 */
	uint32_t rx_gpd_cam_mask_2;
	/* [0x14] Rx Generic protocol detect Cam compare control */
	uint32_t rx_gpd_cam_ctrl;
	/* [0x18] Generic protocol detect Parser result vector pointer 1 */
	uint32_t gpd_p1;
	/* [0x1c] Generic protocol detect Parser result vector pointer 2 */
	uint32_t gpd_p2;
	/* [0x20] Generic protocol detect Parser result vector pointer 3 */
	uint32_t gpd_p3;
	/* [0x24] Generic protocol detect Parser result vector pointer 4 */
	uint32_t gpd_p4;
	/* [0x28] Generic protocol detect Parser result vector pointer 5 */
	uint32_t gpd_p5;
	/* [0x2c] Generic protocol detect Parser result vector pointer 6 */
	uint32_t gpd_p6;
	/* [0x30] Generic protocol detect Parser result vector pointer 7 */
	uint32_t gpd_p7;
	/* [0x34] Generic protocol detect Parser result vector pointer 8 */
	uint32_t gpd_p8;
	/* [0x38] Rx Generic crc parameters legacy */
	uint32_t rx_gcp_legacy;
	/* [0x3c] Rx Generic crc prameters table address */
	uint32_t rx_gcp_table_addr;
	/*
	 * [0x40] Rx Generic crc prameters table general
	 * Note - this register is read trigger for entire table entry
	 */
	uint32_t rx_gcp_table_gen;
	/*
	 * [0x44] Rx Generic crc parametrs tabel mask word 1
	 * mask data word 1 - 1 bit masks 4 data bits
	 * Reset: 0x0         Access: RW
	 */
	uint32_t rx_gcp_table_mask_1;
	/*
	 * [0x48] Rx Generic crc parametrs tabel mask word 2
	 * mask data word 2 - 1 bit masks 4 data bits
	 * Reset: 0x0         Access: RW
	 */
	uint32_t rx_gcp_table_mask_2;
	/*
	 * [0x4c] Rx Generic crc parametrs tabel mask word 3
	 * mask data word 3 - 1 bit masks 4 data bits
	 * Reset: 0x0         Access: RW
	 */
	uint32_t rx_gcp_table_mask_3;
	/*
	 * [0x50] Rx Generic crc parametrs tabel mask word 4
	 * mask data word 4 - 1 bit masks 4 data bits
	 * Reset: 0x0         Access: RW
	 */
	uint32_t rx_gcp_table_mask_4;
	/*
	 * [0x54] Rx Generic crc parametrs tabel mask word 5
	 * mask data word 5 - 1 bit masks 4 data bits
	 * Reset: 0x0         Access: RW
	 */
	uint32_t rx_gcp_table_mask_5;
	/*
	 * [0x58] Rx Generic crc parametrs tabel mask word 6
	 * mask data word 6 - 1 bit masks 4 data bits
	 * Reset: 0x0         Access: RW
	 */
	uint32_t rx_gcp_table_mask_6;
	/*
	 * [0x5c] Rx Generic crc parametrs tabel crc init
	 * crc32/crc32c init value
	 * Reset: 0x0         Access: RW
	 */
	uint32_t rx_gcp_table_crc_init;
	/* [0x60] Rx Generic crc parametrs tabel result configuration */
	uint32_t rx_gcp_table_res;
	/* [0x64] Rx Generic crc  parameters table alu opcode */
	uint32_t rx_gcp_table_alu_opcode;
	/* [0x68] Rx Generic crc  parameters table alu opsel */
	uint32_t rx_gcp_table_alu_opsel;
	/* [0x6c] Rx Generic crc  parameters table alu constant value */
	uint32_t rx_gcp_table_alu_val;
	/* [0x70] Generic crc engin parameters alu Parser result vector pointer 1 */
	uint32_t rx_gcp_alu_p1;
	/*
	 * [0x74] Generic crc engine parameters alu Parser result vector pointer 2
	 * Note - this register is write trigger for entire table entry
	 */
	uint32_t rx_gcp_alu_p2;
	/* [0x78] Header split control table address */
	uint32_t hs_ctrl_table_addr;
	/*
	 * [0x7c] Header split control table
	 * Note - this register is read trigger for entire table entry
	 */
	uint32_t hs_ctrl_table;
	/* [0x80] Header split control alu opcode */
	uint32_t hs_ctrl_table_alu_opcode;
	/* [0x84] Header split control alu opsel */
	uint32_t hs_ctrl_table_alu_opsel;
	/*
	 * [0x88] Header split control alu constant value
	 * Note - this register is write trigger for entire table entry
	 */
	uint32_t hs_ctrl_table_alu_val;
	/* [0x8c] Header split control configuration */
	uint32_t hs_ctrl_cfg;
	/* [0x90] Header split control alu Parser result vector pointer 1 */
	uint32_t hs_ctrl_alu_p1;
	/* [0x94] Header split control alu Parser result vector pointer 2 */
	uint32_t hs_ctrl_alu_p2;
	/* [0x98] general configuration */
	uint32_t rfw_gen_cfg;
	/*
	 * [0x9c] protocol numebr selcetion table entries 31-0
	 * protocol number selection
	 * 0 - from shared_rfw protocol detect cam
	 * 1 - from ec_rfw protocol detect cam (v3)
	 * Reset: 0x0         Access: RW
	 */
	uint32_t rx_protocol_num_sel_table_1;
	/*
	 * [0xa0] protocol numebr selcetion table entries 63:32
	 * protocol number selection
	 * 0 - from shared_rfw protocol detect cam
	 * 1 - from ec_rfw protocol detect cam (v3)
	 * Reset: 0x0         Access: RW
	 */
	uint32_t rx_protocol_num_sel_table_2;
	/* [0xa4] */
	uint32_t rsrvd_0[23];
};

/*
 * Inline crypto
 */
struct al_ec_crypto {
	/* [0x0] Tx inline crypto configuration */
	uint32_t tx_config;
	/* [0x4] Rx inline crypto configuration */
	uint32_t rx_config;
	/* [0x8] reserved FFU */
	uint32_t tx_override;
	/* [0xc] reserved FFU */
	uint32_t rx_override;
	/*
	 * [0x10] inline XTS alpha [31:0]
	 * xts algorithm const (ieee 1619-2007)
	 * Reset: 0x2         Access: RW
	 */
	uint32_t xts_alpha_1;
	/*
	 * [0x14] inline XTS alpha [63:32]
	 * xts algorithm const (ieee 1619-2007)
	 * Reset: 0x0         Access: RW
	 */
	uint32_t xts_alpha_2;
	/*
	 * [0x18] inline XTS alpha [95:64]
	 * xts algorithm const (ieee 1619-2007)
	 * Reset: 0x0         Access: RW
	 */
	uint32_t xts_alpha_3;
	/*
	 * [0x1c] inline XTS alpha [127:96]
	 * xts algorithm const (ieee 1619-2007)
	 * Reset: 0x0         Access: RW
	 */
	uint32_t xts_alpha_4;
	/*
	 * [0x20] inline XTS sector ID increment [31:0]
	 * Increment [31:0]
	 * Reset: 0x1         Access: RW
	 */
	uint32_t xts_sector_id_1;
	/*
	 * [0x24] inline XTS sector ID increment [63:32]
	 * Increment [63:32]
	 * Reset: 0x0         Access: RW
	 */
	uint32_t xts_sector_id_2;
	/*
	 * [0x28] inline XTS sector ID increment [95:64]
	 * Increment [95:64]
	 * Reset: 0x0         Access: RW
	 */
	uint32_t xts_sector_id_3;
	/*
	 * [0x2c] inline XTS sector ID increment [127:96]
	 * Increment [127:96]
	 * Reset: 0x0         Access: RW
	 */
	uint32_t xts_sector_id_4;
	/* [0x30] IV formation configuration */
	uint32_t tx_enc_iv_construction;
	/* [0x34] IV formation configuration */
	uint32_t rx_enc_iv_construction;
	/* [0x38] IV formation configuration */
	uint32_t rx_enc_iv_map;
	/*
	 * [0x3c] effectively shorten shift-registers used for eop-pkt-trim, in order to improve
	 * performance.
	 * Each value must be built of consecutive 1's (bypassed regs), and then consecutive 0's
	 * (non-bypassed regs)
	 */
	uint32_t tx_pkt_trim_len;
	/*
	 * [0x40] effectively shorten shift-registers used for eop-pkt-trim, in order to improve
	 * performance.
	 * Each value must be built of consecutive 1's (bypassed regs), and then consecutive 0's
	 * (non-bypassed regs)
	 */
	uint32_t rx_pkt_trim_len;
	/*
	 * [0x44] reserved FFU
	 * Reset: 0x0         Access: RW
	 */
	uint32_t tx_reserved;
	/*
	 * [0x48] reserved FFU
	 * Reset: 0x0         Access: RW
	 */
	uint32_t rx_reserved;
	/* [0x4c] */
	uint32_t rsrvd_0[13];
};

/*
 * Inline crypto performance counter
 * Each counter counts the total number of <cntr_measure> that passed through the crypto engine,
 * using the relevant crypto table entry (mapped through the crypto_table to cntr map)
 */
struct al_ec_crypto_perf_cntr {
	/*
	 * [0x0]
	 * Reset: 0x0         Access: RW
	 */
	uint32_t total_tx_pkts;
	/*
	 * [0x4]
	 * Reset: 0x0         Access: RW
	 */
	uint32_t total_rx_pkts;
	/*
	 * [0x8]
	 * Reset: 0x0         Access: RW
	 */
	uint32_t total_tx_secured_pkts;
	/*
	 * [0xc]
	 * Reset: 0x0         Access: RW
	 */
	uint32_t total_rx_secured_pkts;
	/*
	 * [0x10]
	 * Reset: 0x0         Access: RW
	 */
	uint32_t total_tx_secured_pkts_cipher_mode;
	/* [0x14] */
	uint32_t total_tx_secured_pkts_cipher_mode_cmpr;
	/*
	 * [0x18]
	 * Reset: 0x0         Access: RW
	 */
	uint32_t total_rx_secured_pkts_cipher_mode;
	/* [0x1c] */
	uint32_t total_rx_secured_pkts_cipher_mode_cmpr;
	/*
	 * [0x20]
	 * Reset: 0x0         Access: RW
	 */
	uint32_t total_tx_secured_bytes_low;
	/*
	 * [0x24]
	 * Reset: 0x0         Access: RW
	 */
	uint32_t total_tx_secured_bytes_high;
	/*
	 * [0x28]
	 * Reset: 0x0         Access: RW
	 */
	uint32_t total_rx_secured_bytes_low;
	/*
	 * [0x2c]
	 * Reset: 0x0         Access: RW
	 */
	uint32_t total_rx_secured_bytes_high;
	/*
	 * [0x30]
	 * Reset: 0x0         Access: RW
	 */
	uint32_t total_tx_sign_calcs;
	/*
	 * [0x34]
	 * Reset: 0x0         Access: RW
	 */
	uint32_t total_rx_sign_calcs;
	/*
	 * [0x38]
	 * Reset: 0x0         Access: RW
	 */
	uint32_t total_tx_sign_errs;
	/*
	 * [0x3c]
	 * Reset: 0x0         Access: RW
	 */
	uint32_t total_rx_sign_errs;
};

/*
 * tid_default_entry
 */
struct al_ec_crypto_tx_tid {
	/*
	 * [0x0] tid_default_entry
	 * used in order to reduce number of extended metadata tx descriptors for tx-crypto pkts, if
	 * a certain field is always constant
	 * Reset: 0x0         Access: RW
	 */
	uint32_t def_val;
};

/*
 * Remap table of protocol numbers. Map 64 possible protocol numbers to 4.
 */
struct al_ec_pn_remap {
	/* [0x0] Table access address */
	uint32_t table_addr;
	/* [0x4] Remapped protocol number */
	uint32_t table_data;
	/* [0x8] */
	uint32_t rsrvd_0[6];
};

/*
 * TMI Forwarding Table
 */
struct al_ec_tmi_fwd_table {
	/* [0x0] Table access address */
	uint32_t addr;
	/* [0x4] */
	uint32_t fields;
	/* [0x8] */
	uint32_t rsrvd_0[2];
	/* [0x10] If set, table decision will be ignored for this field */
	uint32_t fields_ignore;
	/* [0x14] */
	uint32_t rsrvd_1[11];
	/*
	 * [0x40] Bits from stram_info for those offsets will be taken to address calculation,
	 * relative to MSB!
	 */
	uint32_t stream_info_fields;
	/* [0x44] cmpl_metadata0, cmpl_metadata1 will be assigned to those offsets */
	uint32_t cmpl_metadata_fields;
	/* [0x48] general configuration */
	uint32_t cfg;
	/* [0x4c] */
	uint32_t rsrvd_2[13];
};

/*
 * Rx Forwarding engine, udma selection, port mapping
 */
struct al_ec_rfw_v4_udma_select {
	/*
	 * [0x0] port to udma mapping (each register is 8 entries)
	 * each entry is 4 bits udma bit map
	 * Reset: 0x0         Access: RW
	 */
	uint32_t port_map;
};

/*
 * Rx Forwarding engine V4
 */
struct al_ec_rfw_v4 {
	/* [0x0] udma selection */
	uint32_t udma_select;
	/*
	 * [0x4] rfw pipe control - hold to every phase
	 * add hold to every phase
	 * Reset: 0x0         Access: RW
	 */
	uint32_t pipe_ctrl_hold_phase;
	/*
	 * [0x8] rfw pipe control - empty stage ready
	 * in_ready set when stage is empty
	 * Reset: 0x0         Access: RW
	 */
	uint32_t pipe_ctrl_empty_stage_ready;
	/* [0xc] FIFO data memory */
	uint32_t data_fifo_depth;
};

/*
 * crc parameters
 */
struct al_ec_crc {
	/* [0x0] Tx Generic crc prameters table address */
	uint32_t v4_tx_gcp_table_addr;
	/* [0x4] Tx Generic crc prameters table general */
	uint32_t v4_tx_gcp_table_gen;
	/*
	 * [0x8] Tx Generic crc parametrs tabel mask word 1
	 * mask data word 1 - 1 bit masks 4 data bits
	 * Reset: 0x0         Access: RW
	 */
	uint32_t v4_tx_gcp_table_mask_1;
	/*
	 * [0xc] Tx Generic crc parametrs tabel mask word 2
	 * mask data word 2 - 1 bit masks 4 data bits
	 * Reset: 0x0         Access: RW
	 */
	uint32_t v4_tx_gcp_table_mask_2;
	/*
	 * [0x10] Tx Generic crc parametrs tabel mask word 3
	 * mask data word 3 - 1 bit masks 4 data bits
	 * Reset: 0x0         Access: RW
	 */
	uint32_t v4_tx_gcp_table_mask_3;
	/*
	 * [0x14] Tx Generic crc parametrs tabel mask word 4
	 * mask data word 4 - 1 bit masks 4 data bits
	 * Reset: 0x0         Access: RW
	 */
	uint32_t v4_tx_gcp_table_mask_4;
	/*
	 * [0x18] Tx Generic crc parametrs tabel mask word 5
	 * mask data word 5 - 1 bit masks 4 data bits
	 * Reset: 0x0         Access: RW
	 */
	uint32_t v4_tx_gcp_table_mask_5;
	/*
	 * [0x1c] Tx Generic crc parametrs tabel mask word 6
	 * mask data word 6 - 1 bit masks 4 data bits
	 * Reset: 0x0         Access: RW
	 */
	uint32_t v4_tx_gcp_table_mask_6;
	/*
	 * [0x20] Tx Generic crc parametrs tabel crc init
	 * crc32/crc32c init value
	 * Reset: 0x0         Access: RW
	 */
	uint32_t v4_tx_gcp_table_crc_init;
	/* [0x24] Tx Generic crc parametrs tabel result configuration */
	uint32_t v4_tx_gcp_table_res;
	/* [0x28] Tx Generic crc parameters table alu opcode */
	uint32_t v4_tx_gcp_table_alu_opcode;
	/* [0x2c] Tx Generic crc parameters table alu opsel */
	uint32_t v4_tx_gcp_table_alu_opsel;
	/*
	 * [0x30] Tx Generic crc parameters table alu constant value
	 * Note - this register is write trigger for entire table entry
	 */
	uint32_t v4_tx_gcp_table_alu_val;
	/* [0x34] Tx Generic crc prameters table extentions 1 */
	uint32_t v4_tx_gcp_table_ext_1;
	/* [0x38] Tx Generic crc prameters table extentions 2 */
	uint32_t v4_tx_gcp_table_ext_2;
	/*
	 * [0x3c] Tx Generic crc prameters table extentions 3
	 * crc/cks field check value (for replace if match)
	 * Duplicate if crc/cks 8 or 16
	 * Reset: 0x0         Access: RW
	 */
	uint32_t v4_tx_gcp_table_ext_3;
	/*
	 * [0x40] Tx Generic crc prameters table extentions 4
	 * crc/cks field replace value (for replace if match)
	 * Reset: 0x0         Access: RW
	 */
	uint32_t v4_tx_gcp_table_ext_4;
	/*
	 * [0x44] Tx Generic crc prameters table extentions 5
	 * crc/cks field detect value (for correct indication if match)
	 * Use msb if crc/cks 8 or 16
	 * Reset: 0x0         Access: RW
	 */
	uint32_t v4_tx_gcp_table_ext_5;
	/*
	 * [0x48] Tx Generic crc prameters table extentions 6
	 * Note - this register is write trigger for entire table entry
	 */
	uint32_t v4_tx_gcp_table_ext_6;
	/* [0x4c] Rx Generic crc prameters table address */
	uint32_t v4_rx_gcp_table_addr;
	/*
	 * [0x50] Rx Generic crc prameters table general
	 * Note - this register is read trigger for entire table entry
	 */
	uint32_t v4_rx_gcp_table_gen;
	/*
	 * [0x54] Rx Generic crc parametrs tabel mask word 1
	 * mask data word 1 - 1 bit masks 4 data bits
	 * Reset: 0x0         Access: RW
	 */
	uint32_t v4_rx_gcp_table_mask_1;
	/*
	 * [0x58] Rx Generic crc parametrs tabel mask word 2
	 * mask data word 2 - 1 bit masks 4 data bits
	 * Reset: 0x0         Access: RW
	 */
	uint32_t v4_rx_gcp_table_mask_2;
	/*
	 * [0x5c] Rx Generic crc parametrs tabel mask word 3
	 * mask data word 3 - 1 bit masks 4 data bits
	 * Reset: 0x0         Access: RW
	 */
	uint32_t v4_rx_gcp_table_mask_3;
	/*
	 * [0x60] Rx Generic crc parametrs tabel mask word 4
	 * mask data word 4 - 1 bit masks 4 data bits
	 * Reset: 0x0         Access: RW
	 */
	uint32_t v4_rx_gcp_table_mask_4;
	/*
	 * [0x64] Rx Generic crc parametrs tabel mask word 5
	 * mask data word 5 - 1 bit masks 4 data bits
	 * Reset: 0x0         Access: RW
	 */
	uint32_t v4_rx_gcp_table_mask_5;
	/*
	 * [0x68] Rx Generic crc parametrs tabel mask word 6
	 * mask data word 6 - 1 bit masks 4 data bits
	 * Reset: 0x0         Access: RW
	 */
	uint32_t v4_rx_gcp_table_mask_6;
	/*
	 * [0x6c] Rx Generic crc parametrs tabel crc init
	 * crc32/crc32c init value
	 * Reset: 0x0         Access: RW
	 */
	uint32_t v4_rx_gcp_table_crc_init;
	/*
	 * [0x70] Rx Generic crc parametrs tabel result configuration
	 * V3 - partition as written in sel_0/1/2/3/4
	 * V4 - sel_0/1/2/3/4 100 bit, partition as follow:
	 *            [0   +: 12]; // comp desc v4: meta word 0 bit 13
	 *            [12 +: 12]; // comp desc v4: meta word 0 bit 14
	 *            [24 +: 12]; // comp desc v4: meta word 0 bit 7
	 *            [36 +: 12]; // comp desc v4: meta word 2 bit 30
	 *            [48 +: 12]; // comp desc v4: meta word 3 bit 31
	 *            [60 +: 12]; // comp desc v4: meta word 3 bit 30
	 *            [72 +: 12]; // comp desc v4: meta word 3 bit 29
	 *            [84 +: 12]; // comp desc v4: meta word 3 bit 28
	 *         each 12bit select crc/cks engines results:
	 *            [11] reserved
	 *            [10] reserved
	 *            [ 9] csp 1 crc generic engine
	 *            [ 8] csp 0 crc generic engine
	 *            [ 7] crc32_ok[3], // generic engine
	 *            [ 6] crc32_ok[2], // generic engine
	 *            [ 5] crc32_ok[1], // generic engine
	 *            [ 4] crc32_ok[0], // generic engine
	 *            [ 3] l4_checksum_ok_tcks, //tunnel l4 cks engine
	 *            [ 2] l3_checksum_ok_tcks, //tunnel l3 cks engine
	 *            [ 1] l4_checksum_ok_cks,  //l4 cks engine
	 *            [ 0] l3_checksum_ok_cks   //l3 cks engine
	 */
	uint32_t v4_rx_gcp_table_res;
	/* [0x74] Rx Generic crc  parameters table alu opcode */
	uint32_t v4_rx_gcp_table_alu_opcode;
	/* [0x78] Rx Generic crc  parameters table alu opsel */
	uint32_t v4_rx_gcp_table_alu_opsel;
	/* [0x7c] Rx Generic crc  parameters table alu constant value */
	uint32_t v4_rx_gcp_table_alu_val;
	/* [0x80] Rx Generic crc prameters table extentions 1 */
	uint32_t v4_rx_gcp_table_ext_1;
	/* [0x84] Rx Generic crc prameters table extentions 2 */
	uint32_t v4_rx_gcp_table_ext_2;
	/*
	 * [0x88] Rx Generic crc prameters table extentions 3
	 * crc/cks field check value (for replace if match)
	 * Duplicate if crc/cks 8 or 16
	 * Reset: 0x0         Access: RW
	 */
	uint32_t v4_rx_gcp_table_ext_3;
	/*
	 * [0x8c] Rx Generic crc prameters table extentions 4
	 * crc/cks field replace value (for replace if match)
	 * Reset: 0x0         Access: RW
	 */
	uint32_t v4_rx_gcp_table_ext_4;
	/*
	 * [0x90] Rx Generic crc prameters table extentions 5
	 * crc/cks field detect value (for correct indication if match)
	 * Use msb if crc/cks 8 or 16
	 * Reset: 0x0         Access: RW
	 */
	uint32_t v4_rx_gcp_table_ext_5;
	/*
	 * [0x94] Rx Generic crc prameters table extentions 6
	 * Note - this register is write trigger for entire table entry
	 */
	uint32_t v4_rx_gcp_table_ext_6;
	/* [0x98] Generic crc engine parameters alu descriptor vector pointer 1 */
	uint32_t v4_tx_gcp_alu_p1;
	/* [0x9c] Generic crc engine parameters alu descriptor vector pointer 2 */
	uint32_t v4_tx_gcp_alu_p2;
	/* [0xa0] Generic crc engine parameters alu descriptor vector pointer 3 */
	uint32_t v4_tx_gcp_alu_p3;
	/* [0xa4] Generic crc engine parameters alu descriptor vector pointer 4 */
	uint32_t v4_tx_gcp_alu_p4;
	/* [0xa8] Generic crc engine parameters alu descriptor vector pointer 5 */
	uint32_t v4_tx_gcp_alu_p5;
	/* [0xac] Generic crc engine parameters alu descriptor vector pointer 6 */
	uint32_t v4_tx_gcp_alu_p6;
	/* [0xb0] Generic crc engine parameters alu tx const value */
	uint32_t v4_tx_gcp_alu_const;
	/* [0xb4] Tx Generic crc prameters alu const table address */
	uint32_t v4_tx_gcp_alu_const_table_addr;
	/*
	 * [0xb8] Tx Generic crc engine parameters alu const  table register 1
	 * Note - this register is read trigger for entire alu const table entry
	 */
	uint32_t v4_tx_gcp_alu_const_table_1;
	/* [0xbc] Tx Generic crc engine parameters alu const  table register 2 */
	uint32_t v4_tx_gcp_alu_const_table_2;
	/*
	 * [0xc0] Tx Generic crc engine parameters alu const  table register 2
	 * Note - this register is write trigger for entire alu const table entry
	 */
	uint32_t v4_tx_gcp_alu_const_table_3;
	/* [0xc4] Generic crc engine parameters alu Parser result vector pointer 1 */
	uint32_t v4_rx_gcp_alu_p1;
	/* [0xc8] Generic crc engine parameters alu Parser result vector pointer 2 */
	uint32_t v4_rx_gcp_alu_p2;
	/* [0xcc] Generic crc engine parameters alu rx const value */
	uint32_t v4_rx_gcp_alu_const;
	/*
	 * [0xd0] Generic crc engine parameters alu Parser result vector pointer 3
	 * gce 0 is used also for extended_protocol_control_table hw access address (bit 6)
	 */
	uint32_t v4_rx_gcp_alu_p3;
	/*
	 * [0xd4] Generic crc engine parameters alu Parser result vector pointer 4
	 * gce 0 is used also for extended_protocol_control_table hw access address (bit 7)
	 */
	uint32_t v4_rx_gcp_alu_p4;
	/*
	 * [0xd8] Generic crc engine parameters alu Parser result vector pointer 3
	 * gce 0 is used also for extended_protocol_control_table hw access address (bit 8)
	 */
	uint32_t v4_rx_gcp_alu_p5;
	/*
	 * [0xdc] Generic crc engine parameters alu Parser result vector pointer 4
	 * gce 0 is used also for extended_protocol_control_table hw access address (bit 9)
	 */
	uint32_t v4_rx_gcp_alu_p6;
	/* [0xe0] Rx Generic crc prameters alu const table address */
	uint32_t v4_rx_gcp_alu_const_table_addr;
	/*
	 * [0xe4] Rx Generic crc engine parameters alu const  table register 1
	 * Note - this register is read trigger for entire alu const table entry
	 */
	uint32_t v4_rx_gcp_alu_const_table_1;
	/*
	 * [0xe8] Rx Generic crc engine parameters alu const  table register 2
	 * Note - this register is write trigger for entire alu const table entry
	 */
	uint32_t v4_rx_gcp_alu_const_table_2;
	/* [0xec] */
	uint32_t rsrvd_0[5];
};

/*
 * crc extended parameters table
 */
struct al_ec_crc_extended {
	/* [0x0] Rx crc extended masktable address */
	uint32_t mask_table_addr;
	/*
	 * [0x4] Rx crc extended mask table - register 1
	 * Note - this register is read trigger for entire alu const table entry
	 * extended mask register 1 - 1 bit masks 4 data bits
	 * Reset: 0x0         Access: RW
	 */
	uint32_t mask_table_1;
	/*
	 * [0x8] Rx crc extended mask table - register 2
	 * extended mask register 2 - 1 bit masks 4 data bits
	 * Reset: 0x0         Access: RW
	 */
	uint32_t mask_table_2;
	/*
	 * [0xc] Rx crc extended mask table - register 3
	 * extended mask register 3 - 1 bit masks 4 data bits
	 * Reset: 0x0         Access: RW
	 */
	uint32_t mask_table_3;
	/*
	 * [0x10] RX crc extended mask table - register 4
	 * extended mask register 4 - 1 bit masks 4 data bits
	 * Reset: 0x0         Access: RW
	 */
	uint32_t mask_table_4;
	/*
	 * [0x14] Rx crc extended mask table - register 5
	 * extended mask register 5 - 1 bit masks 4 data bits
	 * Reset: 0x0         Access: RW
	 */
	uint32_t mask_table_5;
	/*
	 * [0x18] Rx crc extended mask table - register 6
	 * extended mask register 6 - 1 bit masks 4 data bits
	 * Reset: 0x0         Access: RW
	 */
	uint32_t mask_table_6;
	/*
	 * [0x1c] Rx crc extended mask table - register 7
	 * extended mask register 7 - 1 bit masks 4 data bits
	 * Reset: 0x0         Access: RW
	 */
	uint32_t mask_table_7;
	/*
	 * [0x20] Rx crc extended mask table - register 8
	 * extended mask register 8 - 1 bit masks 4 data bits
	 * Reset: 0x0         Access: RW
	 */
	uint32_t mask_table_8;
	/*
	 * [0x24] Rx crc extended mask table - register 9
	 * extended mask register 9 - 1 bit masks 4 data bits
	 * Reset: 0x0         Access: RW
	 */
	uint32_t mask_table_9;
	/*
	 * [0x28] Rx crc extended mask table - register 10
	 * extended mask register 10 - 1 bit masks 4 data bits
	 * Reset: 0x0         Access: RW
	 */
	uint32_t mask_table_10;
	/*
	 * [0x2c] Rx crc extended mask table - register 11
	 * extended mask register 11 - 1 bit masks 4 data bits
	 * Reset: 0x0         Access: RW
	 */
	uint32_t mask_table_11;
	/*
	 * [0x30] Rx crc extended mask table - register 12
	 * extended mask register 12 - 1 bit masks 4 data bits
	 * Reset: 0x0         Access: RW
	 */
	uint32_t mask_table_12;
	/*
	 * [0x34] Rx crc extended mask table - register 13
	 * extended mask register 13 - 1 bit masks 4 data bits
	 * Reset: 0x0         Access: RW
	 */
	uint32_t mask_table_13;
	/*
	 * [0x38] RX crc extended mask table - register 14
	 * extended mask register 14 - 1 bit masks 4 data bits
	 * Reset: 0x0         Access: RW
	 */
	uint32_t mask_table_14;
	/*
	 * [0x3c] Rx crc extended mask table - register 15
	 * extended mask register 15 - 1 bit masks 4 data bits
	 * Reset: 0x0         Access: RW
	 */
	uint32_t mask_table_15;
	/*
	 * [0x40] Rx crc extended mask table - register 16
	 * Note - this register is write trigger for entire alu const table entry
	 * extended mask register 16 - 1 bit masks 4 data bits
	 * Reset: 0x0         Access: RW
	 */
	uint32_t mask_table_16;
	/* [0x44] Rx crc protocol controltable address */
	uint32_t rx_protocol_control_table_addr;
	/*
	 * [0x48] Rx crc protocol control table - register 1
	 * Note - this register is read trigger for entire alu const table entry
	 * Note - this register is write trigger for entire alu const table entry
	 */
	uint32_t rx_protocol_control_table_1;
	/* [0x4c] Tx crc protocol controltable address */
	uint32_t tx_protocol_control_table_addr;
	/*
	 * [0x50] Tx crc protocol control table - register 1
	 * Note - this register is read trigger for entire alu const table entry
	 * Note - this register is write trigger for entire alu const table entry
	 */
	uint32_t tx_protocol_control_table_1;
	/* [0x54] Tx CRC insert enable table address */
	uint32_t tx_insert_en_table_addr;
	/*
	 * [0x58] Tx CRC insert enable table register 1
	 * Note - this register is read trigger for entire alu const table entry
	 * Note - this register is write trigger for entire alu const table entry
	 */
	uint32_t tx_insert_en_table_1;
};

/*
 * Outstanding table
 * 0-2 : Rx instances
 * 3-4 : Tx instances
 */
struct al_ec_outstanding_gen {
	/* [0x0] outstanding table arbiter general  configuration register */
	uint32_t arb_cfg;
};

/*
 * outstanding tableec
 */
struct al_ec_outstanding {
	/* [0x0] outstanding table arbiter configuration register 1 */
	uint32_t arb_cfg_1;
	/* [0x4] outstanding table arbiter configuration register 2 */
	uint32_t arb_cfg_2;
};

/*
 * RFF configuration
 */
struct al_ec_rff {
	/* [0x0] RFF to RFW Shared i/f */
	uint32_t to_rfw_shared;
	/* [0x4] FIFO data memory */
	uint32_t data_fifo_depth_limit;
};

/*
 * rfw protocol_index selection table
 */
struct al_ec_rfw_prot_index {
	/* [0x0] rfw protocol_index selection table 1 */
	uint32_t table_1;
	/* [0x4] rfw protocol_index selection table 2 */
	uint32_t table_2;
	/* [0x8] rfw protocol_index selection table 3 */
	uint32_t table_3;
	/* [0xc] rfw protocol_index selection table 4 */
	uint32_t table_4;
};

/*
 * udp len offset table
 */
struct al_ec_udp_len {
	/*
	 * [0x0] udp len offset table
	 * 64 x 8 bit offset (in bytes)
	 * Reset: 0x0         Access: RW
	 */
	uint32_t insertion_offset_table;
};

/*
 * udp len insertion
 */
struct al_ec_udp_len_insertion {
	/* [0x0] offset from sop 0 */
	uint32_t offset_from_sop0;
	/* [0x4] offset from sop 1 */
	uint32_t offset_from_sop1;
	/* [0x8] offset from sop 2 */
	uint32_t offset_from_sop2;
	/* [0xc] udp len insertion mask */
	uint32_t mask;
	/* [0x10] udp len insertion enable */
	uint32_t enable;
};

/*
 * TMI V4
 */
struct al_ec_tmi_v4 {
	/* [0x0] protocol number */
	uint32_t protocol_number;
};

/*
 * csd db write credit base
 */
struct al_ec_crdt_os2sr_wr {
	/* [0x0] */
	uint32_t req;
	/* [0x4] */
	uint32_t res;
};

struct al_ec_spare {
	/*
	 * [0x0] spare configuration bits
	 * Reset: 0x0         Access: RW
	 */
	uint32_t zero;
	/*
	 * [0x4] spare configuration bits
	 * Reset: 0xffffffff  Access: RW
	 */
	uint32_t one;
};

struct al_ec_regs {
	/* [0x0] */
	uint32_t rsrvd_0[32];
	/*
	 * [0x80] General configuration of the system clock domain features in the Ethernet
	 * controller
	 */
	struct al_ec_gen gen;
	/* [0xc0] Configuration of the MAC clock domain features in the Ethernet controller */
	struct al_ec_mac mac;
	/* [0x100] Configuration of the Rx FIFO */
	struct al_ec_rxf rxf;
	/* [0x180] Ethernet Parsing Engine general configuration */
	struct al_ec_epe epe[2];
	/* [0x200] Ethernet Parsing Engine, Result pointers */
	struct al_ec_epe_res epe_res;
	/*
	 * [0x280] Ethernet parsing engine, header length configuration.
	 * 4 tables, 2  for each parser,
	 * 0-15 - Registers for tables of parser 1
	 * 16-31 - Registers for tables of parser 2
	 */
	struct al_ec_epe_h epe_h[32];
	/* [0x300] Ethernet Parsing Engine protocol comparator configuration */
	struct al_ec_epe_p epe_p[32];
	/* [0x680] Ethernet Parsing Engine action register per protocol index */
	struct al_ec_epe_a epe_a[32];
	/* [0x700] Rx Forwarding engine general configuration */
	struct al_ec_rfw rfw;
	/* [0x7e0] */
	uint32_t rsrvd_1[4];
	/* [0x7f0] Rx Forwarding engine, per UDMA configuration */
	struct al_ec_rfw_udma rfw_udma[4];
	/* [0x800] Rx Forwarding engine, HASH key configuration */
	struct al_ec_rfw_hash rfw_hash[10];
	/* [0x828] Rx Forwarding engine, priority mapping configuration */
	struct al_ec_rfw_priority rfw_priority[8];
	/* [0x848] Rx Forwarding engine, priority mapping configuration */
	struct al_ec_rfw_default rfw_default[8];
	/*
	 * [0x868] Forwarding engine, MAC address compare registers used in both Rx and Tx
	 * forwarding.
	 */
	struct al_ec_fwd_mac fwd_mac[32];
	/* [0xae8] Rx Multi-stream write general configuration */
	struct al_ec_msw msw;
	/* [0xb00] TSO and stream interface configuration */
	struct al_ec_tso tso;
	/* [0xb60] TSO selection for MSS value */
	struct al_ec_tso_sel tso_sel[8];
	/* [0xb80] Tx parsing engine configuration */
	struct al_ec_tpe tpe;
	/* [0xbc0] Tx packet modification engine configuration */
	struct al_ec_tpm_udma tpm_udma[4];
	/* [0xbf0] Tx packet modification engine configuration */
	struct al_ec_tpm_sel tpm_sel[4];
	/* [0xc00] Tx Forwarding configuration */
	struct al_ec_tfw tfw;
	/*
	 * [0xc60] Tx forwarding engine
	 * UDMA output bitmap configuration per UDMA
	 */
	struct al_ec_tfw_udma tfw_udma[4];
	/* [0xcc0] Tx MAC interface */
	struct al_ec_tmi tmi;
	/* [0xcd0] Ethernet flow control registers */
	struct al_ec_efc efc;
	/* [0xd00] Ethernet flow control per UDMA configuration registers */
	struct al_ec_fc_udma fc_udma[4];
	/* [0xf00] TPG RPA address gap */
	struct al_ec_tpg_rpa_res tpg_rpa_res;
	/* [0x1000] EEE control and configuration */
	struct al_ec_eee eee;
	/* [0x1100] Statistic counters */
	struct al_ec_stat stat;
	/* [0x1300] Statistic counters per UDMA */
	struct al_ec_stat_udma stat_udma[4];
	/* [0x1700] MACsec parsing engine general configuration */
	struct al_ec_msp msp;
	/*
	 * [0x1740] MACsec parsing engine, header length configuration. 4 tables, 2  for each parser
	 * 0 -15 - Registers for tables of parser 1
	 * 16-31 - Registers for tables of parser 2
	 */
	struct al_ec_msp_p msp_p[32];
	/* [0x17c0] MACsec Parsing Engine protocol comparator  configuration */
	struct al_ec_msp_c msp_c[32];
	/* [0x1b40] CRC Engine (CRCE) configuration */
	struct al_ec_crce crce;
	/* [0x1b80] Wake-on-LAN (WoL) configuration */
	struct al_ec_wol wol;
	/* [0x1bc0] */
	uint32_t rsrvd_2[16];
	/* [0x1c00] */
	uint32_t int_ctrl_mem[64];
	/* [0x1d00] PTH configuration */
	struct al_ec_pth pth;
	/* [0x1d80] PTH egress trigger configurations */
	struct al_ec_pth_egress pth_egress[8];
	/*
	 * [0x1e80] DB of TX timestamp values
	 * NOTE: when using 1G ports, only indices 1-7 can hold legal TS values
	 */
	struct al_ec_pth_db pth_db[16];
	/* [0x2000] */
	uint32_t rsrvd_3[416];
	/* [0x2680] Ethernet ontroller V3 General configuration */
	struct al_ec_gen_v3 gen_v3;
	/* [0x26c0] Tx Forwarding V3 */
	struct al_ec_tfw_v3 tfw_v3;
	/* [0x2740] Rx Forwarding V3 */
	struct al_ec_rfw_v3 rfw_v3;
	/* [0x2840] Inline crypto */
	struct al_ec_crypto crypto;
	/*
	 * [0x28c0] Inline crypto performance counter
	 * Each counter counts the total number of <cntr_measure> that passed through the crypto
	 * engine, using the relevant crypto table entry (mapped through the crypto_table to cntr
	 * map)
	 */
	struct al_ec_crypto_perf_cntr crypto_perf_cntr[2];
	/* [0x2940] */
	uint32_t rsrvd_4[48];
	/* [0x2a00] tid_default_entry */
	struct al_ec_crypto_tx_tid crypto_tx_tid[8];
	/* [0x2a20] */
	uint32_t rsrvd_5[16];
	/* [0x2a60] Remap table of protocol numbers. Map 64 possible protocol numbers to 4. */
	struct al_ec_pn_remap pn_remap;
	/* [0x2a80] TMI Forwarding Table */
	struct al_ec_tmi_fwd_table tmi_fwd_table;
	/* [0x2b00] Rx Forwarding engine, udma selection, port mapping */
	struct al_ec_rfw_v4_udma_select rfw_v4_udma_select[64];
	/* [0x2c00] Rx Forwarding engine V4 */
	struct al_ec_rfw_v4 rfw_v4;
	/* [0x2c10] */
	uint32_t rsrvd_6[28];
	/* [0x2c80] crc parameters */
	struct al_ec_crc crc[4];
	/* [0x3080] crc extended parameters table */
	struct al_ec_crc_extended crc_extended;
	/*
	 * [0x30dc] Outstanding table
	 * 0-2 : Rx instances
	 * 3-4 : Tx instances
	 */
	struct al_ec_outstanding_gen outstanding_gen;
	/* [0x30e0] outstanding tableec */
	struct al_ec_outstanding outstanding[4];
	/* [0x3100] RFF configuration */
	struct al_ec_rff rff;
	/* [0x3108] */
	uint32_t rsrvd_7[62];
	/* [0x3200] rfw protocol_index selection table */
	struct al_ec_rfw_prot_index rfw_prot_index[64];
	/* [0x3600] */
	uint32_t rsrvd_8[268];
	/* [0x3a30] udp len offset table */
	struct al_ec_udp_len udp_len[16];
	/* [0x3a70] udp len insertion */
	struct al_ec_udp_len_insertion udp_len_insertion;
	/* [0x3a84] */
	uint32_t rsrvd_9[127];
	/* [0x3c80] TMI V4 */
	struct al_ec_tmi_v4 tmi_v4;
	/* [0x3c84] */
	uint32_t rsrvd_10[31];
	/* [0x3d00] csd db write credit base */
	struct al_ec_crdt_os2sr_wr crdt_os2sr_wr;
	/* [0x3d08] */
	uint32_t rsrvd_11[94];
	/* [0x3e80] */
	struct al_ec_spare spare[16];
	/* [0x3f00] */
	uint32_t sec_int_ctrl_mem[64];
	/* [0x4000] Rx Multi Parser configuration space */
	uint32_t rmp_cfg[2048];
	/* [0x6000] */
	uint32_t rsrvd_12[2048];
	/* [0x8000] ec pmu configuration space */
	uint32_t pmu_cfg[4096];
	/* [0xc000] */
	uint32_t rsrvd_13[20480];
	/* [0x20000] rfw_shared configuration space */
	uint32_t rfw_shared_cfg[32768];
	/* [0x40000] */
	uint32_t rsrvd_14[196608];
};


/*
 * Registers Fields
 */

/**** version register ****/
/*
 * Revision number (Minor)
 * Reset: 0x1         Access: RO
 */
#define EC_GEN_VERSION_RELEASE_NUM_MINOR_MASK 0x000000FF
#define EC_GEN_VERSION_RELEASE_NUM_MINOR_SHIFT 0
/*
 * Revision number (Major)
 * Reset: 0x1         Access: RO
 */
#define EC_GEN_VERSION_RELEASE_NUM_MAJOR_MASK 0x0000FF00
#define EC_GEN_VERSION_RELEASE_NUM_MAJOR_SHIFT 8
/*
 * Day of release
 * Reset: 0x0         Access: RO
 */
#define EC_GEN_VERSION_DATE_DAY_MASK     0x001F0000
#define EC_GEN_VERSION_DATE_DAY_SHIFT    16
/*
 * Month of release
 * Reset: 0x0         Access: RO
 */
#define EC_GEN_VERSION_DATA_MONTH_MASK   0x01E00000
#define EC_GEN_VERSION_DATA_MONTH_SHIFT  21
/*
 * Year of release (starting from 2000)
 * Reset: 0x0         Access: RO
 */
#define EC_GEN_VERSION_DATE_YEAR_MASK    0x3E000000
#define EC_GEN_VERSION_DATE_YEAR_SHIFT   25
/*
 * Reserved
 * Reset: 0x0         Access: RO
 */
#define EC_GEN_VERSION_RESERVED_MASK     0xC0000000
#define EC_GEN_VERSION_RESERVED_SHIFT    30

/**** en register ****/
/*
 * Enable Frequency adjust FIFO input controller operation.
 * Reset: 0x1         Access: RW
 */
#define EC_GEN_EN_FAF_IN                 (1 << 0)
/*
 * Enable Frequency adjust FIFO output controller operation.
 * Reset: 0x1         Access: RW
 */
#define EC_GEN_EN_FAF_OUT                (1 << 1)
/*
 * Enable Rx FIFO input controller 1 operation.
 * Reset: 0x1         Access: RW
 */
#define EC_GEN_EN_RXF_IN                 (1 << 2)
/*
 * Enable Rx FIFO output controller operation.
 * Reset: 0x1         Access: RW
 */
#define EC_GEN_EN_RXF_OUT                (1 << 3)
/*
 * Enable Rx forwarding input controller operation.
 * Reset: 0x1         Access: RW
 */
#define EC_GEN_EN_RFW_IN                 (1 << 4)
/*
 * Enable Rx forwarding output controller operation.
 * Reset: 0x1         Access: RW
 */
#define EC_GEN_EN_RFW_OUT                (1 << 5)
/*
 * Enable Rx multi-stream write controller operation.
 * Reset: 0x1         Access: RW
 */
#define EC_GEN_EN_MSW_IN                 (1 << 6)
/*
 * Enable Rx first parsing engine output operation.
 * Reset: 0x1         Access: RW
 */
#define EC_GEN_EN_RPE_1_OUT              (1 << 7)
/*
 * Enable Rx first parsing engine input operation.
 * Reset: 0x1         Access: RW
 */
#define EC_GEN_EN_RPE_1_IN               (1 << 8)
/*
 * Enable Rx second parsing engine output operation.
 * Reset: 0x1         Access: RW
 */
#define EC_GEN_EN_RPE_2_OUT              (1 << 9)
/*
 * Enable Rx second parsing engine input operation.
 * Reset: 0x1         Access: RW
 */
#define EC_GEN_EN_RPE_2_IN               (1 << 10)
/*
 * Enable Rx MACsec parsing engine output operation.
 * Reset: 0x1         Access: RW
 */
#define EC_GEN_EN_RPE_3_OUT              (1 << 11)
/*
 * Enable Rx MACsec parsing engine input operation.
 * Reset: 0x1         Access: RW
 */
#define EC_GEN_EN_RPE_3_IN               (1 << 12)
/*
 * Enable Loopback FIFO input controller 1 operation.
 * Reset: 0x1         Access: RW
 */
#define EC_GEN_EN_LBF_IN                 (1 << 13)
/*
 * Enable Rx packet analyzer operation.
 * Reset: 0x1         Access: RW
 */
#define EC_GEN_EN_RPA                    (1 << 14)
/*
 * Enable Rx Multi Parsers operation
 * Reset: 0x1         Access: RW
 */
#define EC_GEN_EN_RMP                    (1 << 15)
/*
 * Enable Tx stream interface operation.
 * Reset: 0x1         Access: RW
 */
#define EC_GEN_EN_TSO                    (1 << 16)
/*
 * Enable Tx parser input controller operation.
 * Reset: 0x1         Access: RW
 */
#define EC_GEN_EN_TPE_IN                 (1 << 17)
/*
 * Enable Tx parser output controller operation.
 * Reset: 0x1         Access: RW
 */
#define EC_GEN_EN_TPE_OUT                (1 << 18)
/*
 * Enable Tx packet modification operation.
 * Reset: 0x1         Access: RW
 */
#define EC_GEN_EN_TPM                    (1 << 19)
/*
 * Enable Tx forwarding input controller operation.
 * Reset: 0x1         Access: RW
 */
#define EC_GEN_EN_TFW_IN                 (1 << 20)
/*
 * Enable Tx forwarding output controller operation.
 * Reset: 0x1         Access: RW
 */
#define EC_GEN_EN_TFW_OUT                (1 << 21)
/*
 * Enable Tx MAC interface controller operation.
 * Reset: 0x1         Access: RW
 */
#define EC_GEN_EN_TMI                    (1 << 22)
/*
 * Enable Tx packet generator operation.
 * Reset: 0x1         Access: RW
 */
#define EC_GEN_EN_TPG                    (1 << 23)
/* Reset: 0x0         Access: RW */
#define EC_GEN_EN_RESERVED_31_MASK       0xFF000000
#define EC_GEN_EN_RESERVED_31_SHIFT      24

/**** fifo_en register ****/
/*
 * Enable Frequency adjust FIFO operation (input).
 * Reset: 0x1         Access: RW
 */
#define EC_GEN_FIFO_EN_FAF_IN            (1 << 0)
/*
 * Enable Frequency adjust FIFO operation (output).
 * Reset: 0x1         Access: RW
 */
#define EC_GEN_FIFO_EN_FAF_OUT           (1 << 1)
/*
 * Enable Rx FIFO operation.
 * Reset: 0x1         Access: RW
 */
#define EC_GEN_FIFO_EN_RX_FIFO           (1 << 2)
/*
 * Enable Rx forwarding FIFO operation.
 * Reset: 0x1         Access: RW
 */
#define EC_GEN_FIFO_EN_RFW_FIFO          (1 << 3)
/*
 * Enable Rx multi-stream write FIFO operation
 * Reset: 0x1         Access: RW
 */
#define EC_GEN_FIFO_EN_MSW_FIFO          (1 << 4)
/*
 * Enable Rx first parser FIFO operation.
 * Reset: 0x1         Access: RW
 */
#define EC_GEN_FIFO_EN_RPE_1_FIFO        (1 << 5)
/*
 * Enable Rx second parser FIFO operation.
 * Reset: 0x1         Access: RW
 */
#define EC_GEN_FIFO_EN_RPE_2_FIFO        (1 << 6)
/*
 * Enable Rx MACsec parser FIFO operation.
 * Reset: 0x1         Access: RW
 */
#define EC_GEN_FIFO_EN_RPE_3_FIFO        (1 << 7)
/*
 * Enable Loopback FIFO operation.
 * Reset: 0x1         Access: RW
 */
#define EC_GEN_FIFO_EN_LB_FIFO           (1 << 8)
/* Reset: 0x0         Access: RW */
#define EC_GEN_FIFO_EN_RESERVED_15_9_MASK 0x0000FE00
#define EC_GEN_FIFO_EN_RESERVED_15_9_SHIFT 9
/*
 * Enable Tx parser FIFO operation.
 * Reset: 0x1         Access: RW
 */
#define EC_GEN_FIFO_EN_TPE_FIFO          (1 << 16)
/*
 * Enable Tx forwarding FIFO operation.
 * Reset: 0x1         Access: RW
 */
#define EC_GEN_FIFO_EN_TFW_FIFO          (1 << 17)
/* Reset: 0x0         Access: RW */
#define EC_GEN_FIFO_EN_RESERVED_31_18_MASK 0xFFFC0000
#define EC_GEN_FIFO_EN_RESERVED_31_18_SHIFT 18

/**** l2 register ****/
/*
 * Size of a 802.3 Ethernet header (DA+SA)
 * Reset: 0xc         Access: RW
 */
#define EC_GEN_L2_SIZE_802_3_MASK        0x0000003F
#define EC_GEN_L2_SIZE_802_3_SHIFT       0
/*
 * Size of a 802.3 + MACsec 8 byte header
 * Reset: 0xc         Access: RW
 */
#define EC_GEN_L2_SIZE_802_3_MS_8_MASK   0x00003F00
#define EC_GEN_L2_SIZE_802_3_MS_8_SHIFT  8
/*
 * Offset of the L2 header from the beginning of the packet.
 * Reset: 0x0         Access: RW
 */
#define EC_GEN_L2_OFFSET_MASK            0x7F000000
#define EC_GEN_L2_OFFSET_SHIFT           24

/**** cfg_i register ****/
/*
 * IPv4 protocol index
 * Reset: 0x8         Access: RW
 */
#define EC_GEN_CFG_I_IPV4_INDEX_MASK     0x0000001F
#define EC_GEN_CFG_I_IPV4_INDEX_SHIFT    0
/*
 * IPv6 protocol index
 * Reset: 0xb         Access: RW
 */
#define EC_GEN_CFG_I_IPV6_INDEX_MASK     0x000003E0
#define EC_GEN_CFG_I_IPV6_INDEX_SHIFT    5
/*
 * TCP protocol index
 * Reset: 0xc         Access: RW
 */
#define EC_GEN_CFG_I_TCP_INDEX_MASK      0x00007C00
#define EC_GEN_CFG_I_TCP_INDEX_SHIFT     10
/*
 * UDP protocol index
 * Reset: 0xd         Access: RW
 */
#define EC_GEN_CFG_I_UDP_INDEX_MASK      0x000F8000
#define EC_GEN_CFG_I_UDP_INDEX_SHIFT     15
/*
 * MACsec with 8 bytes SecTAG
 * Reset: 0x2         Access: RW
 */
#define EC_GEN_CFG_I_MACSEC_8_INDEX_MASK 0x01F00000
#define EC_GEN_CFG_I_MACSEC_8_INDEX_SHIFT 20
/*
 * MACsec with 16 bytes SecTAG
 * Reset: 0x3         Access: RW
 */
#define EC_GEN_CFG_I_MACSEC_16_INDEX_MASK 0x3E000000
#define EC_GEN_CFG_I_MACSEC_16_INDEX_SHIFT 25

/**** cfg_i_ext register ****/
/*
 * FcoE protocol index
 * Reset: 0x15        Access: RW
 */
#define EC_GEN_CFG_I_EXT_FCOE_INDEX_MASK 0x0000001F
#define EC_GEN_CFG_I_EXT_FCOE_INDEX_SHIFT 0
/*
 * RoCE protocol index
 * Reset: 0x16        Access: RW
 */
#define EC_GEN_CFG_I_EXT_ROCE_INDEX_L3_1_MASK 0x000003E0
#define EC_GEN_CFG_I_EXT_ROCE_INDEX_L3_1_SHIFT 5
/*
 * RoCE protocol index
 * Reset: 0xb         Access: RW
 */
#define EC_GEN_CFG_I_EXT_ROCE_INDEX_L3_2_MASK 0x00007C00
#define EC_GEN_CFG_I_EXT_ROCE_INDEX_L3_2_SHIFT 10
/*
 * RoCE protocol index
 * Reset: 0x17        Access: RW
 */
#define EC_GEN_CFG_I_EXT_ROCE_INDEX_L4_MASK 0x000F8000
#define EC_GEN_CFG_I_EXT_ROCE_INDEX_L4_SHIFT 15

/**** en_ext register ****/
/*
 * Enable Usage of Ethernet port memories for testing. (NON-Operational mode)
 * 0xA --> Activates the test mode
 * Reset: 0x0         Access: RW
 */
#define EC_GEN_EN_EXT_MEM_FOR_TEST_MASK  0x0000000F
#define EC_GEN_EN_EXT_MEM_FOR_TEST_SHIFT 0
/*
 * Enable MAC loopback (Rx --> Tx, after MAC layer) for 802.3ah OAM
 * Reset: 0x0         Access: RW
 */
#define EC_GEN_EN_EXT_MAC_LB             (1 << 4)
/*
 * CRC forward value for the MAC Tx when working in loopback mode.
 * Reset: 0x0         Access: RW
 */
#define EC_GEN_EN_EXT_MAC_LB_CRC_FWD     (1 << 5)
/*
 * Ready signal configuration when in loopback mode:
 * 00 - Ready from the Ethernet controller Rx
 * 01 -Ready is logic AND between Ethernet controller Rx and MAC Rx (for loopback)
 * 10 - Ready is always '0'.
 * 11 - Ready is always '1'.
 * Reset: 0x0         Access: RW
 */
#define EC_GEN_EN_EXT_MAC_LB_READY_CFG_MASK 0x000000C0
#define EC_GEN_EN_EXT_MAC_LB_READY_CFG_SHIFT 6
/*
 * Bypass the PTH completion update.
 * Reset: 0x1         Access: RW
 */
#define EC_GEN_EN_EXT_PTH_COMPLETION_BYPASS (1 << 16)
/*
 * Selection between the 1G and 10G MAC:
 * 0 - 1G
 * 1 - 10G
 * Reset: 0x0         Access: RW
 */
#define EC_GEN_EN_EXT_PTH_1_10_SEL       (1 << 17)
/*
 * avoid timestamping every pkt in 1G
 * Reset: 0x1         Access: RW
 */
#define EC_GEN_EN_EXT_PTH_CFG_1G_TIMESTAMP_OPT (1 << 18)
/*
 * Selection between descriptor caching options (WORD selection)
 * 0 - M0 descriptor format
 * 1 - A0 descriptor format
 * Reset: 0x0         Access: RW
 */
#define EC_GEN_EN_EXT_CACHE_WORD_SPLIT   (1 << 20)

/**** mem_init register ****/
/* Reset: 0x1         Access: RW */
#define EC_GEN_MEM_INIT_TRIG_TFW_DATA_FIFO (1 << 0)
/* Reset: 0x1         Access: RW */
#define EC_GEN_MEM_INIT_TRIG_TFW_SOP_FIFO (1 << 1)
/* Reset: 0x1         Access: RW */
#define EC_GEN_MEM_INIT_TRIG_TFW_EOP_FIFO (1 << 2)
/* Reset: 0x0         Access: RW */
#define EC_GEN_MEM_INIT_TRIG_TFW_CSP_PN_MAP_TABLE (1 << 3)
/* Reset: 0x0         Access: RW */
#define EC_GEN_MEM_INIT_TRIG_TFW_CRC_PROTOCOL_CONTROL_TABLE (1 << 4)
/* Reset: 0x0         Access: RW */
#define EC_GEN_MEM_INIT_TRIG_RFW_THASH_TABLE (1 << 7)
/* Reset: 0x0         Access: RW */
#define EC_GEN_MEM_INIT_TRIG_RFW_MHASH_TABLE (1 << 8)
/* Reset: 0x0         Access: RW */
#define EC_GEN_MEM_INIT_TRIG_RFW_VLAN_TABLE (1 << 9)
/* Reset: 0x0         Access: RW */
#define EC_GEN_MEM_INIT_TRIG_RFW_CTRL_TABLE (1 << 10)
/* Reset: 0x1         Access: RW */
#define EC_GEN_MEM_INIT_TRIG_TSO_META_DATA_CACHE (1 << 11)
/* Reset: 0x1         Access: RW */
#define EC_GEN_MEM_INIT_TRIG_RFW_HS_CTRL_TABLE (1 << 12)
/* Reset: 0x0         Access: RW */
#define EC_GEN_MEM_INIT_TRIG_RFW_GCP_TABLE (1 << 13)
/* Reset: 0x0         Access: RW */
#define EC_GEN_MEM_INIT_TRIG_TFW_GCP_TABLE (1 << 14)
/* Reset: 0x0         Access: RW */
#define EC_GEN_MEM_INIT_TRIG_TFW_VLAN_TABLE (1 << 15)
/* Reset: 0x1         Access: RW */
#define EC_GEN_MEM_INIT_TRIG_RFW_PKT_HDR_FIFO (1 << 16)
/* Reset: 0x1         Access: RW */
#define EC_GEN_MEM_INIT_TRIG_RFW_META_FIFO (1 << 17)
/* Reset: 0x1         Access: RW */
#define EC_GEN_MEM_INIT_TRIG_RFW_DATA_FIFO (1 << 18)
/* Reset: 0x1         Access: RW */
#define EC_GEN_MEM_INIT_TRIG_RFF_RFW_SR_RESULT_FIFO (1 << 19)
/* Reset: 0x1         Access: RW */
#define EC_GEN_MEM_INIT_TRIG_RFF_PARSE_RES_FIFO (1 << 20)
/* Reset: 0x1         Access: RW */
#define EC_GEN_MEM_INIT_TRIG_RFF_DATA_FIFO (1 << 21)
/* Reset: 0x1         Access: RW */
#define EC_GEN_MEM_INIT_TRIG_RFW_IN_PIPE_DATA_FIFO (1 << 22)
/* Reset: 0x0         Access: RW */
#define EC_GEN_MEM_INIT_TRIG_RFW_CRC_PROTOCOL_CONTROL_TABLE (1 << 23)

/**** sw_reset register ****/
/*
 * rmp sw reset
 * Reset: 0x0         Access: RW
 */
#define EC_GEN_SW_RESET_RMP              (1 << 0)
/*
 * rdma sw reset
 * Reset: 0x0         Access: RW
 */
#define EC_GEN_SW_RESET_RDMA             (1 << 1)

/**** gen register ****/
/*
 * Enable swap of input byte order
 * Reset: 0x1         Access: RW
 */
#define EC_MAC_GEN_SWAP_IN_BYTE          (1 << 0)

/**** min_pkt register ****/
/*
 * Minimum packet size
 * Reset: 0x30        Access: RW
 */
#define EC_MAC_MIN_PKT_SIZE_MASK         0x000FFFFF
#define EC_MAC_MIN_PKT_SIZE_SHIFT        0

/**** max_pkt register ****/
/*
 * Maximum packet size
 * Reset: 0x1000      Access: RW
 */
#define EC_MAC_MAX_PKT_SIZE_MASK         0x000FFFFF
#define EC_MAC_MAX_PKT_SIZE_SHIFT        0

/**** cfg_1 register ****/
/*
 * Drop packet at the ingress
 * 0 - Packets are not dropped at the ingress of the Rx FIFO. Backpressure is applied to the
 * frequency adjust FIFO when the Rx FIFO is FULL.
 * 1 - Packets are dropped at the ingress to the Rx FIFO when the FIFO is full.
 * Reset: 0x0         Access: RW
 */
#define EC_RXF_CFG_1_DROP_AT_INGRESS     (1 << 0)
/*
 * Accept packet criteria at start of packet indication.
 * 0 - Use cfg_2_fifo_used_th_l as threshold.
 * 1 - Use hysteresis between cfg_2_fifo_used_th_l and cfg_2_fifo_used_th_h.
 * Reset: 0x1         Access: RW
 */
#define EC_RXF_CFG_1_SOP_ACCEPT          (1 << 1)
/*
 * Select the arbiter between Rx packets and Tx packets (packets coming from the Tx data path)
 * 0 - RR
 * 1 - strict
 * Reset: 0x1         Access: RW
 */
#define EC_RXF_CFG_1_ARB_SEL             (1 << 2)
/*
 * Arbiter priority when strict priority is selected in arb_sel
 * 0 - Input 0 is high priority.
 * 1 - Input 1 is high priority.
 * Reset: 0x1         Access: RW
 */
#define EC_RXF_CFG_1_ARB_P               (1 << 3)
/*
 * Force loopback operation
 * Reset: 0x0         Access: RW
 */
#define EC_RXF_CFG_1_FORCE_LB            (1 << 4)
/*
 * Forwarding selection between Rx path and/or packet analyzer.
 * 00 - Rx path only
 * 01 - Packet analyzer only
 * 10 - Both Rx path and packet analyzer
 * 11 - N/A
 * Reset: 0x0         Access: RW
 */
#define EC_RXF_CFG_1_FWD_SEL_MASK        0x00000300
#define EC_RXF_CFG_1_FWD_SEL_SHIFT       8

/**** cfg_2 register ****/
/*
 * FIFO USED threshold for accepting new packets, low threshold
 * Reset: 0x244       Access: RW
 */
#define EC_RXF_CFG_2_FIFO_USED_TH_L_MASK 0x0000FFFF
#define EC_RXF_CFG_2_FIFO_USED_TH_L_SHIFT 0
/*
 * FIFO USED threshold for accepting new packets, high threshold
 * Reset: 0x258       Access: RW
 */
#define EC_RXF_CFG_2_FIFO_USED_TH_H_MASK 0xFFFF0000
#define EC_RXF_CFG_2_FIFO_USED_TH_H_SHIFT 16

/**** rd_fifo register ****/
/*
 * Minimum number of entries in the data FIFO to start reading packet
 * Reset: 0x1         Access: RW
 */
#define EC_RXF_RD_FIFO_TH_DATA_MASK      0x0000FFFF
#define EC_RXF_RD_FIFO_TH_DATA_SHIFT     0
/*
 * Enable cut through operation
 * Reset: 0x3         Access: RW
 */
#define EC_RXF_RD_FIFO_EN_CUT_TH_MASK    0x00030000
#define EC_RXF_RD_FIFO_EN_CUT_TH_SHIFT   16

/**** wr_fifo register ****/
/* Reset: 0x258       Access: RW */
#define EC_RXF_WR_FIFO_TH_DATA_MASK      0x0000FFFF
#define EC_RXF_WR_FIFO_TH_DATA_SHIFT     0
/* Reset: 0x78        Access: RW */
#define EC_RXF_WR_FIFO_TH_INFO_MASK      0xFFFF0000
#define EC_RXF_WR_FIFO_TH_INFO_SHIFT     16

/**** lb_fifo register ****/
/* Reset: 0x258       Access: RW */
#define EC_RXF_LB_FIFO_TH_DATA_MASK      0x0000FFFF
#define EC_RXF_LB_FIFO_TH_DATA_SHIFT     0
/* Reset: 0x78        Access: RW */
#define EC_RXF_LB_FIFO_TH_INFO_MASK      0xFFFF0000
#define EC_RXF_LB_FIFO_TH_INFO_SHIFT     16

/**** cfg_lb register ****/
/*
 * FIFO USED threshold for accepting new packets
 * Reset: 0x258       Access: RW
 */
#define EC_RXF_CFG_LB_FIFO_USED_TH_INT_MASK 0x0000FFFF
#define EC_RXF_CFG_LB_FIFO_USED_TH_INT_SHIFT 0
/*
 * FIFO USED threshold for generating ready for the Tx path
 * Reset: 0x46        Access: RW
 */
#define EC_RXF_CFG_LB_FIFO_USED_TH_EXT_MASK 0xFFFF0000
#define EC_RXF_CFG_LB_FIFO_USED_TH_EXT_SHIFT 16

/**** out_drop register ****/
/* Reset: 0x0         Access: RW */
#define EC_RXF_OUT_DROP_MAC_ERR          (1 << 0)
/* Reset: 0x0         Access: RW */
#define EC_RXF_OUT_DROP_MAC_COL          (1 << 1)
/* Reset: 0x0         Access: RW */
#define EC_RXF_OUT_DROP_MAC_DEC          (1 << 2)
/* Reset: 0x0         Access: RW */
#define EC_RXF_OUT_DROP_MAC_LEN          (1 << 3)
/* Reset: 0x0         Access: RW */
#define EC_RXF_OUT_DROP_MAC_PHY          (1 << 4)
/* Reset: 0x0         Access: RW */
#define EC_RXF_OUT_DROP_MAC_FIFO         (1 << 5)
/* Reset: 0x0         Access: RW */
#define EC_RXF_OUT_DROP_MAC_FCS          (1 << 6)
/* Reset: 0x0         Access: RW */
#define EC_RXF_OUT_DROP_MAC_ETYPE        (1 << 7)
/* Reset: 0x0         Access: RW */
#define EC_RXF_OUT_DROP_EC_LEN           (1 << 8)
/* Reset: 0x0         Access: RW */
#define EC_RXF_OUT_DROP_EC_FIFO          (1 << 9)

/**** data register ****/
/* Reset: 0x0         Access: RO */
#define EC_RXF_DATA_FIFO_1_DEPTH_EXPOSE_MASK 0x0000FFFF
#define EC_RXF_DATA_FIFO_1_DEPTH_EXPOSE_SHIFT 0
/* Reset: 0x0         Access: RO */
#define EC_RXF_DATA_FIFO_2_DEPTH_EXPOSE_MASK 0xFFFF0000
#define EC_RXF_DATA_FIFO_2_DEPTH_EXPOSE_SHIFT 16

/**** info register ****/
/* Reset: 0x0         Access: RO */
#define EC_RXF_INFO_FIFO_1_DEPTH_EXPOSE_MASK 0x00003FFF
#define EC_RXF_INFO_FIFO_1_DEPTH_EXPOSE_SHIFT 0
/* Reset: 0x0         Access: RO */
#define EC_RXF_INFO_FIFO_2_DEPTH_EXPOSE_MASK 0x3FFF0000
#define EC_RXF_INFO_FIFO_2_DEPTH_EXPOSE_SHIFT 16

/**** parse_cfg register ****/
/*
 * MAX number of beats for packet parsing
 * Reset: 0x8         Access: RW
 */
#define EC_EPE_PARSE_CFG_MAX_BEATS_MASK  0x000000FF
#define EC_EPE_PARSE_CFG_MAX_BEATS_SHIFT 0
/*
 * MAX number of parsing iterations for packet parsing
 * Reset: 0x8         Access: RW
 */
#define EC_EPE_PARSE_CFG_MAX_ITER_MASK   0x0000FF00
#define EC_EPE_PARSE_CFG_MAX_ITER_SHIFT  8

/**** act_table_addr register ****/
/*
 * Address for accessing the table
 * Reset: 0x1         Access: RW
 */
#define EC_EPE_ACT_TABLE_ADDR_VAL_MASK   0x0000001F
#define EC_EPE_ACT_TABLE_ADDR_VAL_SHIFT  0

/**** act_table_data_1 register ****/
/*
 * Table data
 * [5:0] - Offset to next protocol [bytes]
 * [6] - Next protocol is available in packet data
 * [11:7] - Default next protocol index
 * [12] - Write the detected protocol index into the parser result vector
 * [22:13] - Pointer where to write the detected protocol index in the parser result vector
 * [23] - Select which prot_index to write (0 - next, 1 - current)
 * [24] - Select which header length to write (0 - next, 1 - current)
 * [25] - Select which header offset to write (0 - next, 1 - current)
 * Reset: 0x1         Access: RW
 */
#define EC_EPE_ACT_TABLE_DATA_1_VAL_MASK 0x03FFFFFF
#define EC_EPE_ACT_TABLE_DATA_1_VAL_SHIFT 0

/**** act_table_data_2 register ****/
/*
 * Table Data
 * [8:0] - Offset to data in the packet [bits]
 * [17:9] - Data size [bits]
 * [18] - Write the data to the parser result vector
 * [28:19] - Pointer where to write the data in the parser result vector [bits]
 * Reset: 0x1         Access: RW
 */
#define EC_EPE_ACT_TABLE_DATA_2_VAL_MASK 0x1FFFFFFF
#define EC_EPE_ACT_TABLE_DATA_2_VAL_SHIFT 0

/**** act_table_data_3 register ****/
/*
 * Table Data
 *  [8:0] - Offset to data in the packet [bits]
 * [17:9] - Data size [bits]
 * [18] - Write the data to the parser result vector
 * [28:19] - Pointer where to write the data in the parser result vector [bits]
 * Reset: 0x1         Access: RW
 */
#define EC_EPE_ACT_TABLE_DATA_3_VAL_MASK 0x1FFFFFFF
#define EC_EPE_ACT_TABLE_DATA_3_VAL_SHIFT 0

/**** act_table_data_4 register ****/
/*
 * Table data
 * [7:0] - Offset to header length location in the packet [bits]
 * [12:8] - Header length size [bits
 * [15:13] - Header length units (bit shift)
 * [19:16] - Header length command
 * [27:20] - Default header length
 * Reset: 0x1         Access: RW
 */
#define EC_EPE_ACT_TABLE_DATA_4_VAL_MASK 0x0FFFFFFF
#define EC_EPE_ACT_TABLE_DATA_4_VAL_SHIFT 0

/**** act_table_data_6 register ****/
/*
 * Table data
 * [0] - WR header length
 * [10:1] - Write header length pointer (write 9 bits)
 * [11] - Write current packet offset
 * [21:12] - Write packet offset pointer (write 9 bits)
 * [22] - Input parse enable field for next parser
 * Reset: 0x1         Access: RW
 */
#define EC_EPE_ACT_TABLE_DATA_6_VAL_MASK 0x007FFFFF
#define EC_EPE_ACT_TABLE_DATA_6_VAL_SHIFT 0

/**** res_in register ****/
/*
 * Selector for input parse_en
 * 0 - Input vector
 * 1 - Default value form res_def register
 * Reset: 0x1         Access: RW
 */
#define EC_EPE_RES_IN_SEL_PARSE_EN       (1 << 0)
/*
 * Selector for input protocol_index
 * 0 - Input vector
 * 1 - Default value form res_def register
 * Reset: 0x1         Access: RW
 */
#define EC_EPE_RES_IN_SEL_PROT_INDEX     (1 << 1)
/*
 * Selector for input hdr_offset
 * 0 - Input vector
 * 1 - Default value form res_def register
 * Reset: 0x1         Access: RW
 */
#define EC_EPE_RES_IN_SEL_HDR_OFFSET     (1 << 2)

/**** p1 register ****/
/*
 * Location of the input protocol index in the parser result vector
 * Reset: 0x0         Access: RW
 */
#define EC_EPE_RES_P1_IN_PROT_INDEX_MASK 0x000003FF
#define EC_EPE_RES_P1_IN_PROT_INDEX_SHIFT 0

/**** p2 register ****/
/*
 * Location of the input offset in the parser result vector
 * Reset: 0x1         Access: RW
 */
#define EC_EPE_RES_P2_IN_OFFSET_MASK     0x000003FF
#define EC_EPE_RES_P2_IN_OFFSET_SHIFT    0

/**** p3 register ****/
/*
 * Location of the input parse enable in the parser result vector
 * Reset: 0x3         Access: RW
 */
#define EC_EPE_RES_P3_IN_PARSE_EN_MASK   0x000003FF
#define EC_EPE_RES_P3_IN_PARSE_EN_SHIFT  0

/**** p4 register ****/
/*
 * Location of the control bits in the parser result vector
 * Reset: 0x4         Access: RW
 */
#define EC_EPE_RES_P4_CTRL_BITS_MASK     0x000003FF
#define EC_EPE_RES_P4_CTRL_BITS_SHIFT    0

/**** p5 register ****/
/*
 * Location of the MAC DA in the parser result vector
 * Reset: 0xe         Access: RW
 */
#define EC_EPE_RES_P5_DA_MASK            0x000003FF
#define EC_EPE_RES_P5_DA_SHIFT           0

/**** p6 register ****/
/*
 * Location of the MAC SA in the parser result vector
 * Reset: 0x14        Access: RW
 */
#define EC_EPE_RES_P6_SA_MASK            0x000003FF
#define EC_EPE_RES_P6_SA_SHIFT           0

/**** p7 register ****/
/*
 * Location of the first VLAN in the parser result vector
 * Reset: 0x1a        Access: RW
 */
#define EC_EPE_RES_P7_VLAN_1_MASK        0x000003FF
#define EC_EPE_RES_P7_VLAN_1_SHIFT       0

/**** p8 register ****/
/*
 * Location of the second VLAN in the parser result vector
 * Reset: 0x1c        Access: RW
 */
#define EC_EPE_RES_P8_VLAN_2_MASK        0x000003FF
#define EC_EPE_RES_P8_VLAN_2_SHIFT       0

/**** p9 register ****/
/*
 * Location of the L3 protocol index in the parser result vector
 * Reset: 0x5         Access: RW
 */
#define EC_EPE_RES_P9_L3_PROT_INDEX_MASK 0x000003FF
#define EC_EPE_RES_P9_L3_PROT_INDEX_SHIFT 0

/**** p10 register ****/
/*
 * Location of the L3 offset in the parser result vector
 * Reset: 0x6         Access: RW
 */
#define EC_EPE_RES_P10_L3_OFFSET_MASK    0x000003FF
#define EC_EPE_RES_P10_L3_OFFSET_SHIFT   0

/**** p11 register ****/
/*
 * Location of the L3 SIP in the parser result vector
 * Reset: 0x1e        Access: RW
 */
#define EC_EPE_RES_P11_L3_SIP_MASK       0x000003FF
#define EC_EPE_RES_P11_L3_SIP_SHIFT      0

/**** p12 register ****/
/*
 * Location of the L3 DIP in the parser result vector
 * Reset: 0x2e        Access: RW
 */
#define EC_EPE_RES_P12_L3_DIP_MASK       0x000003FF
#define EC_EPE_RES_P12_L3_DIP_SHIFT      0

/**** p13 register ****/
/*
 * Location of the L3 priority in the parser result vector
 * Reset: 0xd         Access: RW
 */
#define EC_EPE_RES_P13_L3_PRIORITY_MASK  0x000003FF
#define EC_EPE_RES_P13_L3_PRIORITY_SHIFT 0

/**** p14 register ****/
/*
 * Location of the L3 header length in the parser result vector
 * Reset: 0x8         Access: RW
 */
#define EC_EPE_RES_P14_L3_HDR_LEN_MASK   0x000003FF
#define EC_EPE_RES_P14_L3_HDR_LEN_SHIFT  0

/**** p15 register ****/
/*
 * Location of the L4 protocol index in the parser result vector
 * Reset: 0xa         Access: RW
 */
#define EC_EPE_RES_P15_L4_PROT_INDEX_MASK 0x000003FF
#define EC_EPE_RES_P15_L4_PROT_INDEX_SHIFT 0

/**** p16 register ****/
/*
 * Location of the L4 source port in the parser result vector
 * Reset: 0x3e        Access: RW
 */
#define EC_EPE_RES_P16_L4_SRC_PORT_MASK  0x000003FF
#define EC_EPE_RES_P16_L4_SRC_PORT_SHIFT 0

/**** p17 register ****/
/*
 * Location of the L4 destination port in the parser result vector
 * Reset: 0x40        Access: RW
 */
#define EC_EPE_RES_P17_L4_DST_PORT_MASK  0x000003FF
#define EC_EPE_RES_P17_L4_DST_PORT_SHIFT 0

/**** p18 register ****/
/*
 * Location of the L4 offset in the parser result vector
 * Reset: 0xb         Access: RW
 */
#define EC_EPE_RES_P18_L4_OFFSET_MASK    0x000003FF
#define EC_EPE_RES_P18_L4_OFFSET_SHIFT   0

/**** p19 register ****/
/*
 * Location of the Ether type in the parser result vector when working in WoL mode
 * Reset: 0x40        Access: RW
 */
#define EC_EPE_RES_P19_WOL_ETYPE_MASK    0x000003FF
#define EC_EPE_RES_P19_WOL_ETYPE_SHIFT   0

/**** p20 register ****/
/*
 * Location of the RoCE QP number field in the parser result vector
 * Reset: 0x3e        Access: RW
 */
#define EC_EPE_RES_P20_ROCE_QPN_MASK     0x000003FF
#define EC_EPE_RES_P20_ROCE_QPN_SHIFT    0

/**** p21 register ****/
/*
 * Location of the control bits2 in the parser result vector
 * Reset: 0x0         Access: RW
 */
#define EC_EPE_RES_P21_CTRL_BITS2_MASK   0x000003FF
#define EC_EPE_RES_P21_CTRL_BITS2_SHIFT  0

/**** p22 register ****/
/*
 * Location of the L4 header length in the parser result vector
 * Reset: 0x44        Access: RW
 */
#define EC_EPE_RES_P22_L4_HDR_LEN_MASK   0x000003FF
#define EC_EPE_RES_P22_L4_HDR_LEN_SHIFT  0

/**** hdr_len register ****/
/*
 * Value for selecting table 1
 * Reset: 0x0         Access: RW
 */
#define EC_EPE_H_HDR_LEN_TABLE_1_MASK    0x000000FF
#define EC_EPE_H_HDR_LEN_TABLE_1_SHIFT   0
/*
 * Value for selecting table 2
 * Reset: 0x0         Access: RW
 */
#define EC_EPE_H_HDR_LEN_TABLE_2_MASK    0x00FF0000
#define EC_EPE_H_HDR_LEN_TABLE_2_SHIFT   16

/**** comp_data register ****/
/*
 * Data 1 for comparison
 * Reset: 0x0         Access: RW
 */
#define EC_EPE_P_COMP_DATA_DATA_1_MASK   0x0000FFFF
#define EC_EPE_P_COMP_DATA_DATA_1_SHIFT  0
/*
 * Data 2 for comparison
 * [18:16] - Stage
 * [24:19] - Branch ID
 * Reset: 0x0         Access: RW
 */
#define EC_EPE_P_COMP_DATA_DATA_2_MASK   0x01FF0000
#define EC_EPE_P_COMP_DATA_DATA_2_SHIFT  16

/**** comp_mask register ****/
/*
 * Data 1 for comparison
 * Reset: 0x0         Access: RW
 */
#define EC_EPE_P_COMP_MASK_DATA_1_MASK   0x0000FFFF
#define EC_EPE_P_COMP_MASK_DATA_1_SHIFT  0
/*
 * Data 2 for comparison
 * [18:16] - Stage
 * [24:19] - Branch ID
 * Reset: 0x0         Access: RW
 */
#define EC_EPE_P_COMP_MASK_DATA_2_MASK   0x01FF0000
#define EC_EPE_P_COMP_MASK_DATA_2_SHIFT  16

/**** comp_ctrl register ****/
/*
 * Output result value
 * Reset: 0x0         Access: RW
 */
#define EC_EPE_P_COMP_CTRL_RES_MASK      0x0000001F
#define EC_EPE_P_COMP_CTRL_RES_SHIFT     0
/*
 * Compare command for the data_1 field
 * 00 - Compare
 * 01 - <=
 * 10 - >=
 * 11 - N/A
 * Reset: 0x0         Access: RW
 */
#define EC_EPE_P_COMP_CTRL_CMD_1_MASK    0x00030000
#define EC_EPE_P_COMP_CTRL_CMD_1_SHIFT   16
/*
 * Compare command for the data_2 field
 * 00 - Compare
 * 01 - <=
 * 10 - >=
 * 11 - N/A
 * Reset: 0x0         Access: RW
 */
#define EC_EPE_P_COMP_CTRL_CMD_2_MASK    0x000C0000
#define EC_EPE_P_COMP_CTRL_CMD_2_SHIFT   18
/*
 * Entry is valid
 * Reset: 0x0         Access: RW
 */
#define EC_EPE_P_COMP_CTRL_VALID         (1 << 31)

/**** prot_act register ****/
/*
 * Drop indication for the selected protocol index
 * Reset: 0x0         Access: RW
 */
#define EC_EPE_A_PROT_ACT_DROP           (1 << 0)
/*
 * Mapping value
 * Used when mapping the entire protocol index range into a smaller range (for example in the
 * forwarding control table input)
 * Reset: 0x0         Access: RW
 */
#define EC_EPE_A_PROT_ACT_MAP_MASK       0x00000F00
#define EC_EPE_A_PROT_ACT_MAP_SHIFT      8

/**** thash_cfg_1 register ****/
/*
 * Hash function output selection:
 * 000 - [7:0]
 * 001 - [15:8]
 * 010 - [23:16]
 * 011 - [31:24]
 * 100 - XOR bytes
 * 101 - 0
 * 110 - 1
 * 111 - [7:0]
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_THASH_CFG_1_OUT_SEL_MASK  0x00000007
#define EC_RFW_THASH_CFG_1_OUT_SEL_SHIFT 0
/*
 * Selects between hash functions
 * 00 - toeplitz
 * 01 - CRC-32
 * 10 - 0xFF
 * 11 - N/A
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_THASH_CFG_1_FUNC_SEL_MASK 0x00000300
#define EC_RFW_THASH_CFG_1_FUNC_SEL_SHIFT 8
/*
 * Enable SIP/DIP swap if SIP<DIP
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_THASH_CFG_1_ENABLE_IP_SWAP (1 << 16)
/*
 * Enable PORT swap if SPORT<DPORT
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_THASH_CFG_1_ENABLE_PORT_SWAP (1 << 17)

/**** mhash_cfg_1 register ****/
/*
 * Hash function output selection:
 * 000 - [7:0]
 * 001 - [15:8]
 * 010 - [23:16]
 * 011 - [31:24]
 * 100 - XOR bytes
 * 101 - 0
 * 110 - 1
 * 111 - [7:0]
 * Reset: 0x1         Access: RW
 */
#define EC_RFW_MHASH_CFG_1_OUT_SEL_MASK  0x00000007
#define EC_RFW_MHASH_CFG_1_OUT_SEL_SHIFT 0
/*
 * Selects the input to the MAC hash function
 * 0 - DA
 * 1 - DA + SA
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_MHASH_CFG_1_INPUT_SEL     (1 << 4)
/*
 * Selects between hash functions
 * 00 - toeplitz
 * 01 - CRC-32
 * 10 - 0xFF
 * 11 - N/A
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_MHASH_CFG_1_FUNC_SEL_MASK 0x00000300
#define EC_RFW_MHASH_CFG_1_FUNC_SEL_SHIFT 8

/**** hdr_split register ****/
/*
 * Default header length for header split
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_HDR_SPLIT_DEF_LEN_MASK    0x0000FFFF
#define EC_RFW_HDR_SPLIT_DEF_LEN_SHIFT   0
/*
 * Enable header split operation
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_HDR_SPLIT_EN              (1 << 16)

/**** meta_err register ****/
/*
 * Mask for error 1 in the Rx descriptor
 * [13] EC tunnel L3 tlen error long
 * [12] EC tunnel L3 tlen error short
 * [11] EC L3 tlen error long
 * [10] EC L3 tlen error short
 * [9] RXF full error
 * [8] Async FIFO length error
 * [7] MAC frame length error
 * [6] MAC FCS error
 * [5] MAC frame truncation indication (application overflow)
 * [4] MAC PHY error indication
 * [3] MAC remote/local fault or Short frame err
 * [2] MAC decode error (rs layer)
 * [1] MAC Collision error
 * [0] MAC Rx error
 * Reset: 0x3fe       Access: RW
 */
#define EC_RFW_META_ERR_MASK_1_MASK      0x00003FFF
#define EC_RFW_META_ERR_MASK_1_SHIFT     0
/*
 * Mask for error 2 in the Rx descriptor
 * [13] EC tunnel L3 tlen error long
 * [12] EC tunnel L3 tlen error short
 * [11] EC L3 tlen error long
 * [10] EC L3 tlen error short
 * [9] RXF full error
 * [8] Async FIFO length error
 * [7] MAC frame length error
 * [6] MAC FCS error
 * [5] MAC frame truncation indication (application overflow)
 * [4] MAC PHY error indication
 * [3] MAC remote/local fault or Short frame err
 * [2] MAC decode error (rs layer)
 * [1] MAC Collision error
 * [0] MAC Rx error
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_META_ERR_MASK_2_MASK      0x3FFF0000
#define EC_RFW_META_ERR_MASK_2_SHIFT     16

/**** meta register ****/
/*
 * Selection of the L3 offset source:
 * 1 - Inner packet
 * 0 - Outer packet
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_META_L3_LEN_SEL           (1 << 0)
/*
 * Selection of the L3 offset source:
 * 1 - Inner packet
 * 0 - Outer packet
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_META_L3_OFFSET_SEL        (1 << 1)
/*
 * Selection of the l3 protocol index source:
 * 1 - Inner packet
 * 0 - Outer packet
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_META_L3_PROT_SEL          (1 << 2)
/*
 * Selection of the l4 protocol index source:
 * 1 - Inner packet
 * 0 - Outer packet
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_META_L4_PROT_SEL          (1 << 3)
/*
 * Selects how to calculate the L3 header length when L3 is IpPv6.
 * 1 - Use output of the parser (configured value for the detected L3, should be 40 for IPv6)
 * 0 - Use L4 offset - L3 offset
 * Note 1: Selecting 0 only has an effect if the L4_found bit in the output control bit is set i.e.,
 * the parser detected valid L4, UDP or TCP) and the L4 offset >= L3 offset.
 * Otherwise, the configured value for the detected L3 protocol is used
 * Note 2: This is only valid when the L3 is IPv6, to support parsing of extension headers
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_META_L3_LEN_CALC          (1 << 4)
/*
 * Selection of the IPv4 fragment indication source:
 * 1 - Inner packet
 * 0 - Outer packet
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_META_FRAG_SEL             (1 << 5)
/*
 * Selection of the L4 offset source:
 * 1 - Inner packet
 * 0 - Outer packet
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_META_L4_OFFSET_SEL        (1 << 6)

/**** filter register ****/
/*
 * Filter undetected MAC DA
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_FILTER_UNDET_MAC          (1 << 0)
/*
 * Filter specific MAC DA based on MAC table output.
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_FILTER_DET_MAC            (1 << 1)
/*
 * Filter all tagged.
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_FILTER_FILTER_TAGGED      (1 << 2)
/*
 * Filter all untagged.
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_FILTER_UNTAGGED           (1 << 3)
/*
 * Filter all broadcast.
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_FILTER_BC                 (1 << 4)
/*
 * Filter all multicast.
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_FILTER_MC                 (1 << 5)
/*
 * Filter based on parsing output
 * (used to drop selected protocol based on protocol index output)
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_FILTER_PARSE              (1 << 6)
/*
 * Filter packet based on VLAN table output.
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_FILTER_VLAN_VID           (1 << 7)
/*
 * Filter packet based on control table output.
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_FILTER_CTRL_TABLE         (1 << 8)
/*
 * Filter packet based on protocol index action register.
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_FILTER_PROT_INDEX         (1 << 9)
/*
 * Filter packet based on WoL decision
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_FILTER_WOL                (1 << 10)
/*
 * Override filter decision and forward to default UDMA/queue;
 * drop undetected MAC DA.
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_FILTER_OR_UNDET_MAC       (1 << 16)
/*
 * Override filter decision and forward to default UDMA/queue;
 * Drop specific MAC DA based on MAC table output
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_FILTER_OR_DET_MAC         (1 << 17)
/*
 * Override filter decision and forward to default UDMA/queue;
 * Drop all tagged
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_FILTER_OR_TAGGED          (1 << 18)
/*
 * Override filter decision and forward to default UDMA/queue;
 * Drop all untagged
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_FILTER_OR_UNTAGGED        (1 << 19)
/*
 * Override filter decision and forward to default UDMA/queue;
 * Drop all broadcast.
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_FILTER_OR_BC              (1 << 20)
/*
 * Override filter decision and forward to default UDMA/queue;
 * Drop all multicast.
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_FILTER_OR_MC              (1 << 21)
/*
 * Override filter decision and forward to default UDMA/queue;
 * Drop based on parsing output  (used to drop selected protocol based on protocol index output)
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_FILTER_OR_PARSE           (1 << 22)
/*
 * Override filter decision and forward to default UDMA/queue;
 * Drop packet based on VLAN table output.
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_FILTER_OR_VLAN_VID        (1 << 23)
/*
 * Override filter decision and forward to default UDMA/queue;
 * Drop packet based on control table output.
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_FILTER_OR_CTRL_TABLE      (1 << 24)
/*
 * Override filter decision and forward to default UDMA/queue;
 * Drop packet based on protocol index action register.
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_FILTER_OR_PROT_INDEX      (1 << 25)
/*
 * Override filter decision and forward to default UDMA/queue;
 * Drop packet based on WoL decision
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_FILTER_OR_WOL             (1 << 26)

/**** thash_table_addr register ****/
/*
 * Address for accessing the table
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_THASH_TABLE_ADDR_VAL_MASK 0x000000FF
#define EC_RFW_THASH_TABLE_ADDR_VAL_SHIFT 0

/**** thash_table_data register ****/
/*
 * Table data (valid only after configuring the table address register)
 * [3:0] - UDMA
 * [7:4] - Queue number
 * [14:8] - LRO address select - lro not used
 * [15] - LRO valid - lro not used
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_THASH_TABLE_DATA_VAL_MASK 0x0000FFFF
#define EC_RFW_THASH_TABLE_DATA_VAL_SHIFT 0

/**** mhash_table_addr register ****/
/*
 * Address for accessing the table
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_MHASH_TABLE_ADDR_VAL_MASK 0x000000FF
#define EC_RFW_MHASH_TABLE_ADDR_VAL_SHIFT 0

/**** mhash_table_data register ****/
/*
 * Table data (valid only after configuring the table address register)
 * [3:0] - UDMA
 * [7:4] - Queue number
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_MHASH_TABLE_DATA_VAL_MASK 0x000000FF
#define EC_RFW_MHASH_TABLE_DATA_VAL_SHIFT 0

/**** vid_table_addr register ****/
/*
 * Address for accessing the table
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_VID_TABLE_ADDR_VAL_MASK   0x00000FFF
#define EC_RFW_VID_TABLE_ADDR_VAL_SHIFT  0

/**** vid_table_data register ****/
/*
 * Table data (valid only after configuring the table address register)
 * [0] - Control bit, used as input to the control table
 * [1] - Drop indication
 * [5:2] - UDMA selection
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_VID_TABLE_DATA_VAL_MASK   0x0000003F
#define EC_RFW_VID_TABLE_DATA_VAL_SHIFT  0

/**** pbits_table_addr register ****/
/*
 * Address for accessing the table
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_PBITS_TABLE_ADDR_VAL_MASK 0x00000007
#define EC_RFW_PBITS_TABLE_ADDR_VAL_SHIFT 0

/**** pbits_table_data register ****/
/*
 * VLAN P-bits to internal priority mapping
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_PBITS_TABLE_DATA_VAL_MASK 0x00000007
#define EC_RFW_PBITS_TABLE_DATA_VAL_SHIFT 0

/**** dscp_table_addr register ****/
/*
 * Address for accessing the table
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_DSCP_TABLE_ADDR_VAL_MASK  0x000000FF
#define EC_RFW_DSCP_TABLE_ADDR_VAL_SHIFT 0

/**** dscp_table_data register ****/
/*
 * IPv4 DSCP to internal priority mapping
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_DSCP_TABLE_DATA_VAL_MASK  0x00000007
#define EC_RFW_DSCP_TABLE_DATA_VAL_SHIFT 0

/**** tc_table_addr register ****/
/*
 * Address for accessing the table
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_TC_TABLE_ADDR_VAL_MASK    0x000000FF
#define EC_RFW_TC_TABLE_ADDR_VAL_SHIFT   0

/**** tc_table_data register ****/
/*
 * IPv6 TC to internal priority mapping
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_TC_TABLE_DATA_VAL_MASK    0x00000007
#define EC_RFW_TC_TABLE_DATA_VAL_SHIFT   0

/**** ctrl_table_addr register ****/
/*
 * Address for accessing the table
 * [0] - VLAN table control out
 * [1] - Tunnel exists
 * [2] - VLAN 1 exists (in outer packet)
 * [3] - MAC compare result valid
 * [8:4] - L3 protocol index (selection between inner or outer header)
 * [10:9] - MAC packet type (selection between inner and outer header)
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_CTRL_TABLE_ADDR_VAL_MASK  0x000007FF
#define EC_RFW_CTRL_TABLE_ADDR_VAL_SHIFT 0

/**** ctrl_table_data register ****/
/*
 * Control table output for selecting the forwarding MUXs
 * [3:0] - Priority selection
 * [9:4] - Queue selection
 * [14:10] - UDMA selection
 * [18:15] - Header split selection
 * [19] - Drop indication
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_CTRL_TABLE_DATA_VAL_MASK  0x000FFFFF
#define EC_RFW_CTRL_TABLE_DATA_VAL_SHIFT 0

/**** out_cfg register ****/
/*
 * Number of MetaData at the end of the packet
 * 1 - One MetaData beat
 * 2 - Two MetaData beats
 * 0/3 - N/A
 * Reset: 0x1         Access: RW
 */
#define EC_RFW_OUT_CFG_META_CNT_MASK     0x00000003
#define EC_RFW_OUT_CFG_META_CNT_SHIFT    0
/*
 * Enable packet drop
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_OUT_CFG_DROP_EN           (1 << 2)
/*
 * Swap output byte order
 * Reset: 0x1         Access: RW
 */
#define EC_RFW_OUT_CFG_SWAP_OUT_BYTE     (1 << 3)
/*
 * Enable the insertion of the MACsec decoding result into the MetaData
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_OUT_CFG_EN_MACSEC_DEC     (1 << 4)
/*
 * Sample time of the time stamp:
 * 0 - SOP (for 10G MAC)
 * 1 - EOP (for 1G MAC, without MACsec)
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_OUT_CFG_TIMESTAMP_SAMPLE  (1 << 5)
/*
 * Determines which queue to write into the packet header
 * 0 - Original selected queue
 * 1 - Override selected queue
 * Reset: 0x1         Access: RW
 */
#define EC_RFW_OUT_CFG_QUEUE_OR_SEL      (1 << 6)
/*
 * Determines the logic of the drop indication:
 * 0 - Sample the drop bit when changing state from IDLE to HDR.
 * 1 - Sample the drop bit when changing state from IDLE to HDR and from META to HDR.
 * Reset: 0x1         Access: RW
 */
#define EC_RFW_OUT_CFG_DROP_LOGIC_SEL    (1 << 7)
/*
 * Determines the logic of the drop indication:
 * 0 - Sample the drop bit when changing state from IDLE to HDR.
 * 1 - Sample the drop bit when changing state from IDLE to HDR and from META to HDR.
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_OUT_CFG_PKT_TYPE_DEF      (1 << 8)

/**** fsm_table_addr register ****/
/*
 * Address for accessing the table :
 * [2:0] - Outer header control
 * [5:3] - Inner header control
 * [6] - Tunnel exists
 * Header control:
 * 0 - IPv4, TCP
 * 1 - IPv4, UDP
 * 2 - IPv6, TCP
 * 3 - IPv6 UDP
 * 4 - IPv6, no TCP/UDP
 * 5 - IPv4, no TCP/UDP
 * 6 - IPv4, fragmented
 * 7 - No IPv4/6
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_FSM_TABLE_ADDR_VAL_MASK   0x0000007F
#define EC_RFW_FSM_TABLE_ADDR_VAL_SHIFT  0

/**** fsm_table_data register ****/
/*
 * Flow steering mechanism output selectors:
 * [1:0] - Input selector:
 *    00 - 2 tuple, outer header
 *    01 - 4 tuple, outer header
 *    10 - 2 tuple. Inner header
 *    11 - 4 tuple, inner header
 * [2] - Hash select
 *    0 - Select default
 *    1 - Select hash output
 * [6:3] - Default UDMA
 * [10:7] - Default queue
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_FSM_TABLE_DATA_VAL_MASK   0x000007FF
#define EC_RFW_FSM_TABLE_DATA_VAL_SHIFT  0

/**** ctrl_sel register ****/
/*
 * Packet type (UC/MC/BC) for the control table
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_CTRL_SEL_PKT_TYPE         (1 << 0)
/*
 * L3 protocol index for the control table
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_CTRL_SEL_L3_PROTOCOL      (1 << 1)
/*
 * Selects the content and structure of the control table address
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_CTRL_SEL_ADDR_MASK        0x0000000C
#define EC_RFW_CTRL_SEL_ADDR_SHIFT       2
/*
 * protocol_index selection for control_table address
 * 0 - selected protocol_index (v3)
 * 1 - table selected protocol_number[4:0] (dynamic)
 * 2 - selected protocol_number[4:0]
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_CTRL_SEL_PROTOCOL_INDEX_SEL_MASK 0x00000300
#define EC_RFW_CTRL_SEL_PROTOCOL_INDEX_SEL_SHIFT 8

/**** default_vlan register ****/
/*
 * Default VLAN data, used for untagged packets
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_DEFAULT_VLAN_DATA_MASK    0x0000FFFF
#define EC_RFW_DEFAULT_VLAN_DATA_SHIFT   0

/**** default_hash register ****/
/*
 * Default UDMA
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_DEFAULT_HASH_UDMA_MASK    0x0000000F
#define EC_RFW_DEFAULT_HASH_UDMA_SHIFT   0
/*
 * Default queue
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_DEFAULT_HASH_QUEUE_MASK   0x000F0000
#define EC_RFW_DEFAULT_HASH_QUEUE_SHIFT  16

/**** default_or register ****/
/*
 * Default UDMA
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_DEFAULT_OR_UDMA_MASK      0x0000000F
#define EC_RFW_DEFAULT_OR_UDMA_SHIFT     0
/*
 * Default queue
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_DEFAULT_OR_QUEUE_MASK     0x000F0000
#define EC_RFW_DEFAULT_OR_QUEUE_SHIFT    16

/**** checksum register ****/
/*
 * Check that the length in the UDP header matches the length in the IP header.
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_CHECKSUM_UDP_LEN          (1 << 0)
/*
 * Select the header that will be used for the checksum when a tunnel exists.
 * 0 - Always use outer packet header.
 * 1 - Use inner packet header when a tunnel exists.
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_CHECKSUM_HDR_SEL          (1 << 1)
/*
 * Enable L4 checksum when L3 fragmentation is detected
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_CHECKSUM_L4_FRAG_EN       (1 << 2)
/*
 * L3 Checksum result selection for the Metadata descriptor
 * 0 - Original checksum result based on hdr_sel
 * 1 - Logical OR between original checksum result and the outer header checksum result
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_CHECKSUM_L3_CKS_SEL       (1 << 4)
/*
 * L4 Checksum result selection for the Metadata descriptor
 * 0 - Original checksum result based on hdr_sel
 * 1 - Logical OR between original checksum result and the outer header checksum result
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_CHECKSUM_L4_CKS_SEL       (1 << 5)
/*
 * protocol_index selection for l3 checksum
 * 0 - selected protocol_index (v3)
 * 1 - table selected protocol_number[4:0] (dynamic)
 * 2 - selected protocol_number[4:0]
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_CHECKSUM_L3_CKS_PROTOCOL_INDEX_SEL_MASK 0x00000300
#define EC_RFW_CHECKSUM_L3_CKS_PROTOCOL_INDEX_SEL_SHIFT 8
/*
 * protocol_index selection for l4 checksum
 * 0 - selected protocol_index (v3)
 * 1 - table selected protocol_number[4:0] (dynamic)
 * 2 - selected protocol_number[4:0]
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_CHECKSUM_L4_CKS_PROTOCOL_INDEX_SEL_MASK 0x00000C00
#define EC_RFW_CHECKSUM_L4_CKS_PROTOCOL_INDEX_SEL_SHIFT 10
/*
 * protocol_index selection for l3 tunnel checksum
 * 0 - selected protocol_index (v3)
 * 1 - table selected protocol_number[4:0] (dynamic)
 * 2 - selected protocol_number[4:0]
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_CHECKSUM_L3_TCKS_PROTOCOL_INDEX_SEL_MASK 0x00003000
#define EC_RFW_CHECKSUM_L3_TCKS_PROTOCOL_INDEX_SEL_SHIFT 12
/*
 * protocol_index selection for l4 tunnel checksum
 * 0 - selected protocol_index (v3)
 * 1 - table selected protocol_number[4:0] (dynamic)
 * 2 - selected protocol_number[4:0]
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_CHECKSUM_L4_TCKS_PROTOCOL_INDEX_SEL_MASK 0x0000C000
#define EC_RFW_CHECKSUM_L4_TCKS_PROTOCOL_INDEX_SEL_SHIFT 14
/*
 * protocol_index selection for l3 tunnel checksum
 * 0 - selected protocol_index (v3)
 * 1 - table selected protocol_number[4:0] (dynamic)
 * 2 - selected protocol_number[4:0]
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_CHECKSUM_L3_CKS_OFFSET_SEL_MASK 0x00030000
#define EC_RFW_CHECKSUM_L3_CKS_OFFSET_SEL_SHIFT 16
/*
 * protocol_index selection for l3 tunnel checksum
 * 0 - selected protocol_index (v3)
 * 1 - table selected protocol_number[4:0] (dynamic)
 * 2 - selected protocol_number[4:0]
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_CHECKSUM_L3_CKS_HDR_LEN_SEL_MASK 0x000C0000
#define EC_RFW_CHECKSUM_L3_CKS_HDR_LEN_SEL_SHIFT 18
/*
 * protocol_index selection for l3 tunnel checksum
 * 0 - selected protocol_index (v3)
 * 1 - table selected protocol_number[4:0] (dynamic)
 * 2 - selected protocol_number[4:0]
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_CHECKSUM_L3_TCKS_OFFSET_SEL_MASK 0x00300000
#define EC_RFW_CHECKSUM_L3_TCKS_OFFSET_SEL_SHIFT 20
/*
 * protocol_index selection for l3 tunnel checksum
 * 0 - selected protocol_index (v3)
 * 1 - table selected protocol_number[4:0] (dynamic)
 * 2 - selected protocol_number[4:0]
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_CHECKSUM_L3_TCKS_HDR_LEN_SEL_MASK 0x00C00000
#define EC_RFW_CHECKSUM_L3_TCKS_HDR_LEN_SEL_SHIFT 22

/**** lro_cfg_1 register ****/
/*
 * Select the header that will be used for the LRO offload engine when a tunnel exists.
 * 0 - Always use outer packet header.
 * 1 - Use inner packet header when a tunnel exists.
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_LRO_CFG_1_HDR_SEL         (1 << 0)
/*
 * Select the L2 header that will be used for the LRO offload engine when a tunnel exists.
 * 0 - Always use outer packet header.
 * 1 - Use inner packet header when a tunnel exists.
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_LRO_CFG_1_HDR_L2_SEL      (1 << 1)

/**** lro_check_ipv4 register ****/
/*
 * Check version field.
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_LRO_CHECK_IPV4_VER        (1 << 0)
/*
 * Check IHL field == 5.
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_LRO_CHECK_IPV4_IHL_0      (1 << 1)
/*
 * Check IHL field >= 5.
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_LRO_CHECK_IPV4_IHL_1      (1 << 2)
/*
 * Compare to previous packet.
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_LRO_CHECK_IPV4_IHL_2      (1 << 3)
/*
 * Compare DSCP to previous packet.
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_LRO_CHECK_IPV4_DSCP       (1 << 4)
/*
 * Check that Total length >= lro_ipv4_tlen_val.
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_LRO_CHECK_IPV4_TLEN       (1 << 5)
/*
 * Compare to previous packet value +1.
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_LRO_CHECK_IPV4_ID         (1 << 6)
/*
 * Compare to lro_ipv4_flags_val with lro_ipv4_flags_mask_0.
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_LRO_CHECK_IPV4_FLAGS_0    (1 << 7)
/*
 * Compare to previous packet flags with lro_ipv4_flags_mask_1.
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_LRO_CHECK_IPV4_FLAGS_1    (1 << 8)
/*
 * Verify that the fragment offset field is 0.
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_LRO_CHECK_IPV4_FRAG       (1 << 9)
/*
 * Verify that the TTL value >0.
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_LRO_CHECK_IPV4_TTL_0      (1 << 10)
/*
 * Compare TTL value to previous packet.
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_LRO_CHECK_IPV4_TTL_1      (1 << 11)
/*
 * Compare to previous packet protocol field.
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_LRO_CHECK_IPV4_PROT_0     (1 << 12)
/*
 * Verify that the protocol is TCP or UDP.
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_LRO_CHECK_IPV4_PROT_1     (1 << 13)
/*
 * Verify that the check sum is correct.
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_LRO_CHECK_IPV4_CHECKSUM   (1 << 14)
/*
 * Compare SIP to previous packet.
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_LRO_CHECK_IPV4_SIP        (1 << 15)
/*
 * Compare DIP to previous packet.
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_LRO_CHECK_IPV4_DIP        (1 << 16)

/**** lro_ipv4 register ****/
/*
 * Total length minimum value
 * Reset: 0x28        Access: RW
 */
#define EC_RFW_LRO_IPV4_TLEN_VAL_MASK    0x0000FFFF
#define EC_RFW_LRO_IPV4_TLEN_VAL_SHIFT   0
/*
 * Flags value
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_LRO_IPV4_FLAGS_VAL_MASK   0x00070000
#define EC_RFW_LRO_IPV4_FLAGS_VAL_SHIFT  16
/*
 * Flags mask
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_LRO_IPV4_FLAGS_MASK_0_MASK 0x00380000
#define EC_RFW_LRO_IPV4_FLAGS_MASK_0_SHIFT 19
/*
 * Flags mask
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_LRO_IPV4_FLAGS_MASK_1_MASK 0x01C00000
#define EC_RFW_LRO_IPV4_FLAGS_MASK_1_SHIFT 22
/*
 * Version value
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_LRO_IPV4_VER_MASK         0xF0000000
#define EC_RFW_LRO_IPV4_VER_SHIFT        28

/**** lro_check_ipv6 register ****/
/*
 * Check version field
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_LRO_CHECK_IPV6_VER        (1 << 0)
/*
 * Compare TC to previous packet.
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_LRO_CHECK_IPV6_TC         (1 << 1)
/*
 * Compare flow label field to previous packet.
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_LRO_CHECK_IPV6_FLOW       (1 << 2)
/*
 * Check that Total length >= lro_ipv6_pen_val.
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_LRO_CHECK_IPV6_PLEN       (1 << 3)
/*
 * Compare to previous packet next header field.
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_LRO_CHECK_IPV6_NEXT_0     (1 << 4)
/*
 * Verify that the next header is TCP or UDP.
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_LRO_CHECK_IPV6_NEXT_1     (1 << 5)
/*
 * Verify that hop limit is >0.
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_LRO_CHECK_IPV6_HOP_0      (1 << 6)
/*
 * Compare hop limit to previous packet.
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_LRO_CHECK_IPV6_HOP_1      (1 << 7)
/*
 * Compare SIP to previous packet.
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_LRO_CHECK_IPV6_SIP        (1 << 8)
/*
 * Compare DIP to previous packet.
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_LRO_CHECK_IPV6_DIP        (1 << 9)

/**** lro_ipv6 register ****/
/*
 * Payload length minimum value
 * Reset: 0x28        Access: RW
 */
#define EC_RFW_LRO_IPV6_PLEN_VAL_MASK    0x0000FFFF
#define EC_RFW_LRO_IPV6_PLEN_VAL_SHIFT   0
/*
 * Version value
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_LRO_IPV6_VER_MASK         0x0F000000
#define EC_RFW_LRO_IPV6_VER_SHIFT        24

/**** lro_check_tcp register ****/
/*
 * Compare to previous packet.
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_LRO_CHECK_TCP_SRC_PORT    (1 << 0)
/*
 * Compare to previous packet.
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_LRO_CHECK_TCP_DST_PORT    (1 << 1)
/*
 * If (SYN == 1), don't check .
 * Else, check that SN = prev SN + prev Length.
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_LRO_CHECK_TCP_SN          (1 << 2)
/*
 * Check data offset field == 5.
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_LRO_CHECK_TCP_OFFSET_0    (1 << 3)
/*
 * Check data offset field >= 5.
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_LRO_CHECK_TCP_OFFSET_1    (1 << 4)
/*
 * Compare to previous packet.
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_LRO_CHECK_TCP_OFFSET_2    (1 << 5)
/*
 * Compare reserved field to lro_tcp_res.
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_LRO_CHECK_TCP_RES         (1 << 6)
/*
 * Compare to lro_tcp_ecn_val and lro_tcp_ecn_mask_0.
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_LRO_CHECK_TCP_ECN_0       (1 << 7)
/*
 * Compare to previous packet ECN field with lro_tcp_ecn_mask_1.
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_LRO_CHECK_TCP_ECN_1       (1 << 8)
/*
 * Compare to lro_tcp_ctrl_val and lro_tcp_ctrl_mask_0.
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_LRO_CHECK_TCP_CTRL_0      (1 << 9)
/*
 * Compare to previous packet ECN field with lro_tcp_ctrl_mask_1.
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_LRO_CHECK_TCP_CTRL_1      (1 << 10)
/*
 * Verify that check sum is correct.
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_LRO_CHECK_TCP_CHECKSUM    (1 << 11)

/**** lro_tcp register ****/
/*
 * Reserved field default value
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_LRO_TCP_RES_MASK          0x00000007
#define EC_RFW_LRO_TCP_RES_SHIFT         0
/*
 * ECN field value
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_LRO_TCP_ECN_VAL_MASK      0x00000038
#define EC_RFW_LRO_TCP_ECN_VAL_SHIFT     3
/*
 * ECN field mask
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_LRO_TCP_ECN_MASK_0_MASK   0x000001C0
#define EC_RFW_LRO_TCP_ECN_MASK_0_SHIFT  6
/*
 * ECN field mask
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_LRO_TCP_ECN_MASK_1_MASK   0x00000E00
#define EC_RFW_LRO_TCP_ECN_MASK_1_SHIFT  9
/*
 * Control field value
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_LRO_TCP_CTRL_VAL_MASK     0x0003F000
#define EC_RFW_LRO_TCP_CTRL_VAL_SHIFT    12
/*
 * Control field mask
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_LRO_TCP_CTRL_MASK_0_MASK  0x00FC0000
#define EC_RFW_LRO_TCP_CTRL_MASK_0_SHIFT 18
/*
 * Control field mask
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_LRO_TCP_CTRL_MASK_1_MASK  0x3F000000
#define EC_RFW_LRO_TCP_CTRL_MASK_1_SHIFT 24

/**** lro_check_udp register ****/
/*
 * Compare to previous packet.
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_LRO_CHECK_UDP_SRC_PORT    (1 << 0)
/*
 * Compare to previous packet.
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_LRO_CHECK_UDP_DST_PORT    (1 << 1)
/*
 * Verify that check sum is correct.
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_LRO_CHECK_UDP_CHECKSUM    (1 << 2)

/**** lro_check_l2 register ****/
/*
 * Compare to previous packet.
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_LRO_CHECK_L2_MAC_DA       (1 << 0)
/*
 * Compare to previous packet.
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_LRO_CHECK_L2_MAC_SA       (1 << 1)
/*
 * Compare to previous packet.
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_LRO_CHECK_L2_VLAN_1_EXIST (1 << 2)
/*
 * Compare to previous packet.
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_LRO_CHECK_L2_VLAN_1_VID   (1 << 3)
/*
 * Compare to previous packet.
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_LRO_CHECK_L2_VLAN_1_CFI   (1 << 4)
/*
 * Compare to previous packet.
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_LRO_CHECK_L2_VLAN_1_PBITS (1 << 5)
/*
 * Compare to previous packet.
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_LRO_CHECK_L2_VLAN_2_EXIST (1 << 6)
/*
 * Compare to previous packet.
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_LRO_CHECK_L2_VLAN_2_VID   (1 << 7)
/*
 * Compare to previous packet.
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_LRO_CHECK_L2_VLAN_2_CFI   (1 << 8)
/*
 * Compare to previous packet.
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_LRO_CHECK_L2_VLAN_2_PBITS (1 << 9)
/*
 * Verify that the FCS is correct.
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_LRO_CHECK_L2_FCS          (1 << 10)

/**** lro_check_gen register ****/
/*
 * Compare to previous packet
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_LRO_CHECK_GEN_UDMA        (1 << 0)
/*
 * Compare to previous packet
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_LRO_CHECK_GEN_QUEUE       (1 << 1)

/**** lro_store register ****/
/*
 * Store packet information if protocol match.
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_LRO_STORE_IPV4            (1 << 0)
/*
 * Store packet information if protocol match.
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_LRO_STORE_IPV6            (1 << 1)
/*
 * Store packet information if protocol match.
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_LRO_STORE_TCP             (1 << 2)
/*
 * Store packet information if protocol match.
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_LRO_STORE_UDP             (1 << 3)
/*
 * Store packet if IPv4 flags match the register value with mask.
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_LRO_STORE_IPV4_FLAGS_VAL_MASK 0x00000070
#define EC_RFW_LRO_STORE_IPV4_FLAGS_VAL_SHIFT 4
/*
 * Mask for IPv4 flags
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_LRO_STORE_IPV4_FLAGS_MASK_MASK 0x00000380
#define EC_RFW_LRO_STORE_IPV4_FLAGS_MASK_SHIFT 7
/*
 * Store packet if TCP control and ECN match the register value with mask.
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_LRO_STORE_TCP_CTRL_VAL_MASK 0x0007FC00
#define EC_RFW_LRO_STORE_TCP_CTRL_VAL_SHIFT 10
/*
 * Mask for TCP control
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_LRO_STORE_TCP_CTRL_MASK_MASK 0x0FF80000
#define EC_RFW_LRO_STORE_TCP_CTRL_MASK_SHIFT 19

/**** vid_table_def register ****/
/*
 * Table default data (valid only after configuring the table address register)
 * [0] - Control bit, used as input to the control table
 * [1] - Drop indication
 * [5:2] - UDMA selection
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_VID_TABLE_DEF_VAL_MASK    0x0000003F
#define EC_RFW_VID_TABLE_DEF_VAL_SHIFT   0
/*
 * Default data selection
 * 0 - Default value
 * 1 - Table data out
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_VID_TABLE_DEF_SEL         (1 << 6)

/**** ctrl_table_def register ****/
/*
 * Control table output for selecting the forwarding MUXs
 * [3:0] - Priority selection
 * [9:4] - Queue selection
 * [14:10] - UDMA selection
 * [18:15] - Header split selection
 * [19] - Drop indication
 * Reset: 0x1fdc      Access: RW
 */
#define EC_RFW_CTRL_TABLE_DEF_VAL_MASK   0x000FFFFF
#define EC_RFW_CTRL_TABLE_DEF_VAL_SHIFT  0
/*
 * Default data selection
 * 0 - Default value
 * 1 - Table data out
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_CTRL_TABLE_DEF_SEL        (1 << 20)

/**** cfg_a_0 register ****/
/*
 * Selection of the L3 checksum result in the Metadata
 * 00 - L3 checksum
 * 01 - L3 checksum or RoCE/FCoE CRC, based on outer header
 * 10 - If tunnel exist = 0, L3 checksum or RoCE/FCoE CRC, based on outer header
 *         Else, logic AND between outer L3 checksum (if IPv4) and inner CRC (if RoCE or FcoE)
 * 11 - combination of the L3 checksum result and CRC result, based on the checksum and RoCE/FCoE
 * CRC input selections.
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_CFG_A_0_META_L3_CHK_RES_SEL_MASK 0x00000003
#define EC_RFW_CFG_A_0_META_L3_CHK_RES_SEL_SHIFT 0
/*
 * Selection of the L4 checksum result in the Metadata
 * 0 - L4 checksum
 * 1 - Logic AND between outer and inner L4 checksum result
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_CFG_A_0_META_L4_CHK_RES_SEL (1 << 2)
/*
 * Selection of the LRO_context_value result in the Metadata
 * 0 - LRO_context_value
 * 1 - L4_offset
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_CFG_A_0_LRO_CONTEXT_SEL   (1 << 4)

/**** thash_cfg_3 register ****/
/*
 * Enable Hash value for RoCE packets in outer packet.
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_THASH_CFG_3_ENABLE_OUTER_ROCE (1 << 0)
/*
 * Enable Hash value for RoCE packets in inner packet.
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_THASH_CFG_3_ENABLE_INNER_ROCE (1 << 1)
/*
 * Enable Hash value for FcoE packets in outer packet.
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_THASH_CFG_3_ENABLE_OUTER_FCOE (1 << 2)
/*
 * Enable Hash value for FcoE packets in inner packet.
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_THASH_CFG_3_ENABLE_INNER_FCOE (1 << 3)

/**** thash_mask_outer_ipv6 register ****/
/*
 * IPv6 source IP address
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_THASH_MASK_OUTER_IPV6_SRC_MASK 0x0000FFFF
#define EC_RFW_THASH_MASK_OUTER_IPV6_SRC_SHIFT 0
/*
 * IPv6 destination IP address
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_THASH_MASK_OUTER_IPV6_DST_MASK 0xFFFF0000
#define EC_RFW_THASH_MASK_OUTER_IPV6_DST_SHIFT 16

/**** thash_mask_outer register ****/
/*
 * IPv4 source IP address
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_THASH_MASK_OUTER_IPV4_SRC_MASK 0x0000000F
#define EC_RFW_THASH_MASK_OUTER_IPV4_SRC_SHIFT 0
/*
 * IPv4 destination IP address
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_THASH_MASK_OUTER_IPV4_DST_MASK 0x000000F0
#define EC_RFW_THASH_MASK_OUTER_IPV4_DST_SHIFT 4
/*
 * TCP source port
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_THASH_MASK_OUTER_TCP_SRC_PORT_MASK 0x00000300
#define EC_RFW_THASH_MASK_OUTER_TCP_SRC_PORT_SHIFT 8
/*
 * TCP destination port
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_THASH_MASK_OUTER_TCP_DST_PORT_MASK 0x00000C00
#define EC_RFW_THASH_MASK_OUTER_TCP_DST_PORT_SHIFT 10
/*
 * UDP source port
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_THASH_MASK_OUTER_UDP_SRC_PORT_MASK 0x00003000
#define EC_RFW_THASH_MASK_OUTER_UDP_SRC_PORT_SHIFT 12
/*
 * UDP destination port
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_THASH_MASK_OUTER_UDP_DST_PORT_MASK 0x0000C000
#define EC_RFW_THASH_MASK_OUTER_UDP_DST_PORT_SHIFT 14

/**** thash_mask_inner_ipv6 register ****/
/*
 * IPv6 source IP address
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_THASH_MASK_INNER_IPV6_SRC_MASK 0x0000FFFF
#define EC_RFW_THASH_MASK_INNER_IPV6_SRC_SHIFT 0
/*
 * IPv6 destination IP address
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_THASH_MASK_INNER_IPV6_DST_MASK 0xFFFF0000
#define EC_RFW_THASH_MASK_INNER_IPV6_DST_SHIFT 16

/**** thash_mask_inner register ****/
/*
 * IPv4 source IP address
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_THASH_MASK_INNER_IPV4_SRC_MASK 0x0000000F
#define EC_RFW_THASH_MASK_INNER_IPV4_SRC_SHIFT 0
/*
 * IPv4 destination IP address
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_THASH_MASK_INNER_IPV4_DST_MASK 0x000000F0
#define EC_RFW_THASH_MASK_INNER_IPV4_DST_SHIFT 4
/*
 * TCP source port
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_THASH_MASK_INNER_TCP_SRC_PORT_MASK 0x00000300
#define EC_RFW_THASH_MASK_INNER_TCP_SRC_PORT_SHIFT 8
/*
 * TCP destination port
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_THASH_MASK_INNER_TCP_DST_PORT_MASK 0x00000C00
#define EC_RFW_THASH_MASK_INNER_TCP_DST_PORT_SHIFT 10
/*
 * UDP source port
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_THASH_MASK_INNER_UDP_SRC_PORT_MASK 0x00003000
#define EC_RFW_THASH_MASK_INNER_UDP_SRC_PORT_SHIFT 12
/*
 * UDP destination port
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_THASH_MASK_INNER_UDP_DST_PORT_MASK 0x0000C000
#define EC_RFW_THASH_MASK_INNER_UDP_DST_PORT_SHIFT 14

/**** rx_checksum register ****/
/*
 * checksum value to be flipped (see rfc 1624)
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_RX_CHECKSUM_TCP_CKS_VAL_FLIP_MASK 0x0000FFFF
#define EC_RFW_RX_CHECKSUM_TCP_CKS_VAL_FLIP_SHIFT 0
/*
 * En able for checksum value to be flipped (see rfc 1624)
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_RX_CHECKSUM_TCP_CKS_VAL_FLIP_EN (1 << 16)
/*
 * Enable for checksum ok override (see rfc 1624)
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_RX_CHECKSUM_TCP_CKS_OK_OVERRIDE_EN (1 << 17)
/*
 * En able for tunnerl checksum value to be flipped (see rfc 1624)
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_RX_CHECKSUM_TCP_TCKS_VAL_FLIP_EN (1 << 18)
/*
 * Enable for tunnel checksum ok override (see rfc 1624)
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_RX_CHECKSUM_TCP_TCKS_OK_OVERRIDE_EN (1 << 19)

/**** l3_tlen_err register ****/
/*
 * L3 tlen validation table address
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_L3_TLEN_ERR_TABLE_ADDR_MASK 0x000001FF
#define EC_RFW_L3_TLEN_ERR_TABLE_ADDR_SHIFT 0
/*
 * Enable for checksum ok mapping
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_L3_TLEN_ERR_MAP_EN        (1 << 15)
/*
 * L3 tlen validation table address
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_L3_TLEN_ERR_TUNNEL_TABLE_ADDR_MASK 0x01FF0000
#define EC_RFW_L3_TLEN_ERR_TUNNEL_TABLE_ADDR_SHIFT 16
/*
 * Enable for tunnel checksum ok mapping
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_L3_TLEN_ERR_TUNNEL_MAP_EN (1 << 31)

/**** l3_tlen_err_table_1 register ****/
/*
 * L4 checksum ok mapping
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_L3_TLEN_ERR_TABLE_1_VAL   (1 << 0)

/**** tunnel_l3_tlen_err_table_1 register ****/
/*
 * Tunnel l4 checksum ok mapping
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_TUNNEL_L3_TLEN_ERR_TABLE_1_VAL (1 << 0)

/**** def_cfg register ****/
/*
 * Number of padding bytes to add at the beginning of each Ethernet packet
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_UDMA_DEF_CFG_RX_PAD_MASK  0x0000003F
#define EC_RFW_UDMA_DEF_CFG_RX_PAD_SHIFT 0

/**** queue register ****/
/*
 * Mapping between priority and queue number
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_PRIORITY_QUEUE_MAP_MASK   0x0000000F
#define EC_RFW_PRIORITY_QUEUE_MAP_SHIFT  0

/**** opt_1 register ****/
/*
 * Default UDMA for forwarding
 * Reset: 0x1         Access: RW
 */
#define EC_RFW_DEFAULT_OPT_1_UDMA_MASK   0x0000000F
#define EC_RFW_DEFAULT_OPT_1_UDMA_SHIFT  0
/*
 * Default priority for forwarding
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_DEFAULT_OPT_1_DEFAULT_PRIORITY_MASK 0x00000700
#define EC_RFW_DEFAULT_OPT_1_DEFAULT_PRIORITY_SHIFT 8
/*
 * Default queue for forwarding
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_DEFAULT_OPT_1_QUEUE_MASK  0x000F0000
#define EC_RFW_DEFAULT_OPT_1_QUEUE_SHIFT 16

/**** data_h register ****/
/*
 * MAC address data
 * Reset: 0x0         Access: RW
 */
#define EC_FWD_MAC_DATA_H_VAL_MASK       0x0000FFFF
#define EC_FWD_MAC_DATA_H_VAL_SHIFT      0

/**** mask_h register ****/
/*
 * MAC address mask
 * Reset: 0x0         Access: RW
 */
#define EC_FWD_MAC_MASK_H_VAL_MASK       0x0000FFFF
#define EC_FWD_MAC_MASK_H_VAL_SHIFT      0

/**** ctrl register ****/
/*
 * Control value for Rx forwarding engine
 * [0] - Drop indication
 * [2:1] - Control table command input
 * [6:3] - UDMA selection
 * [10:7] - Queue number
 * Reset: 0x0         Access: RW
 */
#define EC_FWD_MAC_CTRL_RX_VAL_MASK      0x000007FF
#define EC_FWD_MAC_CTRL_RX_VAL_SHIFT     0
/*
 * Entry is valid for Rx forwarding engine.
 * Reset: 0x0         Access: RW
 */
#define EC_FWD_MAC_CTRL_RX_VALID         (1 << 15)
/*
 * Control value for Tx forwarding engine
 * Reset: 0x0         Access: RW
 */
#define EC_FWD_MAC_CTRL_TX_VAL_MASK      0x001F0000
#define EC_FWD_MAC_CTRL_TX_VAL_SHIFT     16
/*
 * Entry is valid for Tx forwarding engine.
 * Reset: 0x0         Access: RW
 */
#define EC_FWD_MAC_CTRL_TX_VALID         (1 << 31)

/**** uc register ****/
/*
 * timer max value for waiting for a stream to be ready to accept data
 * Reset: 0xa         Access: RW
 */
#define EC_MSW_UC_TIMER_MASK             0x0000FFFF
#define EC_MSW_UC_TIMER_SHIFT            0
/*
 * Drop packet if target queue in the UDMA is full.
 * Reset: 0x0         Access: RW
 */
#define EC_MSW_UC_Q_FULL_DROP_MASK       0x000F0000
#define EC_MSW_UC_Q_FULL_DROP_SHIFT      16
/*
 * Drop packet if timer expires.
 * Reset: 0x0         Access: RW
 */
#define EC_MSW_UC_TIMER_DROP_MASK        0x0F000000
#define EC_MSW_UC_TIMER_DROP_SHIFT       24

/**** mc register ****/
/*
 * Timer max value for waiting for a stream to be ready to accept data
 * Reset: 0xa         Access: RW
 */
#define EC_MSW_MC_TIMER_MASK             0x0000FFFF
#define EC_MSW_MC_TIMER_SHIFT            0
/*
 * Drop packet if target queue in UDMA is full.
 * Reset: 0x0         Access: RW
 */
#define EC_MSW_MC_Q_FULL_DROP_MASK       0x000F0000
#define EC_MSW_MC_Q_FULL_DROP_SHIFT      16
/*
 * Drop packet if timer expires.
 * Reset: 0x0         Access: RW
 */
#define EC_MSW_MC_TIMER_DROP_MASK        0x0F000000
#define EC_MSW_MC_TIMER_DROP_SHIFT       24

/**** bc register ****/
/*
 * Timer max value for waiting for a stream to be ready to accept data
 * Reset: 0xa         Access: RW
 */
#define EC_MSW_BC_TIMER_MASK             0x0000FFFF
#define EC_MSW_BC_TIMER_SHIFT            0
/*
 * Drop packet if target queue in UDMA is full.
 * Reset: 0x0         Access: RW
 */
#define EC_MSW_BC_Q_FULL_DROP_MASK       0x000F0000
#define EC_MSW_BC_Q_FULL_DROP_SHIFT      16
/*
 * Drop packet if timer expires.
 * Reset: 0x0         Access: RW
 */
#define EC_MSW_BC_TIMER_DROP_MASK        0x0F000000
#define EC_MSW_BC_TIMER_DROP_SHIFT       24

/**** in_cfg register ****/
/*
 * Swap input bytes order
 * Reset: 0x1         Access: RW
 */
#define EC_TSO_IN_CFG_SWAP_BYTES         (1 << 0)
/*
 * Selects strict priority or round robin scheduling between UDMA inputs
 * 0 - RR
 * 1 - SP
 * Reset: 0x0         Access: RW
 */
#define EC_TSO_IN_CFG_SEL_SP_RR          (1 << 1)
/*
 * Selects scheduler numbering direction.
 * 0 - Low to high
 * 1 - High to low
 * Reset: 0x0         Access: RW
 */
#define EC_TSO_IN_CFG_SEL_SCH_DIR        (1 << 2)
/*
 * Select schduelr credit grant mode:
 * 0 - count resource available cycles
 * 1 - Count all cycle
 * Reset: 0x0         Access: RW
 */
#define EC_TSO_IN_CFG_SEL_RR_GRANT_MODE  (1 << 3)
/*
 * Minimum L2 packet size (not including FCS)
 * Reset: 0x3c        Access: RW
 */
#define EC_TSO_IN_CFG_L2_MIN_SIZE_MASK   0x00007F00
#define EC_TSO_IN_CFG_L2_MIN_SIZE_SHIFT  8
/*
 * Swap input bytes order
 * Reset: 0x1         Access: RW
 */
#define EC_TSO_IN_CFG_SP_INIT_VAL_MASK   0x000F0000
#define EC_TSO_IN_CFG_SP_INIT_VAL_SHIFT  16

/**** cache_table_addr register ****/
/*
 * Address for accessing the table
 * Reset: 0x0         Access: RW
 */
#define EC_TSO_CACHE_TABLE_ADDR_VAL_MASK 0x0000003F
#define EC_TSO_CACHE_TABLE_ADDR_VAL_SHIFT 0

/**** ctrl_first register ****/
/*
 * Data to be written into the control BIS.
 * Reset: 0x0         Access: RW
 */
#define EC_TSO_CTRL_FIRST_DATA_MASK      0x000001FF
#define EC_TSO_CTRL_FIRST_DATA_SHIFT     0
/*
 * Mask for control bits.
 * [0] - Use original packet header.
 * [1] - Use new value from data field.
 * Reset: 0x9         Access: RW
 */
#define EC_TSO_CTRL_FIRST_MASK_MASK      0x01FF0000
#define EC_TSO_CTRL_FIRST_MASK_SHIFT     16

/**** ctrl_middle register ****/
/*
 * Data to be written into the control BIS.
 * Reset: 0x0         Access: RW
 */
#define EC_TSO_CTRL_MIDDLE_DATA_MASK     0x000001FF
#define EC_TSO_CTRL_MIDDLE_DATA_SHIFT    0
/*
 * Mask for the control bits.
 * [0] - Use original packet header.
 * [1] - Use new value from data field.
 * Reset: 0x9         Access: RW
 */
#define EC_TSO_CTRL_MIDDLE_MASK_MASK     0x01FF0000
#define EC_TSO_CTRL_MIDDLE_MASK_SHIFT    16

/**** ctrl_last register ****/
/*
 * Data to be written into the control BIS.
 * Reset: 0x0         Access: RW
 */
#define EC_TSO_CTRL_LAST_DATA_MASK       0x000001FF
#define EC_TSO_CTRL_LAST_DATA_SHIFT      0
/*
 * Mask for the control bits.
 * [0] - Use original packet header.
 * [1] - Use new value from data field.
 * Reset: 0x0         Access: RW
 */
#define EC_TSO_CTRL_LAST_MASK_MASK       0x01FF0000
#define EC_TSO_CTRL_LAST_MASK_SHIFT      16

/**** cfg_add_0 register ****/
/*
 * MSS selection option:
 * 0 - MSS value is selected using MSS_sel field from  the Metadata, selection between 8 registers
 * (tso_mss_sel_val)
 * 1 - MSS value is directly specified in the Metadata {MSS_msb,MSS_lsb}
 * Reset: 0x0         Access: RW
 */
#define EC_TSO_CFG_ADD_0_MSS_SEL         (1 << 0)

/**** cfg_tunnel register ****/
/*
 * Enable TSO with tunnelling
 * Reset: 0x0         Access: RW
 */
#define EC_TSO_CFG_TUNNEL_EN_TUNNEL_TSO  (1 << 0)
/*
 * Enable outer UDP checksum update
 * Reset: 0x0         Access: RW
 */
#define EC_TSO_CFG_TUNNEL_EN_UDP_CHKSUM  (1 << 8)
/*
 * Enable outer UDP length update
 * Reset: 0x0         Access: RW
 */
#define EC_TSO_CFG_TUNNEL_EN_UDP_LEN     (1 << 9)
/*
 * Enable outer Ip6  length update
 * Reset: 0x0         Access: RW
 */
#define EC_TSO_CFG_TUNNEL_EN_IPV6_PLEN   (1 << 10)
/*
 * Enable outer IPv4 checksum update
 * Reset: 0x0         Access: RW
 */
#define EC_TSO_CFG_TUNNEL_EN_IPV4_CHKSUM (1 << 11)
/*
 * Enable outer IPv4 Identification update
 * Reset: 0x0         Access: RW
 */
#define EC_TSO_CFG_TUNNEL_EN_IPV4_IDEN   (1 << 12)
/*
 * Enable outer IPv4 length update
 * Reset: 0x0         Access: RW
 */
#define EC_TSO_CFG_TUNNEL_EN_IPV4_TLEN   (1 << 13)

/**** arb_config register ****/
/*
 * Per DWRR master, enable low priorty arbiter grant when credits are negative
 * Reset: 0xf         Access: RW
 */
#define EC_TSO_ARB_CONFIG_MODE_NEG_CRED_EN_MASK 0x0000000F
#define EC_TSO_ARB_CONFIG_MODE_NEG_CRED_EN_SHIFT 0
/*
 * Interval between between grants, counted according to mode_grant field
 * Reset: 0x4         Access: RW
 */
#define EC_TSO_ARB_CONFIG_CREDIT_GRANT_INTERVAL_MASK 0x0000FF00
#define EC_TSO_ARB_CONFIG_CREDIT_GRANT_INTERVAL_SHIFT 8

/**** arb_cred_level register ****/
/*
 * Minimum number of credit to get arbiter grant
 * Reset: 0x120       Access: RW
 */
#define EC_TSO_ARB_CRED_LEVEL_CREDIT_THRESHOLD_MASK 0x000003FF
#define EC_TSO_ARB_CRED_LEVEL_CREDIT_THRESHOLD_SHIFT 0
/*
 * Maximum number of accurable credits
 * Reset: 0x130       Access: RW
 */
#define EC_TSO_ARB_CRED_LEVEL_CREDIT_SATURATION_MASK 0x03FF0000
#define EC_TSO_ARB_CRED_LEVEL_CREDIT_SATURATION_SHIFT 16

/**** arb_cred_grant register ****/
/* Reset: 0x1         Access: RW */
#define EC_TSO_ARB_CRED_GRANT_MASTER0_GRANT_MASK 0x0000000F
#define EC_TSO_ARB_CRED_GRANT_MASTER0_GRANT_SHIFT 0
/* Reset: 0x1         Access: RW */
#define EC_TSO_ARB_CRED_GRANT_MASTER1_GRANT_MASK 0x00000F00
#define EC_TSO_ARB_CRED_GRANT_MASTER1_GRANT_SHIFT 8
/* Reset: 0x1         Access: RW */
#define EC_TSO_ARB_CRED_GRANT_MASTER2_GRANT_MASK 0x000F0000
#define EC_TSO_ARB_CRED_GRANT_MASTER2_GRANT_SHIFT 16
/* Reset: 0x1         Access: RW */
#define EC_TSO_ARB_CRED_GRANT_MASTER3_GRANT_MASK 0x0F000000
#define EC_TSO_ARB_CRED_GRANT_MASTER3_GRANT_SHIFT 24

/**** arb_sop_cost register ****/
/*
 * Master 0 start of packet credit cost
 * Reset: 0x1         Access: RW
 */
#define EC_TSO_ARB_SOP_COST_MASTER0_SOP_C_MASK 0x0000000F
#define EC_TSO_ARB_SOP_COST_MASTER0_SOP_C_SHIFT 0
/*
 * Master 1 start of packet credit cost
 * Reset: 0x1         Access: RW
 */
#define EC_TSO_ARB_SOP_COST_MASTER1_SOP_C_MASK 0x00000F00
#define EC_TSO_ARB_SOP_COST_MASTER1_SOP_C_SHIFT 8
/*
 * Master 2 start of packet credit cost
 * Reset: 0x1         Access: RW
 */
#define EC_TSO_ARB_SOP_COST_MASTER2_SOP_C_MASK 0x000F0000
#define EC_TSO_ARB_SOP_COST_MASTER2_SOP_C_SHIFT 16
/*
 * Master 3 start of packet credit cost
 * Reset: 0x1         Access: RW
 */
#define EC_TSO_ARB_SOP_COST_MASTER3_SOP_C_MASK 0x0F000000
#define EC_TSO_ARB_SOP_COST_MASTER3_SOP_C_SHIFT 24

/**** arb_eop_cost register ****/
/*
 * Master 0 end of packet credit cost
 * Reset: 0x1         Access: RW
 */
#define EC_TSO_ARB_EOP_COST_MASTER0_EOP_C_MASK 0x0000000F
#define EC_TSO_ARB_EOP_COST_MASTER0_EOP_C_SHIFT 0
/*
 * Master 1 end of packet credit cost
 * Reset: 0x1         Access: RW
 */
#define EC_TSO_ARB_EOP_COST_MASTER1_EOP_C_MASK 0x00000F00
#define EC_TSO_ARB_EOP_COST_MASTER1_EOP_C_SHIFT 8
/*
 * Master 2 end of packet credit cost
 * Reset: 0x1         Access: RW
 */
#define EC_TSO_ARB_EOP_COST_MASTER2_EOP_C_MASK 0x000F0000
#define EC_TSO_ARB_EOP_COST_MASTER2_EOP_C_SHIFT 16
/*
 * Master 3 end of packet credit cost
 * Reset: 0x1         Access: RW
 */
#define EC_TSO_ARB_EOP_COST_MASTER3_EOP_C_MASK 0x0F000000
#define EC_TSO_ARB_EOP_COST_MASTER3_EOP_C_SHIFT 24

/**** arb_data_cost register ****/
/*
 * Master 0 regualr data credit cost
 * Reset: 0x1         Access: RW
 */
#define EC_TSO_ARB_DATA_COST_MASTER0_DATA_C_MASK 0x0000000F
#define EC_TSO_ARB_DATA_COST_MASTER0_DATA_C_SHIFT 0
/*
 * Master 1 regualr data credit cost
 * Reset: 0x1         Access: RW
 */
#define EC_TSO_ARB_DATA_COST_MASTER1_DATA_C_MASK 0x00000F00
#define EC_TSO_ARB_DATA_COST_MASTER1_DATA_C_SHIFT 8
/*
 * Master 2 regualr data credit cost
 * Reset: 0x1         Access: RW
 */
#define EC_TSO_ARB_DATA_COST_MASTER2_DATA_C_MASK 0x000F0000
#define EC_TSO_ARB_DATA_COST_MASTER2_DATA_C_SHIFT 16
/*
 * Master 3 regualr data credit cost
 * Reset: 0x1         Access: RW
 */
#define EC_TSO_ARB_DATA_COST_MASTER3_DATA_C_MASK 0x0F000000
#define EC_TSO_ARB_DATA_COST_MASTER3_DATA_C_SHIFT 24

/**** mss register ****/
/*
 * MSS value
 * Reset: 0x578       Access: RW
 */
#define EC_TSO_SEL_MSS_VAL_MASK          0x000FFFFF
#define EC_TSO_SEL_MSS_VAL_SHIFT         0

/**** parse register ****/
/*
 * Max number of bus beats for parsing
 * Reset: 0xc         Access: RW
 */
#define EC_TPE_PARSE_MAX_BEATS_MASK      0x0000FFFF
#define EC_TPE_PARSE_MAX_BEATS_SHIFT     0

/**** vlan_data register ****/
/*
 * UDMA default VLAN 1 data
 * Reset: 0x0         Access: RW
 */
#define EC_TPM_UDMA_VLAN_DATA_DEF_1_MASK 0x0000FFFF
#define EC_TPM_UDMA_VLAN_DATA_DEF_1_SHIFT 0
/*
 * UDMA default VLAN 2 data
 * Reset: 0x0         Access: RW
 */
#define EC_TPM_UDMA_VLAN_DATA_DEF_2_MASK 0xFFFF0000
#define EC_TPM_UDMA_VLAN_DATA_DEF_2_SHIFT 16

/**** mac_sa_2 register ****/
/*
 * MAC source address data [47:32]
 * Reset: 0x0         Access: RW
 */
#define EC_TPM_UDMA_MAC_SA_2_H_VAL_MASK  0x0000FFFF
#define EC_TPM_UDMA_MAC_SA_2_H_VAL_SHIFT 0
/*
 * Drop indication for MAC SA spoofing
 * 0 - Don't drop.
 * 1 - Drop if MCA SA mismatch.
 * Reset: 0x0         Access: RW
 */
#define EC_TPM_UDMA_MAC_SA_2_DROP        (1 << 16)
/*
 * Replace indication for MAC SA spoofing
 * 0 - Don't replace.
 * 1 - Replace if MCA SA mismatch.
 * Reset: 0x0         Access: RW
 */
#define EC_TPM_UDMA_MAC_SA_2_REPLACE     (1 << 17)

/**** etype register ****/
/*
 * Ether type value
 * Reset: 0x8100      Access: RW
 */
#define EC_TPM_SEL_ETYPE_VAL_MASK        0x0000FFFF
#define EC_TPM_SEL_ETYPE_VAL_SHIFT       0

/**** tx_wr_fifo register ****/
/*
 * Max data beats that can be used in the Tx FIFO
 * Reset: 0x258       Access: RW
 */
#define EC_TFW_TX_WR_FIFO_DATA_TH_MASK   0x0000FFFF
#define EC_TFW_TX_WR_FIFO_DATA_TH_SHIFT  0
/*
 * Max packets that can be stored in the Tx FIFO
 * Reset: 0x3c        Access: RW
 */
#define EC_TFW_TX_WR_FIFO_INFO_TH_MASK   0xFFFF0000
#define EC_TFW_TX_WR_FIFO_INFO_TH_SHIFT  16

/**** tx_vid_table_addr register ****/
/*
 * Address for accessing the table
 * Reset: 0x0         Access: RW
 */
#define EC_TFW_TX_VID_TABLE_ADDR_VAL_MASK 0x00000FFF
#define EC_TFW_TX_VID_TABLE_ADDR_VAL_SHIFT 0

/**** tx_vid_table_data register ****/
/*
 * Table data (valid only after configuring the table address register)
 *
 * [3:0] - UDMA selection
 * [4] - Select output MAC
 * Reset: 0x0         Access: RW
 */
#define EC_TFW_TX_VID_TABLE_DATA_VAL_MASK 0x0000001F
#define EC_TFW_TX_VID_TABLE_DATA_VAL_SHIFT 0

/**** tx_rd_fifo register ****/
/*
 * Read data threshold when cut through mode is enabled.
 * Reset: 0x64        Access: RW
 */
#define EC_TFW_TX_RD_FIFO_READ_TH_MASK   0x0000FFFF
#define EC_TFW_TX_RD_FIFO_READ_TH_SHIFT  0
/*
 * Enable cut through operation of the Tx FIFO.
 * Reset: 0x0         Access: RW
 */
#define EC_TFW_TX_RD_FIFO_EN_CUT_THROUGH (1 << 16)

/**** tx_checksum register ****/
/*
 * Enable L3 checksum insertion.
 * Reset: 0x1         Access: RW
 */
#define EC_TFW_TX_CHECKSUM_L3_EN         (1 << 0)
/*
 * Enable L4 checksum insertion.
 * Reset: 0x1         Access: RW
 */
#define EC_TFW_TX_CHECKSUM_L4_EN         (1 << 1)
/*
 * Enable L4 checksum when L3 fragmentation is detected.
 * Reset: 0x1         Access: RW
 */
#define EC_TFW_TX_CHECKSUM_L4_FRAG_EN    (1 << 2)
/*
 * checksum value to be flipped (see rfc 1624)
 * Reset: 0x0         Access: RW
 */
#define EC_TFW_TX_CHECKSUM_TCP_CKS_VAL_FLIP_MASK 0x00FFFF00
#define EC_TFW_TX_CHECKSUM_TCP_CKS_VAL_FLIP_SHIFT 8
/*
 * En able for checksum value to be flipped (see rfc 1624)
 * Reset: 0x0         Access: RW
 */
#define EC_TFW_TX_CHECKSUM_TCP_CKS_VAL_FLIP_EN (1 << 24)
/*
 * Enable for checksum ok override (see rfc 1624)
 * Reset: 0x0         Access: RW
 */
#define EC_TFW_TX_CHECKSUM_TCP_CKS_OK_OVERRIDE_EN (1 << 25)

/**** tx_gen register ****/
/*
 * Force forward of all Tx packets to MAC.
 * Reset: 0x0         Access: RW
 */
#define EC_TFW_TX_GEN_FWD_ALL_TO_MAC     (1 << 0)
/*
 * Select the Packet generator as the source of Tx packets
 * 0 - Tx packets from data path
 * 1 - Tx packets from packet generator
 * Reset: 0x0         Access: RW
 */
#define EC_TFW_TX_GEN_SELECT_PKT_GEN     (1 << 1)

/**** tx_spf register ****/
/*
 * Select the VID for spoofing check:
 * [0] - Packet VID
 * [1] - Forwarding ID
 * Reset: 0x0         Access: RW
 */
#define EC_TFW_TX_SPF_VID_SEL            (1 << 0)

/**** data_fifo register ****/
/*
 * FIFO used value (number of entries)
 * Reset: 0x0         Access: RO
 */
#define EC_TFW_DATA_FIFO_USED_MASK       0x0000FFFF
#define EC_TFW_DATA_FIFO_USED_SHIFT      0
/*
 * FIFO FULL status
 * Reset: 0x0         Access: RO
 */
#define EC_TFW_DATA_FIFO_FULL            (1 << 16)
/*
 * FIFO EMPTY status
 * Reset: 0x0         Access: RO
 */
#define EC_TFW_DATA_FIFO_EMPTY           (1 << 17)

/**** ctrl_fifo register ****/
/*
 * FIFO used value (number of entries)
 * Reset: 0x0         Access: RO
 */
#define EC_TFW_CTRL_FIFO_USED_MASK       0x0000FFFF
#define EC_TFW_CTRL_FIFO_USED_SHIFT      0
/*
 * FIFO FULL status
 * Reset: 0x0         Access: RO
 */
#define EC_TFW_CTRL_FIFO_FULL            (1 << 16)
/*
 * FIFO EMPTY status
 * Reset: 0x0         Access: RO
 */
#define EC_TFW_CTRL_FIFO_EMPTY           (1 << 17)

/**** hdr_fifo register ****/
/*
 * FIFO used value (number of entries)
 * Reset: 0x0         Access: RO
 */
#define EC_TFW_HDR_FIFO_USED_MASK        0x0000FFFF
#define EC_TFW_HDR_FIFO_USED_SHIFT       0
/*
 * FIFO FULL status
 * Reset: 0x0         Access: RO
 */
#define EC_TFW_HDR_FIFO_FULL             (1 << 16)
/*
 * FIFO EMPTY status
 * Reset: 0x0         Access: RO
 */
#define EC_TFW_HDR_FIFO_EMPTY            (1 << 17)

/**** out register ****/
/*
 * axi stream error indication selector
 * 0 - take error indication before sample
 * 1 - take error indication ater sample
 * Reset: 0x1         Access: RW
 */
#define EC_TFW_OUT_S_ERR_SEL             (1 << 0)
/*
 * fsm_pkt_to_idle selector
 * 0 - eop at fifo (legacy)
 * 1 - eop at output
 * Reset: 0x0         Access: RW
 */
#define EC_TFW_OUT_FSM_PKT_TO_IDLE_SEL   (1 << 1)
/*
 * fsm_idle_to_pkt selector
 * Reset: 0x0         Access: RW
 */
#define EC_TFW_OUT_FSM_IDLE_TO_PKT_SEL   (1 << 2)
/*
 * fsm_idle_to_pkt_light selector
 * Reset: 0x0         Access: RW
 */
#define EC_TFW_OUT_FSM_IDLE_TO_PKT_LIGHT_SEL (1 << 3)

/**** uc_udma register ****/
/*
 * Default UDMA bitmap
 * (MSB represents physical port)
 * Reset: 0x10        Access: RW
 */
#define EC_TFW_UDMA_UC_UDMA_DEF_MASK     0x0000001F
#define EC_TFW_UDMA_UC_UDMA_DEF_SHIFT    0

/**** mc_udma register ****/
/*
 * Default UDMA bitmap (MSB represents physical port.)
 * Reset: 0x10        Access: RW
 */
#define EC_TFW_UDMA_MC_UDMA_DEF_MASK     0x0000001F
#define EC_TFW_UDMA_MC_UDMA_DEF_SHIFT    0

/**** bc_udma register ****/
/*
 * Default UDMA bitmap (MSB represents physical port.)
 * Reset: 0x10        Access: RW
 */
#define EC_TFW_UDMA_BC_UDMA_DEF_MASK     0x0000001F
#define EC_TFW_UDMA_BC_UDMA_DEF_SHIFT    0

/**** spf_cmd register ****/
/*
 * Command for the VLAN spoofing
 * 00 - Ignore mismatch.
 * 01 - Drop packet with mismatch
 * 10 - Replace with default value per UDMA if there is a mismatch.
 * 11 - Always replace with default value per UDMA.
 * Reset: 0x0         Access: RW
 */
#define EC_TFW_UDMA_SPF_CMD_VID_MASK     0x00000003
#define EC_TFW_UDMA_SPF_CMD_VID_SHIFT    0
/*
 * Command for VLAN spoofing
 * 00 - Ignore mismatch.
 * 01 - Drop packet with mismatch.
 * 10 - Replace with default value per UDMA if there is a mismatch.
 * 11 - Always replace with default value per UDMA/
 * Reset: 0x0         Access: RW
 */
#define EC_TFW_UDMA_SPF_CMD_MAC_MASK     0x0000000C
#define EC_TFW_UDMA_SPF_CMD_MAC_SHIFT    2

/**** fwd_dec register ****/
/*
 * Forwarding decision control:
 * [0] - Enable internal switch.
 * [3:1] - Switch FID selection
 *    000 - First VLAN VID (only valid if source_VLAN_count = 01 or 10)
 *    001 - Second VLAN VID (only valid if source_VLAN_count = 10)
 *    010 - New VLAN 1 VID
 *    011 - New VLAN 2 VID
 *    100 - Default UDMA VLAN VID
 *    101 -  Packet first VLAN VID (after modification)
 *    110 - 111 - Reserved
 *
 * [5:4] - Forwarding decision control for broadcast packets
 *   00 - N/A
 *   01 - Based on VLAN address
 *   10 - N/A
 *   11 - Pass through
 *
 * [7:6] - Forwarding decision control for multicast
 *   00 - Based on MAC address
 *   01 - Based on VLAN address
 *   10 - Based on MAC + VLAN
 *   11 - Pass through
 *
 * [9:8] - Forwarding decision control for unicast00 - based on MAC address
 *   01 - Based on VLAN address
 *   10 - Based on MAC + VLAN
 *   11 - Pass through
 * Reset: 0x0         Access: RW
 */
#define EC_TFW_UDMA_FWD_DEC_CTRL_MASK    0x000003FF
#define EC_TFW_UDMA_FWD_DEC_CTRL_SHIFT   0
/*
 * enable forwarding to same udma for broadcast packets
 * Reset: 0x1         Access: RW
 */
#define EC_TFW_UDMA_FWD_DEC_SAME_UDMA_EN_BC (1 << 10)
/*
 * enable forwarding to same udma for multicast packets
 * Reset: 0x1         Access: RW
 */
#define EC_TFW_UDMA_FWD_DEC_SAME_UDMA_EN_MC (1 << 11)
/*
 * enable forwarding to same udma for unicast packets
 * Reset: 0x1         Access: RW
 */
#define EC_TFW_UDMA_FWD_DEC_SAME_UDMA_EN_UC (1 << 12)

/**** tx_cfg register ****/
/*
 * Swap output byte order
 * Reset: 0x1         Access: RW
 */
#define EC_TMI_TX_CFG_SWAP_BYTES         (1 << 0)
/*
 * Enable forwarding to the Rx data path.
 * Reset: 0x0         Access: RW
 */
#define EC_TMI_TX_CFG_EN_FWD_TO_RX       (1 << 1)
/*
 * Force forwarding all packets to the MAC.
 * Reset: 0x0         Access: RW
 */
#define EC_TMI_TX_CFG_FORCE_FWD_MAC      (1 << 2)
/*
 * Force forwarding all packets to the MAC.
 * Reset: 0x0         Access: RW
 */
#define EC_TMI_TX_CFG_FORCE_FWD_RX       (1 << 3)
/*
 * Force loopback operation.
 * All packets are forwarded to the Rx and not to the MAC, regardless of other configurations.
 * Reset: 0x0         Access: RW
 */
#define EC_TMI_TX_CFG_FORCE_LB           (1 << 4)
/*
 * 0 - zero padding disabled
 * 1 - zero padding enabled, data bus will be padded with zero according to input bus byte cnt
 * Reset: 0x1         Access: RW
 */
#define EC_TMI_TX_CFG_ZERO_PAD_EN        (1 << 7)
/*
 * [0] tmi stop - mask abort_ec trigger
 * [1] tmi flush - mask abort_ec trigger
 * [2] tmi error - mask abort_ec trigger
 * [3] tmi cmpl error - mask abort_ec trigger
 * [4] tmi cmpl meta 0 error - mask abort_ec trigger
 * [5] tmi cmpl meta 1 error - mask abort_ec trigger
 *
 * [6] tmi stop - mask tfw partiy error
 * [7] tmi flush - mask tfw partiy error
 * [8] tmi error - mask tfw partiy error
 * [9] tmi cmpl error - mask tfw partiy error
 * [10] tmi cmpl meta 0 error - mask tfw partiy error
 * [11] tmi cmpl meta 1 error - mask tfw partiy error
 * Reset: 0x555       Access: RW
 */
#define EC_TMI_TX_CFG_ABORT_MASK_MASK    0x000FFF00
#define EC_TMI_TX_CFG_ABORT_MASK_SHIFT   8
/*
 * mask tfw  data path fifos memories parity error {eop, sop, data2[1:0], data1[1:0]}
 * Reset: 0x3f        Access: RW
 */
#define EC_TMI_TX_CFG_TFW_PAR_ERR_MASK_MASK 0x3F000000
#define EC_TMI_TX_CFG_TFW_PAR_ERR_MASK_SHIFT 24

/**** ec_pause register ****/
/*
 * Mask of pause_on [7:0]
 * Reset: 0x0         Access: RW
 */
#define EC_EFC_EC_PAUSE_MASK_MAC_MASK    0x000000FF
#define EC_EFC_EC_PAUSE_MASK_MAC_SHIFT   0
/*
 * Mask of GPIO input [7:0]
 * Reset: 0x0         Access: RW
 */
#define EC_EFC_EC_PAUSE_MASK_GPIO_MASK   0x0000FF00
#define EC_EFC_EC_PAUSE_MASK_GPIO_SHIFT  8

/**** ec_xoff register ****/
/*
 * Mask 1 for XOFF [7:0]
 * Mask 1 for Almost Full indication,
 * Reset: 0x0         Access: RW
 */
#define EC_EFC_EC_XOFF_MASK_1_MASK       0x000000FF
#define EC_EFC_EC_XOFF_MASK_1_SHIFT      0
/*
 * Mask 2 for XOFF [7:0]
 * Mask 2 for sampled Almost Full indication (with hysteresis)
 * Reset: 0x0         Access: RW
 */
#define EC_EFC_EC_XOFF_MASK_2_MASK       0x0000FF00
#define EC_EFC_EC_XOFF_MASK_2_SHIFT      8

/**** xon register ****/
/*
 * Mask 1 for generating XON pulse, masking XOFF [0]
 * Reset: 0x0         Access: RW
 */
#define EC_EFC_XON_MASK_1                (1 << 0)
/*
 * Mask 2 for generating XON pulse, masking Almost Full indication (with hysteresis) from the
 * Ethernet controller Rx FIFO
 * Reset: 0x0         Access: RW
 */
#define EC_EFC_XON_MASK_2                (1 << 1)

/**** gpio register ****/
/*
 * Mask for generating GPIO output XOFF indication from XOFF[0]
 * Reset: 0x0         Access: RW
 */
#define EC_EFC_GPIO_MASK_1               (1 << 0)

/**** rx_fifo_af register ****/
/*
 * Threshold
 * Reset: 0x0         Access: RW
 */
#define EC_EFC_RX_FIFO_AF_TH_MASK        0x0000FFFF
#define EC_EFC_RX_FIFO_AF_TH_SHIFT       0

/**** rx_fifo_hyst register ****/
/*
 * Threshold low
 * Reset: 0x0         Access: RW
 */
#define EC_EFC_RX_FIFO_HYST_TH_LOW_MASK  0x0000FFFF
#define EC_EFC_RX_FIFO_HYST_TH_LOW_SHIFT 0
/*
 * Threshold high
 * Reset: 0x0         Access: RW
 */
#define EC_EFC_RX_FIFO_HYST_TH_HIGH_MASK 0xFFFF0000
#define EC_EFC_RX_FIFO_HYST_TH_HIGH_SHIFT 16

/**** stat register ****/
/*
 * 10G MAC PFC mode, input from the 10 MAC
 * Reset: 0x0         Access: RO
 */
#define EC_EFC_STAT_PFC_MODE             (1 << 0)

/**** ec_pfc register ****/
/*
 * Force PFC flow control
 * Reset: 0x0         Access: RW
 */
#define EC_EFC_EC_PFC_FORCE_PFC_MASK     0x000000FF
#define EC_EFC_EC_PFC_FORCE_PFC_SHIFT    0

/**** q_pause_0 register ****/
/*
 * [i] - Mask for Q[i]
 * Reset: 0x0         Access: RW
 */
#define EC_FC_UDMA_Q_PAUSE_0_MASK_MASK   0x0000FFFF
#define EC_FC_UDMA_Q_PAUSE_0_MASK_SHIFT  0

/**** q_pause_1 register ****/
/*
 * [i] - Mask for Q[i]
 * Reset: 0x0         Access: RW
 */
#define EC_FC_UDMA_Q_PAUSE_1_MASK_MASK   0x0000FFFF
#define EC_FC_UDMA_Q_PAUSE_1_MASK_SHIFT  0

/**** q_pause_2 register ****/
/*
 * [i] - Mask for Q[i]
 * Reset: 0x0         Access: RW
 */
#define EC_FC_UDMA_Q_PAUSE_2_MASK_MASK   0x0000FFFF
#define EC_FC_UDMA_Q_PAUSE_2_MASK_SHIFT  0

/**** q_pause_3 register ****/
/*
 * [i] - Mask for Q[i]
 * Reset: 0x0         Access: RW
 */
#define EC_FC_UDMA_Q_PAUSE_3_MASK_MASK   0x0000FFFF
#define EC_FC_UDMA_Q_PAUSE_3_MASK_SHIFT  0

/**** q_pause_4 register ****/
/*
 * [i] - Mask for Q[i]
 * Reset: 0x0         Access: RW
 */
#define EC_FC_UDMA_Q_PAUSE_4_MASK_MASK   0x0000FFFF
#define EC_FC_UDMA_Q_PAUSE_4_MASK_SHIFT  0

/**** q_pause_5 register ****/
/*
 * [i] - Mask for Q[i]
 * Reset: 0x0         Access: RW
 */
#define EC_FC_UDMA_Q_PAUSE_5_MASK_MASK   0x0000FFFF
#define EC_FC_UDMA_Q_PAUSE_5_MASK_SHIFT  0

/**** q_pause_6 register ****/
/*
 * [i] - Mask for Q[i]
 * Reset: 0x0         Access: RW
 */
#define EC_FC_UDMA_Q_PAUSE_6_MASK_MASK   0x0000FFFF
#define EC_FC_UDMA_Q_PAUSE_6_MASK_SHIFT  0

/**** q_pause_7 register ****/
/*
 * [i] - Mask for Q[i]
 * Reset: 0x0         Access: RW
 */
#define EC_FC_UDMA_Q_PAUSE_7_MASK_MASK   0x0000FFFF
#define EC_FC_UDMA_Q_PAUSE_7_MASK_SHIFT  0

/**** q_gpio_0 register ****/
/*
 * [i] - Mask for Q[i]
 * Reset: 0x0         Access: RW
 */
#define EC_FC_UDMA_Q_GPIO_0_MASK_MASK    0x0000FFFF
#define EC_FC_UDMA_Q_GPIO_0_MASK_SHIFT   0

/**** q_gpio_1 register ****/
/*
 * [i] - Mask for Q[i]
 * Reset: 0x0         Access: RW
 */
#define EC_FC_UDMA_Q_GPIO_1_MASK_MASK    0x0000FFFF
#define EC_FC_UDMA_Q_GPIO_1_MASK_SHIFT   0

/**** q_gpio_2 register ****/
/*
 * [i] - Mask for Q[i]
 * Reset: 0x0         Access: RW
 */
#define EC_FC_UDMA_Q_GPIO_2_MASK_MASK    0x0000FFFF
#define EC_FC_UDMA_Q_GPIO_2_MASK_SHIFT   0

/**** q_gpio_3 register ****/
/*
 * [i] - Mask for Q[i]
 * Reset: 0x0         Access: RW
 */
#define EC_FC_UDMA_Q_GPIO_3_MASK_MASK    0x0000FFFF
#define EC_FC_UDMA_Q_GPIO_3_MASK_SHIFT   0

/**** q_gpio_4 register ****/
/*
 * [i] - Mask for Q[i]
 * Reset: 0x0         Access: RW
 */
#define EC_FC_UDMA_Q_GPIO_4_MASK_MASK    0x0000FFFF
#define EC_FC_UDMA_Q_GPIO_4_MASK_SHIFT   0

/**** q_gpio_5 register ****/
/*
 * [i] - Mask for Q[i]
 * Reset: 0x0         Access: RW
 */
#define EC_FC_UDMA_Q_GPIO_5_MASK_MASK    0x0000FFFF
#define EC_FC_UDMA_Q_GPIO_5_MASK_SHIFT   0

/**** q_gpio_6 register ****/
/*
 * [i] - Mask for Q[i]
 * Reset: 0x0         Access: RW
 */
#define EC_FC_UDMA_Q_GPIO_6_MASK_MASK    0x0000FFFF
#define EC_FC_UDMA_Q_GPIO_6_MASK_SHIFT   0

/**** q_gpio_7 register ****/
/*
 * [i] - Mask for Q[i]
 * Reset: 0x0         Access: RW
 */
#define EC_FC_UDMA_Q_GPIO_7_MASK_MASK    0x0000FFFF
#define EC_FC_UDMA_Q_GPIO_7_MASK_SHIFT   0

/**** s_pause register ****/
/*
 * Mask of pause_on [7:0]
 * Reset: 0x0         Access: RW
 */
#define EC_FC_UDMA_S_PAUSE_MASK_MAC_MASK 0x000000FF
#define EC_FC_UDMA_S_PAUSE_MASK_MAC_SHIFT 0
/*
 * Mask of GPIO input  [7:0]
 * Reset: 0x0         Access: RW
 */
#define EC_FC_UDMA_S_PAUSE_MASK_GPIO_MASK 0x0000FF00
#define EC_FC_UDMA_S_PAUSE_MASK_GPIO_SHIFT 8

/**** q_xoff_0 register ****/
/*
 * [i] - Mask for Q[i]
 * Reset: 0x0         Access: RW
 */
#define EC_FC_UDMA_Q_XOFF_0_MASK_MASK    0x0000FFFF
#define EC_FC_UDMA_Q_XOFF_0_MASK_SHIFT   0

/**** q_xoff_1 register ****/
/*
 * [i] - Mask for Q[i]
 * Reset: 0x0         Access: RW
 */
#define EC_FC_UDMA_Q_XOFF_1_MASK_MASK    0x0000FFFF
#define EC_FC_UDMA_Q_XOFF_1_MASK_SHIFT   0

/**** q_xoff_2 register ****/
/*
 * [i] - Mask for Q[i]
 * Reset: 0x0         Access: RW
 */
#define EC_FC_UDMA_Q_XOFF_2_MASK_MASK    0x0000FFFF
#define EC_FC_UDMA_Q_XOFF_2_MASK_SHIFT   0

/**** q_xoff_3 register ****/
/*
 * [i] - Mask for Q[i]
 * Reset: 0x0         Access: RW
 */
#define EC_FC_UDMA_Q_XOFF_3_MASK_MASK    0x0000FFFF
#define EC_FC_UDMA_Q_XOFF_3_MASK_SHIFT   0

/**** q_xoff_4 register ****/
/*
 * [i] - Mask for Q[i]
 * Reset: 0x0         Access: RW
 */
#define EC_FC_UDMA_Q_XOFF_4_MASK_MASK    0x0000FFFF
#define EC_FC_UDMA_Q_XOFF_4_MASK_SHIFT   0

/**** q_xoff_5 register ****/
/*
 * [i] - Mask for Q[i]
 * Reset: 0x0         Access: RW
 */
#define EC_FC_UDMA_Q_XOFF_5_MASK_MASK    0x0000FFFF
#define EC_FC_UDMA_Q_XOFF_5_MASK_SHIFT   0

/**** q_xoff_6 register ****/
/*
 * [i] - Mask for Q[i]
 * Reset: 0x0         Access: RW
 */
#define EC_FC_UDMA_Q_XOFF_6_MASK_MASK    0x0000FFFF
#define EC_FC_UDMA_Q_XOFF_6_MASK_SHIFT   0

/**** q_xoff_7 register ****/
/*
 * [i] - Mask for Q[i]
 * Reset: 0x0         Access: RW
 */
#define EC_FC_UDMA_Q_XOFF_7_MASK_MASK    0x0000FFFF
#define EC_FC_UDMA_Q_XOFF_7_MASK_SHIFT   0

/**** cfg_e register ****/
/*
 * Use MAC Tx FIFO empty status for EEE control.
 * Reset: 0x1         Access: RW
 */
#define EC_EEE_CFG_E_USE_MAC_TX_FIFO     (1 << 0)
/*
 * Use MAC Rx FIFO empty status for EEE control.
 * Reset: 0x0         Access: RW
 */
#define EC_EEE_CFG_E_USE_MAC_RX_FIFO     (1 << 1)
/*
 * Use Ethernet controller Tx FIFO empty status for EEE control.
 * Reset: 0x1         Access: RW
 */
#define EC_EEE_CFG_E_USE_EC_TX_FIFO      (1 << 2)
/*
 * Use Ethernet controller Rx FIFO empty status for EEE control.
 * Reset: 0x0         Access: RW
 */
#define EC_EEE_CFG_E_USE_EC_RX_FIFO      (1 << 3)
/*
 * Enable Low power signalling.
 * Reset: 0x0         Access: RW
 */
#define EC_EEE_CFG_E_ENABLE              (1 << 4)
/*
 * Mask output to MAC.
 * Reset: 0x0         Access: RW
 */
#define EC_EEE_CFG_E_MASK_MAC_EEE        (1 << 8)
/*
 * Mask output to stop MAC interface.
 * Reset: 0x0         Access: RW
 */
#define EC_EEE_CFG_E_MASK_EC_TMI_STOP    (1 << 9)

/**** stat_eee register ****/
/*
 * EEE state
 * Reset: 0x0         Access: RO
 */
#define EC_EEE_STAT_EEE_STATE_MASK       0x0000000F
#define EC_EEE_STAT_EEE_STATE_SHIFT      0
/*
 * EEE detected
 * Reset: 0x0         Access: RO
 */
#define EC_EEE_STAT_EEE_DET              (1 << 4)

/**** p_parse_cfg register ****/
/*
 * MAX number of beats for packet parsing
 * Reset: 0x8         Access: RW
 */
#define EC_MSP_P_PARSE_CFG_MAX_BEATS_MASK 0x000000FF
#define EC_MSP_P_PARSE_CFG_MAX_BEATS_SHIFT 0
/*
 * MAX number of parsing iterations for packet parsing
 * Reset: 0x8         Access: RW
 */
#define EC_MSP_P_PARSE_CFG_MAX_ITER_MASK 0x0000FF00
#define EC_MSP_P_PARSE_CFG_MAX_ITER_SHIFT 8

/**** p_act_table_addr register ****/
/*
 * Address for accessing the table
 * Reset: 0x1         Access: RW
 */
#define EC_MSP_P_ACT_TABLE_ADDR_VAL_MASK 0x0000001F
#define EC_MSP_P_ACT_TABLE_ADDR_VAL_SHIFT 0

/**** p_act_table_data_1 register ****/
/*
 * Table data
 * [5:0] - Offset to next protocol [bytes]
 * [6] - Next protocol is available in packet data
 * [11:7] - Default next protocol index
 * [12] - Write the detected protocol index into the parser result vector [22:13] - Pointer where to
 * write the detected protocol index in the parser result vector
 * [23] - Select which prot_index to write (0 - next, 1 - current)
 * [24] - Select which header length to write (0 - next, 1 - current)
 * [25] - Select which header offset to write (0 - next, 1 - current)
 * Reset: 0x1         Access: RW
 */
#define EC_MSP_P_ACT_TABLE_DATA_1_VAL_MASK 0x03FFFFFF
#define EC_MSP_P_ACT_TABLE_DATA_1_VAL_SHIFT 0

/**** p_act_table_data_2 register ****/
/*
 * Table data
 * [8:0] - Offset to data in the packet [bits]
 * [17:9] - Data size [bits]
 * [18] - Write the data to the parser result vector
 * [28:19] - Pointer where to write the data in the parser result vector [bits]
 * Reset: 0x1         Access: RW
 */
#define EC_MSP_P_ACT_TABLE_DATA_2_VAL_MASK 0x1FFFFFFF
#define EC_MSP_P_ACT_TABLE_DATA_2_VAL_SHIFT 0

/**** p_act_table_data_3 register ****/
/*
 * Table data
 * [8:0] - Offset to data in the packet [bits]
 * [17:9] - Data size [bits]
 * [18] - Write the data to the parser result vector
 * [28:19] - Pointer where to write the data in the parser result vector [bits]
 * Reset: 0x1         Access: RW
 */
#define EC_MSP_P_ACT_TABLE_DATA_3_VAL_MASK 0x1FFFFFFF
#define EC_MSP_P_ACT_TABLE_DATA_3_VAL_SHIFT 0

/**** p_act_table_data_4 register ****/
/*
 * Table data
 * [7:0] - Offset to the header length location in the packet [bits]
 * [12:8] - Header length size [bits [15:13] - Header length units (bit shift)
 * [19:16] - Header length command [27:20] - Default header length
 * Reset: 0x1         Access: RW
 */
#define EC_MSP_P_ACT_TABLE_DATA_4_VAL_MASK 0x0FFFFFFF
#define EC_MSP_P_ACT_TABLE_DATA_4_VAL_SHIFT 0

/**** p_act_table_data_6 register ****/
/*
 * Table data
 * [0] - Wr header length
 * [10:1] - Write header length pointer (write 9 bits)
 * [11] - Write current packet offset [21:12] - Write packet offset pointer (write 9 bits)
 * [22] - Input parse enable field for next parser
 * Reset: 0x1         Access: RW
 */
#define EC_MSP_P_ACT_TABLE_DATA_6_VAL_MASK 0x007FFFFF
#define EC_MSP_P_ACT_TABLE_DATA_6_VAL_SHIFT 0

/**** p_res_in register ****/
/*
 * Selector for input parse_en
 * 0 - Input vector
 * 1 - Default value form res_def register
 * Reset: 0x1         Access: RW
 */
#define EC_MSP_P_RES_IN_SEL_PARSE_EN     (1 << 0)
/*
 * Selector for input protocol_index  0 - Input vector
 * 1 - Default value form res_def register
 * Reset: 0x1         Access: RW
 */
#define EC_MSP_P_RES_IN_SEL_PROT_INDEX   (1 << 1)
/*
 * Selector for input hdr_offset
 * 0 - Input vector
 * 1 - Default value form res_def register
 * Reset: 0x1         Access: RW
 */
#define EC_MSP_P_RES_IN_SEL_HDR_OFFSET   (1 << 2)

/**** h_hdr_len register ****/
/*
 * Value for selecting table 1
 * Reset: 0x0         Access: RW
 */
#define EC_MSP_P_H_HDR_LEN_TABLE_1_MASK  0x000000FF
#define EC_MSP_P_H_HDR_LEN_TABLE_1_SHIFT 0
/*
 * Value for selecting table 2
 * Reset: 0x0         Access: RW
 */
#define EC_MSP_P_H_HDR_LEN_TABLE_2_MASK  0x00FF0000
#define EC_MSP_P_H_HDR_LEN_TABLE_2_SHIFT 16

/**** p_comp_data register ****/
/*
 * Data 1 for comparison
 * Reset: 0x0         Access: RW
 */
#define EC_MSP_C_P_COMP_DATA_DATA_1_MASK 0x0000FFFF
#define EC_MSP_C_P_COMP_DATA_DATA_1_SHIFT 0
/*
 * Data 2 for comparison
 * [18:16] - Stage
 * [24:19] - Branch ID
 * Reset: 0x0         Access: RW
 */
#define EC_MSP_C_P_COMP_DATA_DATA_2_MASK 0x01FF0000
#define EC_MSP_C_P_COMP_DATA_DATA_2_SHIFT 16

/**** p_comp_mask register ****/
/*
 * Data 1 for comparison
 * Reset: 0x0         Access: RW
 */
#define EC_MSP_C_P_COMP_MASK_DATA_1_MASK 0x0000FFFF
#define EC_MSP_C_P_COMP_MASK_DATA_1_SHIFT 0
/*
 * Data 2 for comparison
 * [18:16] - Stage
 * [24:19] - Branch ID
 * Reset: 0x0         Access: RW
 */
#define EC_MSP_C_P_COMP_MASK_DATA_2_MASK 0x01FF0000
#define EC_MSP_C_P_COMP_MASK_DATA_2_SHIFT 16

/**** p_comp_ctrl register ****/
/*
 * Output result value
 * Reset: 0x0         Access: RW
 */
#define EC_MSP_C_P_COMP_CTRL_RES_MASK    0x0000001F
#define EC_MSP_C_P_COMP_CTRL_RES_SHIFT   0
/*
 * Compare command for the data_1 field
 * 00 - Compare
 * 01 - <=
 * 10 - >=
 * 11 - N/A
 * Reset: 0x0         Access: RW
 */
#define EC_MSP_C_P_COMP_CTRL_CMD_1_MASK  0x00030000
#define EC_MSP_C_P_COMP_CTRL_CMD_1_SHIFT 16
/*
 * Compare command for the data_2 field
 * 00 - Compare
 * 01 - <=
 * 10 - >=
 * 11 - N/A
 * Reset: 0x0         Access: RW
 */
#define EC_MSP_C_P_COMP_CTRL_CMD_2_MASK  0x000C0000
#define EC_MSP_C_P_COMP_CTRL_CMD_2_SHIFT 18
/*
 * Entry is valid
 * Reset: 0x0         Access: RW
 */
#define EC_MSP_C_P_COMP_CTRL_VALID       (1 << 31)

/**** gen_cfg register ****/
/*
 * Default result for undetected protocols.
 * Reset: 0x0         Access: RW
 */
#define EC_CRCE_GEN_CFG_RES_DEF          (1 << 0)
/*
 * Enable CRC (RoCE/FCoE) insertion in the Tx data path
 * (override for both RoCE and FCoE separate configuration)
 * Reset: 0x0         Access: RW
 */
#define EC_CRCE_GEN_CFG_EN_TX_CRC_INS    (1 << 4)
/*
 * Enable RoCE insertion in the Tx data path
 * Reset: 0x0         Access: RW
 */
#define EC_CRCE_GEN_CFG_EN_TX_ROCE_INS   (1 << 5)
/*
 * Enable FcoE insertion in the Tx data path
 * Reset: 0x0         Access: RW
 */
#define EC_CRCE_GEN_CFG_EN_TX_FCOE_INS   (1 << 6)
/*
 * Enable CRC (RoCE/FCoE) insertion in the Tx data path (override for both RoCE and FCoE separate
 * configuration)
 * Reset: 0x0         Access: RW
 */
#define EC_CRCE_GEN_CFG_EN_TX_CKS_DIS    (1 << 8)
/*
 * Disable checksum insertion when RoCE packet is detected
 * Reset: 0x0         Access: RW
 */
#define EC_CRCE_GEN_CFG_EN_TX_ROCE_CKS_DIS (1 << 9)
/*
 * Disable checksum insertion when FcoE packet is detected
 * Reset: 0x0         Access: RW
 */
#define EC_CRCE_GEN_CFG_EN_TX_FCOE_CKS_DIS (1 << 10)
/*
 * TX L3 offset selection
 * 0 - Standard L3 offset selection from the descriptor
 * 1 - Outer L3 offset from the descriptor
 * Reset: 0x0         Access: RW
 */
#define EC_CRCE_GEN_CFG_TX_OFFSET_SELECTION (1 << 12)

/**** wol_en register ****/
/*
 * Interrupt enable WoL MAC DA Unicast detected packet
 * Reset: 0x0         Access: RW
 */
#define EC_WOL_WOL_EN_INTRPT_EN_UNICAST  (1 << 0)
/*
 * Interrupt enable WoL L2 Multicast detected packet
 * Reset: 0x0         Access: RW
 */
#define EC_WOL_WOL_EN_INTRPT_EN_MULTICAST (1 << 1)
/*
 * Interrupt enable WoL L2 Broadcast detected packet
 * Reset: 0x0         Access: RW
 */
#define EC_WOL_WOL_EN_INTRPT_EN_BROADCAST (1 << 2)
/*
 * Interrupt enable WoL IPv4 detected packet
 * Reset: 0x0         Access: RW
 */
#define EC_WOL_WOL_EN_INTRPT_EN_IPV4     (1 << 3)
/*
 * Interrupt enable WoL IPv6 detected packet
 * Reset: 0x0         Access: RW
 */
#define EC_WOL_WOL_EN_INTRPT_EN_IPV6     (1 << 4)
/*
 * Interrupt enable WoL EtherType+MAC DA detected packet
 * Reset: 0x0         Access: RW
 */
#define EC_WOL_WOL_EN_INTRPT_EN_ETHERTYPE_DA (1 << 5)
/*
 * Interrupt enable WoL EtherType+L2 Broadcast detected packet
 * Reset: 0x0         Access: RW
 */
#define EC_WOL_WOL_EN_INTRPT_EN_ETHERTYPE_BC (1 << 6)
/*
 * Interrupt enable WoL parser detected packet
 * Reset: 0x0         Access: RW
 */
#define EC_WOL_WOL_EN_INTRPT_EN_PARSER   (1 << 7)
/*
 * Interrupt enable WoL magic detected packet
 * Reset: 0x0         Access: RW
 */
#define EC_WOL_WOL_EN_INTRPT_EN_MAGIC    (1 << 8)
/*
 * Interrupt enable WoL magic+password detected packet
 * Reset: 0x0         Access: RW
 */
#define EC_WOL_WOL_EN_INTRPT_EN_MAGIC_PSWD (1 << 9)
/*
 * Forward enable WoL MAC DA Unicast detected packet
 * Reset: 0x0         Access: RW
 */
#define EC_WOL_WOL_EN_FWRD_EN_UNICAST    (1 << 16)
/*
 * Forward enable WoL L2 Multicast detected packet
 * Reset: 0x0         Access: RW
 */
#define EC_WOL_WOL_EN_FWRD_EN_MULTICAST  (1 << 17)
/*
 * Forward enable WoL L2 Broadcast detected packet
 * Reset: 0x0         Access: RW
 */
#define EC_WOL_WOL_EN_FWRD_EN_BROADCAST  (1 << 18)
/*
 * Forward enable WoL IPv4 detected packet
 * Reset: 0x0         Access: RW
 */
#define EC_WOL_WOL_EN_FWRD_EN_IPV4       (1 << 19)
/*
 * Forward enable WoL IPv6 detected packet
 * Reset: 0x0         Access: RW
 */
#define EC_WOL_WOL_EN_FWRD_EN_IPV6       (1 << 20)
/*
 * Forward enable WoL EtherType+MAC DA detected packet
 * Reset: 0x0         Access: RW
 */
#define EC_WOL_WOL_EN_FWRD_EN_ETHERTYPE_DA (1 << 21)
/*
 * Forward enable WoL EtherType+L2 Broadcast detected packet
 * Reset: 0x0         Access: RW
 */
#define EC_WOL_WOL_EN_FWRD_EN_ETHERTYPE_BC (1 << 22)
/*
 * Forward enable WoL parser detected packet
 * Reset: 0x0         Access: RW
 */
#define EC_WOL_WOL_EN_FWRD_EN_PARSER     (1 << 23)

/**** magic_pswd_h register ****/
/*
 * Password for magic_password packet detection - bits 47:32
 * Reset: 0x0         Access: RW
 */
#define EC_WOL_MAGIC_PSWD_H_VAL_MASK     0x0000FFFF
#define EC_WOL_MAGIC_PSWD_H_VAL_SHIFT    0

/**** ethertype register ****/
/*
 * Configured EtherType 1 for WoL EtherType_da/EtherType_bc packet detection
 * Reset: 0x0         Access: RW
 */
#define EC_WOL_ETHERTYPE_VAL_1_MASK      0x0000FFFF
#define EC_WOL_ETHERTYPE_VAL_1_SHIFT     0
/*
 * Configured EtherType 2 for WoL EtherType_da/EtherType_bc packet detection
 * Reset: 0x0         Access: RW
 */
#define EC_WOL_ETHERTYPE_VAL_2_MASK      0xFFFF0000
#define EC_WOL_ETHERTYPE_VAL_2_SHIFT     16

/**** system_time_subseconds_lsb register ****/
/* Reset: 0x0         Access: RO */
#define EC_PTH_SYSTEM_TIME_SUBSECONDS_LSB_VAL_MASK 0xFFFFC000
#define EC_PTH_SYSTEM_TIME_SUBSECONDS_LSB_VAL_SHIFT 14

/**** clock_period_lsb register ****/
/* Reset: 0x0         Access: RW */
#define EC_PTH_CLOCK_PERIOD_LSB_VAL_MASK 0xFFFFC000
#define EC_PTH_CLOCK_PERIOD_LSB_VAL_SHIFT 14

/**** int_update_ctrl register ****/
/*
 * This field chooses between two methods for SW to update the system time register. The first one
 * (1'b0), is to update the system time register on the next internal_ingress_trigger (which is a
 * self generated trigger). the seconds one (1'b1), is to update the system time register on the
 * next APB write to int_update_seconds
 * 1'b0 - Update on next internal ingress trigger
 * 1'b1 - Update on next write to int_update_seconds
 * Reset: 0x0         Access: RW
 */
#define EC_PTH_INT_UPDATE_CTRL_UPDATE_TRIG (1 << 0)
/*
 * 3'b000 - Set system time according to the value in {int_update_seconds,
 * int_update_subseconds_msb, int_update_subseconds_lsb}
 *
 * 3'b001 - Increment system time by value in {int_update_seconds, int_update_subseconds_msb,
 * int_update_subseconds_lsb}.
 * This update method is used for offset adjustment by slave node)
 *
 * 3'b010 - Decrement system time by value in {int_update_seconds, int_update_subseconds_msb,
 * int_update_subseconds_lsb}.
 * This update method is used for offset adjustment by slave node.
 *
 * 3'b011 - Set system time to be last set system time plus  {int_update_seconds,
 * int_update_subseconds_msb, int_update_subseconds_lsb}.
 * This update method is used in nodes that have GPS / atomic clock / etc (for example, for
 * periodically advancing system time by 1ms).
 * Reset: 0x0         Access: RW
 */
#define EC_PTH_INT_UPDATE_CTRL_UPDATE_METHOD_MASK 0x0000000E
#define EC_PTH_INT_UPDATE_CTRL_UPDATE_METHOD_SHIFT 1
/*
 * 1'b1 - Next update writes to system_time_subseconds
 * 1'b0 - Next update doesn't write to system_time_subseconds
 *
 * For all common use cases, this value should be 1'b1
 * Reset: 0x1         Access: RW
 */
#define EC_PTH_INT_UPDATE_CTRL_SUBSECOND_MASK (1 << 4)
/*
 * 1'b1 - Next update writes to system_time_seconds
 * 1'b0 - Next update doesn't write to system_time_seconds
 *
 * For all common use cases, this value should be 1'b1.
 * Reset: 0x1         Access: RW
 */
#define EC_PTH_INT_UPDATE_CTRL_SECOND_MASK (1 << 5)
/*
 * Enabling / disabling the internal ingress trigger (ingress_trigger #0)
 * 1'b1 - Enabled
 * 1'b0 - Disabled
 * Reset: 0x0         Access: RW
 */
#define EC_PTH_INT_UPDATE_CTRL_INT_TRIG_EN (1 << 16)
/*
 * Determines if internal ingress trigger (ingress_trigger #0) should be treated as pulse or level
 * 1'b1 - Pulse
 * 1'b0 - Level
 * Reset: 0x0         Access: RW
 */
#define EC_PTH_INT_UPDATE_CTRL_PULSE_LEVEL_N (1 << 17)
/*
 * Internal ingress trigger polarity (ingress_trigger #0)
 * 1'b0 - Regular polarity ( i.e.  __________|`````|_____ )
 * 1'b1 - Inverse polarity (i.e. `````````````````|___|``````````)
 * Reset: 0x0         Access: RW
 */
#define EC_PTH_INT_UPDATE_CTRL_POLARITY  (1 << 18)

/**** int_update_subseconds_lsb register ****/
/* Reset: 0x0         Access: RW */
#define EC_PTH_INT_UPDATE_SUBSECONDS_LSB_RESERVED_13_0_MASK 0x00003FFF
#define EC_PTH_INT_UPDATE_SUBSECONDS_LSB_RESERVED_13_0_SHIFT 0
/* Reset: 0x0         Access: RW */
#define EC_PTH_INT_UPDATE_SUBSECONDS_LSB_VAL_MASK 0xFFFFC000
#define EC_PTH_INT_UPDATE_SUBSECONDS_LSB_VAL_SHIFT 14

/**** ext_update_ctrl register ****/
/*
 * 3'b000 - Set system time according to the value in {int_update_seconds,
 * int_update_subseconds_msb, int_update_subseconds_lsb}
 *
 * 3'b001 - Increment system time by value in {ext_update_seconds, ext_update_subseconds_msb,
 * ext_update_subseconds_lsb}.
 * This update method is used for offset adjustment by slave node)
 *
 * 3'b010 - Decrement system time by value in {ext_update_seconds, ext_update_subseconds_msb,
 * ext_update_subseconds_lsb}.
 * This update method is used for offset adjustment by slave node.
 *
 * 3'b011 - Set system time to be last set system time plus  {ext_update_seconds,
 * ext_update_subseconds_msb, ext_update_subseconds_lsb}.
 * This update method is used in nodes that have GPS / atomic clock / etc (for example, for
 * periodically advancing system time by 1ms).
 * Reset: 0x0         Access: RW
 */
#define EC_PTH_EXT_UPDATE_CTRL_UPDATE_METHOD_MASK 0x0000000E
#define EC_PTH_EXT_UPDATE_CTRL_UPDATE_METHOD_SHIFT 1
/*
 * 1'b1 - next update writes to system_time_subseconds
 * 1'b0 - next update doesn't write to system_time_subseconds
 *
 * for all common use cases, this value should be 1'b1
 * Reset: 0x1         Access: RW
 */
#define EC_PTH_EXT_UPDATE_CTRL_SUBSECOND_MASK (1 << 4)
/*
 * 1'b1 - Next update writes to system_time_seconds
 * 1'b0 - Next update doesn't write to system_time_seconds
 *
 * For all common use cases, this value should be 1'b1
 * Reset: 0x1         Access: RW
 */
#define EC_PTH_EXT_UPDATE_CTRL_SECOND_MASK (1 << 5)
/*
 * Enabling / disabling the external ingress triggers (ingress_triggers #1-7)
 * 1'b1 - Enabled
 * 1'b0 - Disabled
 * Reset: 0x0         Access: RW
 */
#define EC_PTH_EXT_UPDATE_CTRL_EXT_TRIG_EN_MASK 0x00007F00
#define EC_PTH_EXT_UPDATE_CTRL_EXT_TRIG_EN_SHIFT 8
/*
 * Determines if external ingress triggers (ingress_triggers #1-7) should be treated as pulse or
 * level
 * 1'b1 - Pulse
 * 1'b0 - Sevel
 * Reset: 0x0         Access: RW
 */
#define EC_PTH_EXT_UPDATE_CTRL_PULSE_LEVEL_N_MASK 0x007F0000
#define EC_PTH_EXT_UPDATE_CTRL_PULSE_LEVEL_N_SHIFT 16
/*
 * bit-field configurations of external ingress trigger polarity (ingress triggers #1-7).  LSB
 * corresponds to ingress_trigger #1.
 * 1'b0 - Regular polarity ( i.e.  __________|`````|_____ )
 * 1'b1 - Inverse polarity (i.e. `````````````````|___|``````````)
 * Reset: 0x0         Access: RW
 */
#define EC_PTH_EXT_UPDATE_CTRL_POLARITY_MASK 0x7F000000
#define EC_PTH_EXT_UPDATE_CTRL_POLARITY_SHIFT 24

/**** ext_update_subseconds_lsb register ****/
/* Reset: 0x0         Access: RW */
#define EC_PTH_EXT_UPDATE_SUBSECONDS_LSB_RESERVED_13_0_MASK 0x00003FFF
#define EC_PTH_EXT_UPDATE_SUBSECONDS_LSB_RESERVED_13_0_SHIFT 0
/* Reset: 0x0         Access: RW */
#define EC_PTH_EXT_UPDATE_SUBSECONDS_LSB_VAL_MASK 0xFFFFC000
#define EC_PTH_EXT_UPDATE_SUBSECONDS_LSB_VAL_SHIFT 14

/**** read_compensation_subseconds_lsb register ****/
/* Reset: 0x0         Access: RW */
#define EC_PTH_READ_COMPENSATION_SUBSECONDS_LSB_VAL_MASK 0xFFFFC000
#define EC_PTH_READ_COMPENSATION_SUBSECONDS_LSB_VAL_SHIFT 14

/**** int_write_compensation_subseconds_lsb register ****/
/* Reset: 0x0         Access: RW */
#define EC_PTH_INT_WRITE_COMPENSATION_SUBSECONDS_LSB_VAL_MASK 0xFFFFC000
#define EC_PTH_INT_WRITE_COMPENSATION_SUBSECONDS_LSB_VAL_SHIFT 14

/**** ext_write_compensation_subseconds_lsb register ****/
/* Reset: 0x0         Access: RW */
#define EC_PTH_EXT_WRITE_COMPENSATION_SUBSECONDS_LSB_VAL_MASK 0xFFFFC000
#define EC_PTH_EXT_WRITE_COMPENSATION_SUBSECONDS_LSB_VAL_SHIFT 14

/**** sync_compensation_subseconds_lsb register ****/
/* Reset: 0x0         Access: RW */
#define EC_PTH_SYNC_COMPENSATION_SUBSECONDS_LSB_VAL_MASK 0xFFFFC000
#define EC_PTH_SYNC_COMPENSATION_SUBSECONDS_LSB_VAL_SHIFT 14

/**** nanosec_align register ****/
/*
 * align PTH timestamp to nanosec (drop 2 lsbs) before sending them to MAC
 * Reset: 0x0         Access: RW
 */
#define EC_PTH_NANOSEC_ALIGN_TO_MAC      (1 << 0)

/**** trigger_ctrl register ****/
/*
 * Enabling / disabling the egress trigger
 * 1'b1 - Enabled
 * 1'b0 - Disabled
 * Reset: 0x0         Access: RW
 */
#define EC_PTH_EGRESS_TRIGGER_CTRL_EN    (1 << 0)
/*
 * Configuration that determines if the egress trigger is a periodic trigger, or a single event.
 * 1'b0 - Single event
 * 1'b1 - Periodic
 * Reset: 0x0         Access: RW
 */
#define EC_PTH_EGRESS_TRIGGER_CTRL_PERIODIC (1 << 1)
/*
 * Configuration of egress trigger polarity.
 * 1'b0 - Regular polarity ( i.e.  __________|`````|_____ )
 * 1'b1 - Inverse polarity (i.e. `````````````````|___|``````````)
 * Reset: 0x0         Access: RW
 */
#define EC_PTH_EGRESS_TRIGGER_CTRL_POLARITY (1 << 2)
/*
 * If the pulse is marked as periodic (see periodic field), this field holds the requested period
 * (in microseconds)
 * Reset: 0x0         Access: RW
 */
#define EC_PTH_EGRESS_TRIGGER_CTRL_PERIOD_SUBSEC_MASK 0x00FFFFF0
#define EC_PTH_EGRESS_TRIGGER_CTRL_PERIOD_SUBSEC_SHIFT 4
/*
 * If the pulse is marked as periodic (see periodic field), this field holds the requested period
 * (in seconds)
 * Reset: 0x0         Access: RW
 */
#define EC_PTH_EGRESS_TRIGGER_CTRL_PERIOD_SEC_MASK 0xFF000000
#define EC_PTH_EGRESS_TRIGGER_CTRL_PERIOD_SEC_SHIFT 24

/**** trigger_subseconds_lsb register ****/
/* Reset: 0x0         Access: RW */
#define EC_PTH_EGRESS_TRIGGER_SUBSECONDS_LSB_RESERVED_13_0_MASK 0x00003FFF
#define EC_PTH_EGRESS_TRIGGER_SUBSECONDS_LSB_RESERVED_13_0_SHIFT 0
/* Reset: 0x0         Access: RW */
#define EC_PTH_EGRESS_TRIGGER_SUBSECONDS_LSB_VAL_MASK 0xFFFFC000
#define EC_PTH_EGRESS_TRIGGER_SUBSECONDS_LSB_VAL_SHIFT 14

/**** pulse_width_subseconds_lsb register ****/
/* Reset: 0x0         Access: RW */
#define EC_PTH_EGRESS_PULSE_WIDTH_SUBSECONDS_LSB_RESERVED_13_0_MASK 0x00003FFF
#define EC_PTH_EGRESS_PULSE_WIDTH_SUBSECONDS_LSB_RESERVED_13_0_SHIFT 0
/* Reset: 0x0         Access: RW */
#define EC_PTH_EGRESS_PULSE_WIDTH_SUBSECONDS_LSB_VAL_MASK 0xFFFFC000
#define EC_PTH_EGRESS_PULSE_WIDTH_SUBSECONDS_LSB_VAL_SHIFT 14

/**** qual register ****/
/* Reset: 0x0         Access: RW */
#define EC_PTH_DB_QUAL_TS_VALID          (1 << 0)
/* Reset: 0x0         Access: RW */
#define EC_PTH_DB_QUAL_RESERVED_31_1_MASK 0xFFFFFFFE
#define EC_PTH_DB_QUAL_RESERVED_31_1_SHIFT 1

/**** bypass register ****/
/*
 * Bypass outstanding module
 * Reset: 0x1         Access: RW
 */
#define EC_GEN_V3_BYPASS_OUTSTANDING_CTRL (1 << 0)
/*
 * Bypass Tx inline crypto module
 * Reset: 0x1         Access: RW
 */
#define EC_GEN_V3_BYPASS_TX_CRYPTO       (1 << 1)
/*
 * Bypass Rx inline crypto module
 * Reset: 0x1         Access: RW
 */
#define EC_GEN_V3_BYPASS_RX_CRYPTO       (1 << 2)
/*
 * Bypass Tx XTS read
 * Reset: 0x1         Access: RW
 */
#define EC_GEN_V3_BYPASS_TX_XTS_READ     (1 << 3)
/*
 * Bypass rdma
 * Reset: 0x1         Access: RW
 */
#define EC_GEN_V3_BYPASS_RDMA            (1 << 4)

/**** rx_comp_desc register ****/
/*
 * Selection for word0[13]:
 * 0- legacy SR-A0
 * 1- per generic protocol detect mask options
 * Reset: 0x0         Access: RW
 */
#define EC_GEN_V3_RX_COMP_DESC_W0_L3_CKS_RES_SEL (1 << 0)
/*
 * Selection for word0[14]:
 * 0- legacy SR-A0
 * 1- per generic protocol detect mask options
 * Reset: 0x0         Access: RW
 */
#define EC_GEN_V3_RX_COMP_DESC_W0_L4_CKS_RES_SEL (1 << 1)
/*
 * Selection for word3[2:0]:
 * 0- priority (legacy SR-A0)
 * 1- rdma_info result [2:0]
 * Reset: 0x0         Access: RW
 */
#define EC_GEN_V3_RX_COMP_DESC_W3_PRIORITY_RDMA_INFO_2_0_SEL (1 << 2)
/*
 * Selection for word3[10:3]:
 * 0- l4_offset / lro value (legacy SR-A0)
 * 1- switch source port
 * 2- rdma_info result [10:3]
 * 3- reserve
 * Reset: 0x0         Access: RW
 */
#define EC_GEN_V3_RX_COMP_DESC_W3_L4_OFFSET_RDMA_INFO_10_3_SEL_MASK 0x00000018
#define EC_GEN_V3_RX_COMP_DESC_W3_L4_OFFSET_RDMA_INFO_10_3_SEL_SHIFT 3
/*
 * Selection for word3[12:11]:
 * 0-lro_context_result (legacy SR-A0)
 * 1- rdma info result[12:11]
 * Reset: 0x0         Access: RW
 */
#define EC_GEN_V3_RX_COMP_DESC_W3_LRO_RES_RDMA_INFO_12_11_SEL (1 << 5)
/*
 * Selection for word3[15:13]:
 * 0-switch source port (legacy SR-A0)
 * 1- rdma info result[15:13]
 * Reset: 0x0         Access: RW
 */
#define EC_GEN_V3_RX_COMP_DESC_W3_SPORT_RDMA_INFO_15_13_SEL (1 << 6)
/*
 * Selection for word3[28:16]:
 * 0-macseec decryption status[12:0] (legacy SR-A0)
 * 1- rdma info result [28:16]
 * Reset: 0x0         Access: RW
 */
#define EC_GEN_V3_RX_COMP_DESC_W3_DEC_STAT_12_0_RDMA_INFO_28_16_SEL (1 << 7)
/*
 * Selection for word3[29]:
 * 0-macsec decryption status[13] (legacy SR-A0)
 * 1- per generic protocol detect mask options
 * Reset: 0x0         Access: RW
 */
#define EC_GEN_V3_RX_COMP_DESC_W3_DEC_STAT_13_L4_CKS_RES_SEL (1 << 8)
/*
 * Selection for word3[30]:
 * 0-macsec decryption status[14] (legacy SR-A0)
 * 1- per generic protocol detect mask options
 * Reset: 0x0         Access: RW
 */
#define EC_GEN_V3_RX_COMP_DESC_W3_DEC_STAT_14_L3_CKS_RES_SEL (1 << 9)
/*
 * Selection for word3[31]:
 * 0-macsec decryption status[15] (legacy SR-A0)
 * 1- per generic protocol detect mask options
 * Reset: 0x0         Access: RW
 */
#define EC_GEN_V3_RX_COMP_DESC_W3_DEC_STAT_15_CRC_RES_SEL (1 << 10)
/*
 * Selection for words 4-7
 * 0- word 4 time stamp, word 5-7 reserved (legacy SR-A0)
 * 1- alternative processing debug info
 * Reset: 0x0         Access: RW
 */
#define EC_GEN_V3_RX_COMP_DESC_W4_ALT_PROCESSING_SEL (1 << 11)
/*
 * Selection for word 0 [6:5], source VLAN count
 * 0- source vlan count
 * 1- CRC result [15:14]
 * Reset: 0x0         Access: RW
 */
#define EC_GEN_V3_RX_COMP_DESC_W0_SRC_VLAN_CNT (1 << 12)
/*
 * Selection for word 0 [4:0], l3 protocol index
 * 0-  l3 protocol index
 * 1- CRC result [13:9] (v3) / protocol_number[4:0] (v4)
 * Reset: 0x1         Access: RW
 */
#define EC_GEN_V3_RX_COMP_DESC_W0_L3_PROT_INDEX (1 << 13)
/*
 * Selection for word 1 [31:16], lP fragment checksum
 * 0-  IP fragment checksum
 * 1- CRC result [31:16]
 * Reset: 0x0         Access: RW
 */
#define EC_GEN_V3_RX_COMP_DESC_W1_IP_FRAG_CHECKSUM (1 << 14)
/*
 * Selection for word 2 [15:9], L3 offset
 * 0-  LL3 offset
 * 1- CRC result [15:9]
 * Reset: 0x0         Access: RW
 */
#define EC_GEN_V3_RX_COMP_DESC_W2_L3_OFFSET (1 << 15)
/*
 * Selection for word 2 [8:0], tunnel offset
 * 0-  tunnel offset
 * 1- CRC result [8:0]
 * Reset: 0x0         Access: RW
 */
#define EC_GEN_V3_RX_COMP_DESC_W2_TUNNEL_OFFSET (1 << 16)
/*
 * Selection for word 3 [28:0], selecting 3 options for RDMA result (only valid when RDMA result is
 * selected)
 * 00:
 * [28] - RDMA error
 * [27] - RDMA qualified for acceleration
 * [26] - TID valid
 * [25] - reserved
 * [24:20] - protocol number
 * [19:12] - Extracted command
 * [11:0] - selected TID
 * 01:
 * 28] - RDMA error
 * [27] - RDMA qualified for acceleration
 * [26] - TID valid
 * [25] - reserved
 * [24:20] - protocol number
 * [19:12] - Extracted command
 * [11:0] - {5’d0, CRC result [15:9]]}
 * 10:
 * [28] - RDMA error
 * [27] - RDMA qualified for acceleration
 * [26] - TID valid
 * [25] - reserved
 * [24:20] - protocol number
 * [19:12] - - {1’d0, CRC result [15:9]}
 *  [11:0] - selected TID
 * Reset: 0x0         Access: RW
 */
#define EC_GEN_V3_RX_COMP_DESC_W3_RDMA_RESULT_MASK 0x00060000
#define EC_GEN_V3_RX_COMP_DESC_W3_RDMA_RESULT_SHIFT 17
/*
 * Selection for word 4 [31:0]
 * 0-  RDMA debug
 * 1- CRC result [31:0]
 * 2- alternative processing address[31:0]
 * 3- alternative processing address[63:32]
 * Reset: 0x0         Access: RW
 */
#define EC_GEN_V3_RX_COMP_DESC_W4_ALT_PROCESSING_DEBUG_MASK 0x00180000
#define EC_GEN_V3_RX_COMP_DESC_W4_ALT_PROCESSING_DEBUG_SHIFT 19
/*
 * Selection for word 5 [31:0]
 * 0-  RDMA debug
 * 1- CRC result [31:0]
 * 2- alternative processing address[31:0]
 * 3- alternative processing address[63:32]
 * Reset: 0x0         Access: RW
 */
#define EC_GEN_V3_RX_COMP_DESC_W5_ALT_PROCESSING_DEBUG_MASK 0x00600000
#define EC_GEN_V3_RX_COMP_DESC_W5_ALT_PROCESSING_DEBUG_SHIFT 21
/*
 * Selection for word 6 [31:0]
 * 0-  RDMA debug
 * 1- CRC result [31:0]
 * 2- alternative processing address[31:0]
 * 3- alternative processing address[63:32]
 * Reset: 0x0         Access: RW
 */
#define EC_GEN_V3_RX_COMP_DESC_W6_ALT_PROCESSING_DEBUG_MASK 0x01800000
#define EC_GEN_V3_RX_COMP_DESC_W6_ALT_PROCESSING_DEBUG_SHIFT 23
/*
 * Selection for word 7 [31:0]
 * 0-  RDMA debug
 * 1- CRC result [31:0]
 * 2- alternative processing address[31:0]
 * 3- alternative processing address[63:32]
 * Reset: 0x0         Access: RW
 */
#define EC_GEN_V3_RX_COMP_DESC_W7_ALT_PROCESSING_DEBUG_MASK 0x06000000
#define EC_GEN_V3_RX_COMP_DESC_W7_ALT_PROCESSING_DEBUG_SHIFT 25
/*
 * Selection for word 0 [6]
 * valid when w0_src_vlan_cnt = 1
 * 0- source_VLAN_count[0]
 * 1- source_VLAN_count[1]
 * Reset: 0x0         Access: RW
 */
#define EC_GEN_V3_RX_COMP_DESC_W0_SRC_VLAN_CNT_1 (1 << 29)
/*
 * completion descriptor version
 * 0 - v3
 * 1 - v4
 * 2:3 - reserved
 * Reset: 0x0         Access: RW
 */
#define EC_GEN_V3_RX_COMP_DESC_VERSION_MASK 0xC0000000
#define EC_GEN_V3_RX_COMP_DESC_VERSION_SHIFT 30

/**** conf register ****/
/*
 * Valid signal configuration when in loopback mode:
 * 00 - valid from the Ethernet controller
 * 01 - valid is logic AND between Ethernet controller Tx ready and MAC Rx valid (for loopback)
 * 10 - valid is always '0'
 * 11 - valid is always '1'
 * Reset: 0x1         Access: RW
 */
#define EC_GEN_V3_CONF_MAC_LB_EC_OUT_S_VALID_CFG_MASK 0x00000003
#define EC_GEN_V3_CONF_MAC_LB_EC_OUT_S_VALID_CFG_SHIFT 0
/*
 * Valid signal configuration when in loopback mode:
 * 00 - valid from the Ethernet controller Rx
 * 01 - valid is logic AND between Ethernet controller Tx ready and MAC Rx valid (for loopback)
 * 10 -  valid is alway '0'
 * 11 - valid is always '1'
 * Reset: 0x1         Access: RW
 */
#define EC_GEN_V3_CONF_MAC_LB_EC_IN_S_VALID_CFG_MASK 0x0000000C
#define EC_GEN_V3_CONF_MAC_LB_EC_IN_S_VALID_CFG_SHIFT 2

/**** tpm register ****/
/*
 * vlan modification enable
 * Reset: 0x0         Access: RW
 */
#define EC_GEN_V3_TPM_VLAN_MOD_EN        (1 << 0)
/*
 * protocol number selection
 * 0 - from protocol detect cam (v3)
 * 1 - from Tx buffer descriptor
 * 2 - protocol number select table
 * 3 - reserved
 * Reset: 0x0         Access: RW
 */
#define EC_GEN_V3_TPM_PROTOCOL_NUM_SEL_MASK 0x00000006
#define EC_GEN_V3_TPM_PROTOCOL_NUM_SEL_SHIFT 1
/*
 * vlan modification cmd selection
 * 0 - from Tx metadata descriptor (v3)
 * 1 - from vlan_mod_table (using protocol number)
 * Reset: 0x0         Access: RW
 */
#define EC_GEN_V3_TPM_VLAN_MOD_CMD_SEL   (1 << 3)
/*
 * vlan modification new selection
 * 0 - from Tx metadata descriptor (v3)
 * 1 - from vlan_mod_table (using protocol number)
 * Reset: 0x0         Access: RW
 */
#define EC_GEN_V3_TPM_VLAN_MOD_NEW_SEL   (1 << 4)
/*
 * 4 chicken bit for fixing eop_info bug
 * Reset: 0x4         Access: RW
 */
#define EC_GEN_V3_TPM_FF_INIT_CHICKEN_MASK 0x00000F00
#define EC_GEN_V3_TPM_FF_INIT_CHICKEN_SHIFT 8

/**** tpm_vlan_mod_table_addr register ****/
/*
 * Vlan modification  table address
 * Reset: 0x0         Access: RW
 */
#define EC_GEN_V3_TPM_VLAN_MOD_TABLE_ADDR_VAL_MASK 0x0000003F
#define EC_GEN_V3_TPM_VLAN_MOD_TABLE_ADDR_VAL_SHIFT 0

/**** tpm_vlan_mod_table_1 register ****/
/*
 * [9:8] - vlan 2 etype sel
 * [7:6] - vlan 2 pbits sel
 * [5:4] - vlan 2 cfi sel
 * [3:2] - vlan 2 vid sel
 * [1:0] - vlan 1 cfi sel
 * Reset: 0x0         Access: RW
 */
#define EC_GEN_V3_TPM_VLAN_MOD_TABLE_1_CMD_MASK 0x000003FF
#define EC_GEN_V3_TPM_VLAN_MOD_TABLE_1_CMD_SHIFT 0

/**** tpm_vlan_mod_table_2 register ****/
/*
 * [15:13] - new pbits
 * [12]  - new cfi
 * [11:0] - new vid
 * Reset: 0x0         Access: RW
 */
#define EC_GEN_V3_TPM_VLAN_MOD_TABLE_2_VLAN_1_NEW_MASK 0x0000FFFF
#define EC_GEN_V3_TPM_VLAN_MOD_TABLE_2_VLAN_1_NEW_SHIFT 0
/*
 * [15:13] - new pbits
 * [12]  - new cfi
 * [11:0] - new vid
 * Reset: 0x0         Access: RW
 */
#define EC_GEN_V3_TPM_VLAN_MOD_TABLE_2_VLAN_2_NEW_MASK 0xFFFF0000
#define EC_GEN_V3_TPM_VLAN_MOD_TABLE_2_VLAN_2_NEW_SHIFT 16

/**** tx_gpd_cam_addr register ****/
/*
 * Cam compare table address
 * Reset: 0x0         Access: RW
 */
#define EC_TFW_V3_TX_GPD_CAM_ADDR_VAL_MASK 0x0000003F
#define EC_TFW_V3_TX_GPD_CAM_ADDR_VAL_SHIFT 0

/**** tx_gpd_cam_ctrl register ****/
/*
 * cam entry is valid
 * Reset: 0x0         Access: RW
 */
#define EC_TFW_V3_TX_GPD_CAM_CTRL_VALID  (1 << 31)

/**** tx_gcp_legacy register ****/
/*
 * 0-choose parameters from table
 * 1- choose legacy crce roce parameters
 * Reset: 0x1         Access: RW
 */
#define EC_TFW_V3_TX_GCP_LEGACY_PARAM_SEL (1 << 0)

/**** tx_gcp_table_addr register ****/
/*
 * parametrs table address
 * Reset: 0x0         Access: RW
 */
#define EC_TFW_V3_TX_GCP_TABLE_ADDR_VAL_MASK 0x0000003F
#define EC_TFW_V3_TX_GCP_TABLE_ADDR_VAL_SHIFT 0

/**** tx_gcp_table_gen register ****/
/*
 * polynomial selcet
 * 0-crc32(0x104C11DB7)
 * 1-crc32c(0x11EDC6F41)
 * Reset: 0x0         Access: RW
 */
#define EC_TFW_V3_TX_GCP_TABLE_GEN_POLY_SEL (1 << 0)
/*
 * Enable bit complement on crc result
 * Reset: 0x0         Access: RW
 */
#define EC_TFW_V3_TX_GCP_TABLE_GEN_CRC32_BIT_COMP (1 << 1)
/*
 * Enable bit swap on crc result
 * Reset: 0x0         Access: RW
 */
#define EC_TFW_V3_TX_GCP_TABLE_GEN_CRC32_BIT_SWAP (1 << 2)
/*
 * Enable byte swap on crc result
 * Reset: 0x0         Access: RW
 */
#define EC_TFW_V3_TX_GCP_TABLE_GEN_CRC32_BYTE_SWAP (1 << 3)
/*
 * Enable bit swap on input data
 * Reset: 0x0         Access: RW
 */
#define EC_TFW_V3_TX_GCP_TABLE_GEN_DATA_BIT_SWAP (1 << 4)
/*
 * Enable byte swap on input data
 * Reset: 0x0         Access: RW
 */
#define EC_TFW_V3_TX_GCP_TABLE_GEN_DATA_BYTE_SWAP (1 << 5)
/*
 * Number of bytes in trailer which are not part of crc calculation
 * Reset: 0x0         Access: RW
 */
#define EC_TFW_V3_TX_GCP_TABLE_GEN_TRAIL_SIZE_MASK 0x00003FC0
#define EC_TFW_V3_TX_GCP_TABLE_GEN_TRAIL_SIZE_SHIFT 6
/*
 * Number of bytes in header which are not part of crc calculation
 * Reset: 0x0         Access: RW
 */
#define EC_TFW_V3_TX_GCP_TABLE_GEN_HEAD_SIZE_MASK 0x00FF0000
#define EC_TFW_V3_TX_GCP_TABLE_GEN_HEAD_SIZE_SHIFT 16
/*
 * corrected offset calculation
 * 0- subtract head_size (roce)
 * 1- add head_size (fcoe)
 * Reset: 0x0         Access: RW
 */
#define EC_TFW_V3_TX_GCP_TABLE_GEN_HEAD_CALC (1 << 24)
/*
 * 0-replace masked bits with 0
 * 1-replace masked bits with 1 (roce)
 * Reset: 0x0         Access: RW
 */
#define EC_TFW_V3_TX_GCP_TABLE_GEN_MASK_POLARITY (1 << 25)

/**** tx_gcp_table_res register ****/
/*
 * Not in use
 * Reset: 0x0         Access: RW
 */
#define EC_TFW_V3_TX_GCP_TABLE_RES_SEL_MASK 0x0000001F
#define EC_TFW_V3_TX_GCP_TABLE_RES_SEL_SHIFT 0
/*
 * Not in use
 * Reset: 0x0         Access: RW
 */
#define EC_TFW_V3_TX_GCP_TABLE_RES_EN    (1 << 5)
/*
 * Not in use
 * Reset: 0x0         Access: RW
 */
#define EC_TFW_V3_TX_GCP_TABLE_RES_DEF   (1 << 6)

/**** tx_gcp_table_alu_opcode register ****/
/*
 * first opcode
 * e.g. (A op1 B) op3 (C op2 D)
 * Reset: 0x0         Access: RW
 */
#define EC_TFW_V3_TX_GCP_TABLE_ALU_OPCODE_OPCODE_1_MASK 0x0000003F
#define EC_TFW_V3_TX_GCP_TABLE_ALU_OPCODE_OPCODE_1_SHIFT 0
/*
 * second opcode
 * e.g. (A op1 B) op3 (C op2 D)
 * Reset: 0x0         Access: RW
 */
#define EC_TFW_V3_TX_GCP_TABLE_ALU_OPCODE_OPCODE_2_MASK 0x00000FC0
#define EC_TFW_V3_TX_GCP_TABLE_ALU_OPCODE_OPCODE_2_SHIFT 6
/*
 * third opcode
 * e.g. (A op1 B) op3 (C op2 D)
 * Reset: 0x0         Access: RW
 */
#define EC_TFW_V3_TX_GCP_TABLE_ALU_OPCODE_OPCODE_3_MASK 0x0003F000
#define EC_TFW_V3_TX_GCP_TABLE_ALU_OPCODE_OPCODE_3_SHIFT 12

/**** tx_gcp_table_alu_opsel register ****/
/*
 * frst opsel, input selection
 * Reset: 0x0         Access: RW
 */
#define EC_TFW_V3_TX_GCP_TABLE_ALU_OPSEL_OPSEL_1_MASK 0x0000000F
#define EC_TFW_V3_TX_GCP_TABLE_ALU_OPSEL_OPSEL_1_SHIFT 0
/*
 * second opsel, input selection
 * Reset: 0x0         Access: RW
 */
#define EC_TFW_V3_TX_GCP_TABLE_ALU_OPSEL_OPSEL_2_MASK 0x000000F0
#define EC_TFW_V3_TX_GCP_TABLE_ALU_OPSEL_OPSEL_2_SHIFT 4
/*
 * third opsel, input selction
 * Reset: 0x0         Access: RW
 */
#define EC_TFW_V3_TX_GCP_TABLE_ALU_OPSEL_OPSEL_3_MASK 0x00000F00
#define EC_TFW_V3_TX_GCP_TABLE_ALU_OPSEL_OPSEL_3_SHIFT 8
/*
 * fourth opsel, input selction
 * Reset: 0x0         Access: RW
 */
#define EC_TFW_V3_TX_GCP_TABLE_ALU_OPSEL_OPSEL_4_MASK 0x0000F000
#define EC_TFW_V3_TX_GCP_TABLE_ALU_OPSEL_OPSEL_4_SHIFT 12

/**** tx_gcp_table_alu_val register ****/
/*
 * value for alu input
 * Reset: 0x0         Access: RW
 */
#define EC_TFW_V3_TX_GCP_TABLE_ALU_VAL_VAL_MASK 0x000001FF
#define EC_TFW_V3_TX_GCP_TABLE_ALU_VAL_VAL_SHIFT 0

/**** crc_csum_replace register ****/
/*
 * 0- use table
 * 1- legacy SR-A0
 * Reset: 0x1         Access: RW
 */
#define EC_TFW_V3_CRC_CSUM_REPLACE_L3_CSUM_LEGACY_SEL (1 << 0)
/*
 * 0- use table
 * 1- legacy SR-A0
 * Reset: 0x1         Access: RW
 */
#define EC_TFW_V3_CRC_CSUM_REPLACE_L4_CSUM_LEGACY_SEL (1 << 1)
/*
 * 0- use table
 * 1- legacy SR-A0
 * 2-use Tx buffer desriptor
 * Reset: 0x1         Access: RW
 */
#define EC_TFW_V3_CRC_CSUM_REPLACE_CRC_LEGACY_SEL_MASK 0x0000000C
#define EC_TFW_V3_CRC_CSUM_REPLACE_CRC_LEGACY_SEL_SHIFT 2

/**** crc_csum_replace_table_addr register ****/
/*
 * parametrs table address
 * Reset: 0x0         Access: RW
 */
#define EC_TFW_V3_CRC_CSUM_REPLACE_TABLE_ADDR_VAL_MASK 0x000000FF
#define EC_TFW_V3_CRC_CSUM_REPLACE_TABLE_ADDR_VAL_SHIFT 0

/**** crc_csum_replace_table register ****/
/*
 * L3 Checksum replace enable
 * Reset: 0x0         Access: RW
 */
#define EC_TFW_V3_CRC_CSUM_REPLACE_TABLE_L3_CSUM_EN (1 << 0)
/*
 * L4 Checksum replace enable
 * Reset: 0x0         Access: RW
 */
#define EC_TFW_V3_CRC_CSUM_REPLACE_TABLE_L4_CSUM_EN (1 << 1)
/*
 * crc replace enable bit , per CRC generic engin (0-3)
 * Reset: 0x0         Access: RW
 */
#define EC_TFW_V3_CRC_CSUM_REPLACE_TABLE_CRC_EN_MASK 0x0000003C
#define EC_TFW_V3_CRC_CSUM_REPLACE_TABLE_CRC_EN_SHIFT 2

/**** rx_gpd_cam_addr register ****/
/*
 * Cam compare table address
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_V3_RX_GPD_CAM_ADDR_VAL_MASK 0x0000003F
#define EC_RFW_V3_RX_GPD_CAM_ADDR_VAL_SHIFT 0

/**** rx_gpd_cam_ctrl register ****/
/*
 * cam entry is valid
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_V3_RX_GPD_CAM_CTRL_VALID  (1 << 31)

/**** gpd_p1 register ****/
/*
 * Location in bytes of the gpd cam data1 in the parser result vector (default outer
 * l3_protocol_index)
 * Reset: 0x6f        Access: RW
 */
#define EC_RFW_V3_GPD_P1_OFFSET_MASK     0x000003FF
#define EC_RFW_V3_GPD_P1_OFFSET_SHIFT    0

/**** gpd_p2 register ****/
/*
 * Location in bytes of the gpd cam data2 in the parser result vector (default outer
 * l4_protocol_index)
 * Reset: 0x74        Access: RW
 */
#define EC_RFW_V3_GPD_P2_OFFSET_MASK     0x000003FF
#define EC_RFW_V3_GPD_P2_OFFSET_SHIFT    0

/**** gpd_p3 register ****/
/*
 * Location in bytes of the gpd cam data3 in the parser result vector  (default inner
 * l3_protocol_index)
 * Reset: 0x5         Access: RW
 */
#define EC_RFW_V3_GPD_P3_OFFSET_MASK     0x000003FF
#define EC_RFW_V3_GPD_P3_OFFSET_SHIFT    0

/**** gpd_p4 register ****/
/*
 * Location in bytes of the gpd cam data4 in the parser result vector  (default inner
 * l4_protocol_index)
 * Reset: 0xa         Access: RW
 */
#define EC_RFW_V3_GPD_P4_OFFSET_MASK     0x000003FF
#define EC_RFW_V3_GPD_P4_OFFSET_SHIFT    0

/**** gpd_p5 register ****/
/*
 * Location in bytes of the gpd cam data5 in the parser result vector  (default outer parse_ctrl)
 * Reset: 0x6e        Access: RW
 */
#define EC_RFW_V3_GPD_P5_OFFSET_MASK     0x000003FF
#define EC_RFW_V3_GPD_P5_OFFSET_SHIFT    0

/**** gpd_p6 register ****/
/*
 * Location in bytes of the gpd cam data6 in the parser result vector  (default inner parse_ctrl)
 * Reset: 0x4         Access: RW
 */
#define EC_RFW_V3_GPD_P6_OFFSET_MASK     0x000003FF
#define EC_RFW_V3_GPD_P6_OFFSET_SHIFT    0

/**** gpd_p7 register ****/
/*
 * Location in bytes of the gpd cam data7 in the parser result vector  (default outer l3_priority)
 * Reset: 0x77        Access: RW
 */
#define EC_RFW_V3_GPD_P7_OFFSET_MASK     0x000003FF
#define EC_RFW_V3_GPD_P7_OFFSET_SHIFT    0

/**** gpd_p8 register ****/
/*
 * Location in bytes of the gpd cam data8 in the parser result vector  (default outer l4_dest_port
 * lsb)
 * Reset: 0xab        Access: RW
 */
#define EC_RFW_V3_GPD_P8_OFFSET_MASK     0x000003FF
#define EC_RFW_V3_GPD_P8_OFFSET_SHIFT    0

/**** rx_gcp_legacy register ****/
/*
 * 0-choose parameters from table
 * 1- choose legacy crce roce parameters
 * Reset: 0x1         Access: RW
 */
#define EC_RFW_V3_RX_GCP_LEGACY_PARAM_SEL (1 << 0)

/**** rx_gcp_table_addr register ****/
/*
 * parametrs table address
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_V3_RX_GCP_TABLE_ADDR_VAL_MASK 0x0000003F
#define EC_RFW_V3_RX_GCP_TABLE_ADDR_VAL_SHIFT 0

/**** rx_gcp_table_gen register ****/
/*
 * polynomial selcet
 * 0-crc32(0x104C11DB7)
 * 1-crc32c(0x11EDC6F41)
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_V3_RX_GCP_TABLE_GEN_POLY_SEL (1 << 0)
/*
 * Enable bit complement on crc result
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_V3_RX_GCP_TABLE_GEN_CRC32_BIT_COMP (1 << 1)
/*
 * Enable bit swap on crc result
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_V3_RX_GCP_TABLE_GEN_CRC32_BIT_SWAP (1 << 2)
/*
 * Enable byte swap on crc result
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_V3_RX_GCP_TABLE_GEN_CRC32_BYTE_SWAP (1 << 3)
/*
 * Enable bit swap on input data
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_V3_RX_GCP_TABLE_GEN_DATA_BIT_SWAP (1 << 4)
/*
 * Enable byte swap on input data
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_V3_RX_GCP_TABLE_GEN_DATA_BYTE_SWAP (1 << 5)
/*
 * Number of bytes in trailer which are not part of crc calculation
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_V3_RX_GCP_TABLE_GEN_TRAIL_SIZE_MASK 0x00003FC0
#define EC_RFW_V3_RX_GCP_TABLE_GEN_TRAIL_SIZE_SHIFT 6
/*
 * Number of bytes in header which are not part of crc calculation
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_V3_RX_GCP_TABLE_GEN_HEAD_SIZE_MASK 0x00FF0000
#define EC_RFW_V3_RX_GCP_TABLE_GEN_HEAD_SIZE_SHIFT 16
/*
 * corrected offset calculation
 * 0- subtract head_size (roce)
 * 1- add head_size (fcoe)
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_V3_RX_GCP_TABLE_GEN_HEAD_CALC (1 << 24)
/*
 * 0-replace masked bits with 0
 * 1-replace masked bits with 1 (roce)
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_V3_RX_GCP_TABLE_GEN_MASK_POLARITY (1 << 25)

/**** rx_gcp_table_res register ****/
/*
 * Bit mask for crc/checksum result options for metadata W0[13]
 * [0] - l3 inner/ no-tunnel checksum result
 * [1] - l4 inner/no-tunnel  checksum result
 * [2] - l3 outer checksum result
 * [3] - l4 outer checksum result
 * [4] - crc result
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_V3_RX_GCP_TABLE_RES_SEL_0_MASK 0x0000001F
#define EC_RFW_V3_RX_GCP_TABLE_RES_SEL_0_SHIFT 0
/*
 * Bit mask for crc/checksum result options for metadata W0[14]
 * [0] - l3 inner/ no-tunnel checksum result
 * [1] - l4 inner/no-tunnel  checksum result
 * [2] - l3 outer checksum result
 * [3] - l4 outer checksum result
 * [4] - crc result
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_V3_RX_GCP_TABLE_RES_SEL_1_MASK 0x000003E0
#define EC_RFW_V3_RX_GCP_TABLE_RES_SEL_1_SHIFT 5
/*
 * Bit mask for crc/checksum result options for metadata W3[29]
 * [0] - l3 inner/ no-tunnel checksum result
 * [1] - l4 inner/no-tunnel  checksum result
 * [2] - l3 outer checksum result
 * [3] - l4 outer checksum result
 * [4] - crc result
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_V3_RX_GCP_TABLE_RES_SEL_2_MASK 0x00007C00
#define EC_RFW_V3_RX_GCP_TABLE_RES_SEL_2_SHIFT 10
/*
 * Bit mask for crc/checksum result options for metadata W3[30]
 * [0] - l3 inner/ no-tunnel checksum result
 * [1] - l4 inner/no-tunnel  checksum result
 * [2] - l3 outer checksum result
 * [3] - l4 outer checksum result
 * [4] - crc result
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_V3_RX_GCP_TABLE_RES_SEL_3_MASK 0x000F8000
#define EC_RFW_V3_RX_GCP_TABLE_RES_SEL_3_SHIFT 15
/*
 * Bit mask for crc/checksum result options for metadata W3[31]
 * [0] - l3 inner/ no-tunnel checksum result
 * [1] - l4 inner/no-tunnel  checksum result
 * [2] - l3 outer checksum result
 * [3] - l4 outer checksum result
 * [4] - crc result
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_V3_RX_GCP_TABLE_RES_SEL_4_MASK 0x01F00000
#define EC_RFW_V3_RX_GCP_TABLE_RES_SEL_4_SHIFT 20
/*
 * enable crc result check
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_V3_RX_GCP_TABLE_RES_EN    (1 << 25)
/*
 * default value for crc check for non-crc protocol
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_V3_RX_GCP_TABLE_RES_DEF   (1 << 26)

/**** rx_gcp_table_alu_opcode register ****/
/*
 * first opcode
 * e.g. (A op1 B) op3 (C op2 D)
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_V3_RX_GCP_TABLE_ALU_OPCODE_OPCODE_1_MASK 0x0000003F
#define EC_RFW_V3_RX_GCP_TABLE_ALU_OPCODE_OPCODE_1_SHIFT 0
/*
 * second opcode
 * e.g. (A op1 B) op3 (C op2 D)
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_V3_RX_GCP_TABLE_ALU_OPCODE_OPCODE_2_MASK 0x00000FC0
#define EC_RFW_V3_RX_GCP_TABLE_ALU_OPCODE_OPCODE_2_SHIFT 6
/*
 * third opcode
 * e.g. (A op1 B) op3 (C op2 D)
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_V3_RX_GCP_TABLE_ALU_OPCODE_OPCODE_3_MASK 0x0003F000
#define EC_RFW_V3_RX_GCP_TABLE_ALU_OPCODE_OPCODE_3_SHIFT 12

/**** rx_gcp_table_alu_opsel register ****/
/*
 * frst opsel, input selection
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_V3_RX_GCP_TABLE_ALU_OPSEL_OPSEL_1_MASK 0x0000000F
#define EC_RFW_V3_RX_GCP_TABLE_ALU_OPSEL_OPSEL_1_SHIFT 0
/*
 * second opsel, input selection
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_V3_RX_GCP_TABLE_ALU_OPSEL_OPSEL_2_MASK 0x000000F0
#define EC_RFW_V3_RX_GCP_TABLE_ALU_OPSEL_OPSEL_2_SHIFT 4
/*
 * third opsel, input selction
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_V3_RX_GCP_TABLE_ALU_OPSEL_OPSEL_3_MASK 0x00000F00
#define EC_RFW_V3_RX_GCP_TABLE_ALU_OPSEL_OPSEL_3_SHIFT 8
/*
 * fourth opsel, input selction
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_V3_RX_GCP_TABLE_ALU_OPSEL_OPSEL_4_MASK 0x0000F000
#define EC_RFW_V3_RX_GCP_TABLE_ALU_OPSEL_OPSEL_4_SHIFT 12

/**** rx_gcp_table_alu_val register ****/
/*
 * value for alu input
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_V3_RX_GCP_TABLE_ALU_VAL_VAL_MASK 0x000001FF
#define EC_RFW_V3_RX_GCP_TABLE_ALU_VAL_VAL_SHIFT 0

/**** rx_gcp_alu_p1 register ****/
/*
 * Location in bytes of field 1 in the parser result vector
 * Reset: 0x4         Access: RW
 */
#define EC_RFW_V3_RX_GCP_ALU_P1_OFFSET_MASK 0x000003FF
#define EC_RFW_V3_RX_GCP_ALU_P1_OFFSET_SHIFT 0
/*
 * Right shift for field 1 in the parser result vector
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_V3_RX_GCP_ALU_P1_SHIFT_MASK 0x000F0000
#define EC_RFW_V3_RX_GCP_ALU_P1_SHIFT_SHIFT 16

/**** rx_gcp_alu_p2 register ****/
/*
 * Location in bytes of field 2 in the parser result vector
 * Reset: 0x46        Access: RW
 */
#define EC_RFW_V3_RX_GCP_ALU_P2_OFFSET_MASK 0x000003FF
#define EC_RFW_V3_RX_GCP_ALU_P2_OFFSET_SHIFT 0
/*
 * Right shift for field 2 in the parser result vector
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_V3_RX_GCP_ALU_P2_SHIFT_MASK 0x000F0000
#define EC_RFW_V3_RX_GCP_ALU_P2_SHIFT_SHIFT 16

/**** hs_ctrl_table_addr register ****/
/*
 * Header split control table address
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_V3_HS_CTRL_TABLE_ADDR_VAL_MASK 0x000001FF
#define EC_RFW_V3_HS_CTRL_TABLE_ADDR_VAL_SHIFT 0

/**** hs_ctrl_table register ****/
/*
 * Header split length select
 * 0 - legacy
 * 1 - rdma
 * 2 - alu
 * 3 - reserve
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_V3_HS_CTRL_TABLE_SEL_MASK 0x00000003
#define EC_RFW_V3_HS_CTRL_TABLE_SEL_SHIFT 0
/*
 * enable header split
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_V3_HS_CTRL_TABLE_ENABLE   (1 << 2)

/**** hs_ctrl_table_alu_opcode register ****/
/*
 * first opcode
 * e.g. (A op1 B) op3 (C op2 D)
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_V3_HS_CTRL_TABLE_ALU_OPCODE_OPCODE_1_MASK 0x0000003F
#define EC_RFW_V3_HS_CTRL_TABLE_ALU_OPCODE_OPCODE_1_SHIFT 0
/*
 * second opcode
 * e.g. (A op1 B) op3 (C op2 D)
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_V3_HS_CTRL_TABLE_ALU_OPCODE_OPCODE_2_MASK 0x00000FC0
#define EC_RFW_V3_HS_CTRL_TABLE_ALU_OPCODE_OPCODE_2_SHIFT 6
/*
 * third opcode
 * e.g. (A op1 B) op3 (C op2 D)
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_V3_HS_CTRL_TABLE_ALU_OPCODE_OPCODE_3_MASK 0x0003F000
#define EC_RFW_V3_HS_CTRL_TABLE_ALU_OPCODE_OPCODE_3_SHIFT 12

/**** hs_ctrl_table_alu_opsel register ****/
/*
 * frst opsel, input selection
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_V3_HS_CTRL_TABLE_ALU_OPSEL_OPSEL_1_MASK 0x0000000F
#define EC_RFW_V3_HS_CTRL_TABLE_ALU_OPSEL_OPSEL_1_SHIFT 0
/*
 * second opsel, input selection
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_V3_HS_CTRL_TABLE_ALU_OPSEL_OPSEL_2_MASK 0x000000F0
#define EC_RFW_V3_HS_CTRL_TABLE_ALU_OPSEL_OPSEL_2_SHIFT 4
/*
 * third opsel, input selction
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_V3_HS_CTRL_TABLE_ALU_OPSEL_OPSEL_3_MASK 0x00000F00
#define EC_RFW_V3_HS_CTRL_TABLE_ALU_OPSEL_OPSEL_3_SHIFT 8
/*
 * fourth opsel, input selction
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_V3_HS_CTRL_TABLE_ALU_OPSEL_OPSEL_4_MASK 0x0000F000
#define EC_RFW_V3_HS_CTRL_TABLE_ALU_OPSEL_OPSEL_4_SHIFT 12

/**** hs_ctrl_table_alu_val register ****/
/*
 * value for alu input
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_V3_HS_CTRL_TABLE_ALU_VAL_VAL_MASK 0x0000FFFF
#define EC_RFW_V3_HS_CTRL_TABLE_ALU_VAL_VAL_SHIFT 0

/**** hs_ctrl_cfg register ****/
/*
 * Header split enable static selction
 * 0 - legacy
 * 1 - header split control table
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_V3_HS_CTRL_CFG_ENABLE_SEL (1 << 0)
/*
 * Header split length static selction
 * 0 - legacy
 * 1 - header split control table dynamic selection
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_V3_HS_CTRL_CFG_LENGTH_SEL (1 << 1)

/**** hs_ctrl_alu_p1 register ****/
/*
 * Location in bytes of field 1 in the parser result vector
 * Reset: 0x4         Access: RW
 */
#define EC_RFW_V3_HS_CTRL_ALU_P1_OFFSET_MASK 0x000003FF
#define EC_RFW_V3_HS_CTRL_ALU_P1_OFFSET_SHIFT 0
/*
 * Right shift for field 1 in the parser result vector
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_V3_HS_CTRL_ALU_P1_SHIFT_MASK 0x000F0000
#define EC_RFW_V3_HS_CTRL_ALU_P1_SHIFT_SHIFT 16

/**** hs_ctrl_alu_p2 register ****/
/*
 * Location in bytes of field 2 in the parser result vector
 * Reset: 0x46        Access: RW
 */
#define EC_RFW_V3_HS_CTRL_ALU_P2_OFFSET_MASK 0x000003FF
#define EC_RFW_V3_HS_CTRL_ALU_P2_OFFSET_SHIFT 0
/*
 * Right shift for field 2 in the parser result vector
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_V3_HS_CTRL_ALU_P2_SHIFT_MASK 0x000F0000
#define EC_RFW_V3_HS_CTRL_ALU_P2_SHIFT_SHIFT 16

/**** rfw_gen_cfg register ****/
/*
 * protocol number selection
 * 0 - from ec_rfw protocol detect (v3)
 * 1 - from shared_rfw protocol detect
 * 2 - protocol number select table
 * 3 - reserved
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_V3_RFW_GEN_CFG_PROTOCOL_NUM_SEL_MASK 0x00000003
#define EC_RFW_V3_RFW_GEN_CFG_PROTOCOL_NUM_SEL_SHIFT 0

/**** tx_config register ****/
/*
 * [0] pre increment word swap
 * [1] pre increment byte swap
 * [2] pre increment bit swap
 * [3] post increment word swap
 * [4] post increment byte swap
 * [5] post increment bit swap
 * Reset: 0x10        Access: RW
 */
#define EC_CRYPTO_TX_CONFIG_TWEAK_ENDIANITY_SWAP_MASK 0x0000003F
#define EC_CRYPTO_TX_CONFIG_TWEAK_ENDIANITY_SWAP_SHIFT 0
/*
 * if asserted, treat auth_len field in TID entry as auth_offset_from_sop
 * Reset: 0x0         Access: RW
 */
#define EC_CRYPTO_TX_CONFIG_AUTH_LEN_OFFSET (1 << 6)
/*
 * [0] pre encryption word swap
 * [1] pre encryption byte swap
 * [2] pre encryption bit swap
 * [3] post encryption word swap
 * [4] post encryption byte swap
 * [5] post encryption bit swap
 * Reset: 0x12        Access: RW
 */
#define EC_CRYPTO_TX_CONFIG_DATA_ENDIANITY_SWAP_MASK 0x00003F00
#define EC_CRYPTO_TX_CONFIG_DATA_ENDIANITY_SWAP_SHIFT 8
/*
 * direction flip, used in order to use same TID entry for both TX & RX traffic
 * Reset: 0x0         Access: RW
 */
#define EC_CRYPTO_TX_CONFIG_CRYPTO_DIR_FLIP (1 << 14)
/*
 * enable pipeline optimization
 * Reset: 0x1         Access: RW
 */
#define EC_CRYPTO_TX_CONFIG_PIPE_CALC_EN (1 << 16)
/*
 * enable performance counters
 * Reset: 0x1         Access: RW
 */
#define EC_CRYPTO_TX_CONFIG_PERF_CNT_EN  (1 << 17)
/*
 * 0 - from LBA.  1 - from tweak key
 * Reset: 0x1         Access: RW
 */
#define EC_CRYPTO_TX_CONFIG_GCM_ENC0_SOURCE_MUX_SEL (1 << 18)
/*
 * 0 - from LBA.  1 - from tweak key
 * Reset: 0x1         Access: RW
 */
#define EC_CRYPTO_TX_CONFIG_ENC_IV_SOURCE_MUX_SEL (1 << 19)
/*
 * [0] pre aes word swap
 * [1] pre aes byte swap
 * [2] pre aes bit swap
 * [3] post aes word swap
 * [4] post aes byte swap
 * [5] post aes bit swap
 * Reset: 0x0         Access: RW
 */
#define EC_CRYPTO_TX_CONFIG_AES_ENDIANITY_SWAP_MASK 0x03F00000
#define EC_CRYPTO_TX_CONFIG_AES_ENDIANITY_SWAP_SHIFT 20
/*
 * [0] pre aes key word swap
 * [1] pre aes key byte swap
 * [2] pre aes key bit swap
 * [3] post aes key word swap
 * [4] post aes key byte swap
 * [5] post aes key bit swap
 * Reset: 0x0         Access: RW
 */
#define EC_CRYPTO_TX_CONFIG_AES_KEY_ENDIANITY_SWAP_MASK 0xFC000000
#define EC_CRYPTO_TX_CONFIG_AES_KEY_ENDIANITY_SWAP_SHIFT 26

/**** rx_config register ****/
/*
 * [0] pre increment word swap
 * [1] pre increment byte swap
 * [2] pre increment bit swap
 * [3] post increment word swap
 * [4] post increment byte swap
 * [5] post increment bit swap
 * Reset: 0x10        Access: RW
 */
#define EC_CRYPTO_RX_CONFIG_TWEAK_ENDIANITY_SWAP_MASK 0x0000003F
#define EC_CRYPTO_RX_CONFIG_TWEAK_ENDIANITY_SWAP_SHIFT 0
/*
 * if asserted, treat auth_len field in TID entry as auth_offset_from_sop
 * Reset: 0x0         Access: RW
 */
#define EC_CRYPTO_RX_CONFIG_AUTH_LEN_OFFSET (1 << 6)
/*
 * take XTS LBA from header instead of from TID table
 * Reset: 0x0         Access: RW
 */
#define EC_CRYPTO_RX_CONFIG_XTS_LBA_FROM_HEADER (1 << 7)
/*
 * [0] pre encryption word swap
 * [1] pre encryption byte swap
 * [2] pre encryption bit swap
 * [3] post encryption word swap
 * [4] post encryption byte swap
 * [5] post encryption bit swap
 * Reset: 0x12        Access: RW
 */
#define EC_CRYPTO_RX_CONFIG_DATA_ENDIANITY_SWAP_MASK 0x00003F00
#define EC_CRYPTO_RX_CONFIG_DATA_ENDIANITY_SWAP_SHIFT 8
/*
 * direction flip, used in order to use same TID entry for both TX & RX traffic
 * Reset: 0x0         Access: RW
 */
#define EC_CRYPTO_RX_CONFIG_CRYPTO_DIR_FLIP (1 << 14)
/*
 * enable pipeline optimization
 * Reset: 0x1         Access: RW
 */
#define EC_CRYPTO_RX_CONFIG_PIPE_CALC_EN (1 << 16)
/*
 * enable performance counters
 * Reset: 0x1         Access: RW
 */
#define EC_CRYPTO_RX_CONFIG_PERF_CNT_EN  (1 << 17)
/*
 * 0 - from LBA.  1 - from tweak key
 * Reset: 0x1         Access: RW
 */
#define EC_CRYPTO_RX_CONFIG_GCM_ENC0_SOURCE_MUX_SEL (1 << 18)
/*
 * 0 - from LBA.  1 - from tweak key
 * Reset: 0x1         Access: RW
 */
#define EC_CRYPTO_RX_CONFIG_ENC_IV_SOURCE_MUX_SEL (1 << 19)
/*
 * [0] pre aes word swap
 * [1] pre aes byte swap
 * [2] pre aes bit swap
 * [3] post aes word swap
 * [4] post aes byte swap
 * [5] post aes bit swap
 * Reset: 0x0         Access: RW
 */
#define EC_CRYPTO_RX_CONFIG_AES_ENDIANITY_SWAP_MASK 0x03F00000
#define EC_CRYPTO_RX_CONFIG_AES_ENDIANITY_SWAP_SHIFT 20
/*
 * [0] data aes key word swap
 * [1] data aes key byte swap
 * [2] data aes key bit swap
 * [3] tweak aes key word swap
 * [4] tweak aes key byte swap
 * [5] tweak aes key bit swap
 * Reset: 0x0         Access: RW
 */
#define EC_CRYPTO_RX_CONFIG_AES_KEY_ENDIANITY_SWAP_MASK 0xFC000000
#define EC_CRYPTO_RX_CONFIG_AES_KEY_ENDIANITY_SWAP_SHIFT 26

/**** tx_override register ****/
/*
 * all transactions are encrypted
 * Reset: 0x0         Access: RW
 */
#define EC_CRYPTO_TX_OVERRIDE_ENCRYPT_ONLY (1 << 0)
/*
 * all transactions are decrypted
 * Reset: 0x0         Access: RW
 */
#define EC_CRYPTO_TX_OVERRIDE_DECRYPT_ONLY (1 << 1)
/*
 * all pkts use IV
 * Reset: 0x0         Access: RW
 */
#define EC_CRYPTO_TX_OVERRIDE_ALWAYS_DRIVE_IV (1 << 2)
/*
 * no pkt uses IV
 * Reset: 0x0         Access: RW
 */
#define EC_CRYPTO_TX_OVERRIDE_NEVER_DRIVE_IV (1 << 3)
/*
 * all pkts perform authentication calculation
 * Reset: 0x0         Access: RW
 */
#define EC_CRYPTO_TX_OVERRIDE_ALWAYS_PERFORM_SIGN (1 << 4)
/*
 * no pkt performs authentication calculation
 * Reset: 0x0         Access: RW
 */
#define EC_CRYPTO_TX_OVERRIDE_NEVER_PERFORM_SIGN (1 << 5)
/*
 * all pkts perform encryption calculation
 * Reset: 0x0         Access: RW
 */
#define EC_CRYPTO_TX_OVERRIDE_ALWAYS_PERFORM_ENC (1 << 6)
/*
 * no pkt performs encryption calculation
 * Reset: 0x0         Access: RW
 */
#define EC_CRYPTO_TX_OVERRIDE_NEVER_PERFORM_ENC (1 << 7)
/*
 * Enforce pkt trimming
 * bit[0] relates to metadata_pkt_trim
 * bit[1] relates to trailer_pkt_trime
 * bit[2] relates to sign_trim
 * bit[3] relates to aes_padding_trim
 * Reset: 0xc         Access: RW
 */
#define EC_CRYPTO_TX_OVERRIDE_ALWAYS_BYPASS_PKT_TRIM_MASK 0x00000F00
#define EC_CRYPTO_TX_OVERRIDE_ALWAYS_BYPASS_PKT_TRIM_SHIFT 8
/*
 * Enforce no pkt trimming
 * bit[0] relates to metadata_pkt_trim
 * bit[1] relates to trailer_pkt_trime
 * bit[2] relates to sign_trim
 * bit[3] relates to aes_padding_trim
 * Reset: 0x0         Access: RW
 */
#define EC_CRYPTO_TX_OVERRIDE_NEVER_BYPASS_PKT_TRIM_MASK 0x0000F000
#define EC_CRYPTO_TX_OVERRIDE_NEVER_BYPASS_PKT_TRIM_SHIFT 12
/*
 * chicken bit to disable metadata handling optimization
 * Reset: 0x0         Access: RW
 */
#define EC_CRYPTO_TX_OVERRIDE_EXPLICIT_METADATA_STAGE (1 << 16)

/**** rx_override register ****/
/*
 * all transactions are encrypted
 * Reset: 0x0         Access: RW
 */
#define EC_CRYPTO_RX_OVERRIDE_ENCRYPT_ONLY (1 << 0)
/*
 * all transactions are decrypted
 * Reset: 0x0         Access: RW
 */
#define EC_CRYPTO_RX_OVERRIDE_DECRYPT_ONLY (1 << 1)
/*
 * all pkts use IV
 * Reset: 0x0         Access: RW
 */
#define EC_CRYPTO_RX_OVERRIDE_ALWAYS_DRIVE_IV (1 << 2)
/*
 * no pkt uses IV
 * Reset: 0x0         Access: RW
 */
#define EC_CRYPTO_RX_OVERRIDE_NEVER_DRIVE_IV (1 << 3)
/*
 * all pkts perform authentication calculation
 * Reset: 0x0         Access: RW
 */
#define EC_CRYPTO_RX_OVERRIDE_ALWAYS_PERFORM_SIGN (1 << 4)
/*
 * no pkt performs authentication calculation
 * Reset: 0x0         Access: RW
 */
#define EC_CRYPTO_RX_OVERRIDE_NEVER_PERFORM_SIGN (1 << 5)
/*
 * all pkts perform encryption calculation
 * Reset: 0x0         Access: RW
 */
#define EC_CRYPTO_RX_OVERRIDE_ALWAYS_PERFORM_ENC (1 << 6)
/*
 * no pkt performs encryption calculation
 * Reset: 0x0         Access: RW
 */
#define EC_CRYPTO_RX_OVERRIDE_NEVER_PERFORM_ENC (1 << 7)
/*
 * Enforce pkt trimming
 * bit[0] relates to metadata_pkt_trim
 * bit[1] relates to trailer_pkt_trime
 * bit[2] relates to sign_trim
 * bit[3] relates to aes_padding_trim
 * Reset: 0xc         Access: RW
 */
#define EC_CRYPTO_RX_OVERRIDE_ALWAYS_BYPASS_PKT_TRIM_MASK 0x00000F00
#define EC_CRYPTO_RX_OVERRIDE_ALWAYS_BYPASS_PKT_TRIM_SHIFT 8
/*
 * Enforce no pkt trimming
 * bit[0] relates to metadata_pkt_trim
 * bit[1] relates to trailer_pkt_trime
 * bit[2] relates to sign_trim
 * bit[3] relates to aes_padding_trim
 * Reset: 0x0         Access: RW
 */
#define EC_CRYPTO_RX_OVERRIDE_NEVER_BYPASS_PKT_TRIM_MASK 0x0000F000
#define EC_CRYPTO_RX_OVERRIDE_NEVER_BYPASS_PKT_TRIM_SHIFT 12
/*
 * bit enable for writing to rx_cmpl metadata info
 * Reset: 0x7         Access: RW
 */
#define EC_CRYPTO_RX_OVERRIDE_META_DATA_WRITE_EN_MASK 0x00070000
#define EC_CRYPTO_RX_OVERRIDE_META_DATA_WRITE_EN_SHIFT 16
/*
 * chicken bit to disable metadata handling optimization
 * Reset: 0x0         Access: RW
 */
#define EC_CRYPTO_RX_OVERRIDE_EXPLICIT_METADATA_STAGE (1 << 19)
/*
 * crypto metadata offset in the rx cmpl_desc
 * Reset: 0x15        Access: RW
 */
#define EC_CRYPTO_RX_OVERRIDE_META_DATA_BASE_MASK 0x07F00000
#define EC_CRYPTO_RX_OVERRIDE_META_DATA_BASE_SHIFT 20

/**** tx_enc_iv_construction register ****/
/*
 * for each IV byte, select between src1 & src2. Src1 & src2 are determined by map_0 & map_1 fields,
 * respectively
 * Reset: 0x0         Access: RW
 */
#define EC_CRYPTO_TX_ENC_IV_CONSTRUCTION_MUX_SEL_MASK 0x0000FFFF
#define EC_CRYPTO_TX_ENC_IV_CONSTRUCTION_MUX_SEL_SHIFT 0
/*
 * configure meaning of mux_sel=1'b0 (2'b00 - zeros, 2'b01 - IV from header. 2'b10 - IV from crypto
 * table. 2'b11 - IV as XOR between value from header and value from table)
 * Reset: 0x0         Access: RW
 */
#define EC_CRYPTO_TX_ENC_IV_CONSTRUCTION_MAP_0_MASK 0x00030000
#define EC_CRYPTO_TX_ENC_IV_CONSTRUCTION_MAP_0_SHIFT 16
/*
 * configure meaning of mux_sel=1'b1 (2'b00 - zeros, 2'b01 - IV from header. 2'b10 - IV from crypto
 * table. 2'b11 - IV as XOR between value from header and value from table)
 * Reset: 0x0         Access: RW
 */
#define EC_CRYPTO_TX_ENC_IV_CONSTRUCTION_MAP_1_MASK 0x000C0000
#define EC_CRYPTO_TX_ENC_IV_CONSTRUCTION_MAP_1_SHIFT 18
/*
 * Per-byte mux select taken from Crypto table (otherwise from this register, field mux_sel)
 * Reset: 0x1         Access: RW
 */
#define EC_CRYPTO_TX_ENC_IV_CONSTRUCTION_SEL_FROM_TABLE (1 << 20)
/*
 * [0] word swap en
 * [1] byte swap en
 * [2] bit swap en
 * Reset: 0x0         Access: RW
 */
#define EC_CRYPTO_TX_ENC_IV_CONSTRUCTION_ENDIANITY_SWAP_MASK 0x00E00000
#define EC_CRYPTO_TX_ENC_IV_CONSTRUCTION_ENDIANITY_SWAP_SHIFT 21

/**** rx_enc_iv_construction register ****/
/*
 * for each IV byte, select between src1 & src2. Src1 & src2 are determined by map_0 & map_1 fields,
 * respectively
 * Reset: 0xfff0      Access: RW
 */
#define EC_CRYPTO_RX_ENC_IV_CONSTRUCTION_MUX_SEL_MASK 0x0000FFFF
#define EC_CRYPTO_RX_ENC_IV_CONSTRUCTION_MUX_SEL_SHIFT 0
/*
 * configure meaning of mux_sel=1'b0 (2'b00 - zeros, 2'b01 - IV from header. 2'b10 - IV from crypto
 * table. 2'b11 - IV as XOR between value from header and value from table)
 * Reset: 0x0         Access: RW
 */
#define EC_CRYPTO_RX_ENC_IV_CONSTRUCTION_MAP_0_MASK 0x00030000
#define EC_CRYPTO_RX_ENC_IV_CONSTRUCTION_MAP_0_SHIFT 16
/*
 * configure meaning of mux_sel=1'b1 (2'b00 - zeros, 2'b01 - IV from header. 2'b10 - IV from crypto
 * table. 2'b11 - IV as XOR between value from header and value from table)
 * Reset: 0x3         Access: RW
 */
#define EC_CRYPTO_RX_ENC_IV_CONSTRUCTION_MAP_1_MASK 0x000C0000
#define EC_CRYPTO_RX_ENC_IV_CONSTRUCTION_MAP_1_SHIFT 18
/*
 * Per-byte mux select taken from Crypto table (otherwise from this register, field mux_sel)
 * Reset: 0x1         Access: RW
 */
#define EC_CRYPTO_RX_ENC_IV_CONSTRUCTION_SEL_FROM_TABLE (1 << 20)
/*
 * [0] word swap en
 * [1] byte swap en
 * [2] bit swap en
 * Reset: 0x0         Access: RW
 */
#define EC_CRYPTO_RX_ENC_IV_CONSTRUCTION_ENDIANITY_SWAP_MASK 0x00E00000
#define EC_CRYPTO_RX_ENC_IV_CONSTRUCTION_ENDIANITY_SWAP_SHIFT 21

/**** rx_enc_iv_map register ****/
/*
 * [0] word swap en
 * [1] byte swap en
 * [2] bit swap en
 * Reset: 0x0         Access: RW
 */
#define EC_CRYPTO_RX_ENC_IV_MAP_FIELD_EXTRACT_0_OFFSET_MASK 0x0000001F
#define EC_CRYPTO_RX_ENC_IV_MAP_FIELD_EXTRACT_0_OFFSET_SHIFT 0
/*
 * number of valid bytes in word, as generated by field extract (legal values are 1-4)
 * Reset: 0x3         Access: RW
 */
#define EC_CRYPTO_RX_ENC_IV_MAP_FIELD_EXTRACT_0_LENGTH_MASK 0x000000E0
#define EC_CRYPTO_RX_ENC_IV_MAP_FIELD_EXTRACT_0_LENGTH_SHIFT 5
/*
 * [0] word swap en
 * [1] byte swap en
 * [2] bit swap en
 * Reset: 0x3         Access: RW
 */
#define EC_CRYPTO_RX_ENC_IV_MAP_FIELD_EXTRACT_1_OFFSET_MASK 0x00001F00
#define EC_CRYPTO_RX_ENC_IV_MAP_FIELD_EXTRACT_1_OFFSET_SHIFT 8
/*
 * number of valid bytes in word, as generated by field extract (legal values are 1-4)
 * Reset: 0x3         Access: RW
 */
#define EC_CRYPTO_RX_ENC_IV_MAP_FIELD_EXTRACT_1_LENGTH_MASK 0x0000E000
#define EC_CRYPTO_RX_ENC_IV_MAP_FIELD_EXTRACT_1_LENGTH_SHIFT 13
/*
 * [0] word swap en
 * [1] byte swap en
 * [2] bit swap en
 * Reset: 0x6         Access: RW
 */
#define EC_CRYPTO_RX_ENC_IV_MAP_FIELD_EXTRACT_2_OFFSET_MASK 0x001F0000
#define EC_CRYPTO_RX_ENC_IV_MAP_FIELD_EXTRACT_2_OFFSET_SHIFT 16
/*
 * number of valid bytes in word, as generated by field extract (legal values are 1-4)
 * Reset: 0x3         Access: RW
 */
#define EC_CRYPTO_RX_ENC_IV_MAP_FIELD_EXTRACT_2_LENGTH_MASK 0x00E00000
#define EC_CRYPTO_RX_ENC_IV_MAP_FIELD_EXTRACT_2_LENGTH_SHIFT 21
/*
 * [0] word swap en
 * [1] byte swap en
 * [2] bit swap en
 * Reset: 0x9         Access: RW
 */
#define EC_CRYPTO_RX_ENC_IV_MAP_FIELD_EXTRACT_3_OFFSET_MASK 0x1F000000
#define EC_CRYPTO_RX_ENC_IV_MAP_FIELD_EXTRACT_3_OFFSET_SHIFT 24
/*
 * number of valid bytes in word, as generated by field extract (legal values are 1-4)
 * Reset: 0x3         Access: RW
 */
#define EC_CRYPTO_RX_ENC_IV_MAP_FIELD_EXTRACT_3_LENGTH_MASK 0xE0000000
#define EC_CRYPTO_RX_ENC_IV_MAP_FIELD_EXTRACT_3_LENGTH_SHIFT 29

/**** tx_pkt_trim_len register ****/
/*
 * metadata shift-reg length
 * Reset: 0x1         Access: RW
 */
#define EC_CRYPTO_TX_PKT_TRIM_LEN_META_MASK 0x00000007
#define EC_CRYPTO_TX_PKT_TRIM_LEN_META_SHIFT 0
/*
 * pkt trailer shift-reg length
 * Reset: 0x0         Access: RW
 */
#define EC_CRYPTO_TX_PKT_TRIM_LEN_TRAIL_MASK 0x000000F0
#define EC_CRYPTO_TX_PKT_TRIM_LEN_TRAIL_SHIFT 4
/*
 * sign shift-reg length
 * Reset: 0x0         Access: RW
 */
#define EC_CRYPTO_TX_PKT_TRIM_LEN_SIGN_MASK 0x00000300
#define EC_CRYPTO_TX_PKT_TRIM_LEN_SIGN_SHIFT 8
/*
 * crypto padding shift-reg length
 * Reset: 0x1         Access: RW
 */
#define EC_CRYPTO_TX_PKT_TRIM_LEN_CRYPTO_PADDING_MASK 0x00003000
#define EC_CRYPTO_TX_PKT_TRIM_LEN_CRYPTO_PADDING_SHIFT 12
/*
 * hardware chooses shift-registers configurations automatically - no need for sw configuration
 * Reset: 0x1         Access: RW
 */
#define EC_CRYPTO_TX_PKT_TRIM_LEN_AUTO_MODE (1 << 16)

/**** rx_pkt_trim_len register ****/
/*
 * metadata shift-reg length
 * Reset: 0x1         Access: RW
 */
#define EC_CRYPTO_RX_PKT_TRIM_LEN_META_MASK 0x00000007
#define EC_CRYPTO_RX_PKT_TRIM_LEN_META_SHIFT 0
/*
 * pkt trailer shift-reg length
 * Reset: 0x0         Access: RW
 */
#define EC_CRYPTO_RX_PKT_TRIM_LEN_TRAIL_MASK 0x000000F0
#define EC_CRYPTO_RX_PKT_TRIM_LEN_TRAIL_SHIFT 4
/*
 * sign shift-reg length
 * Reset: 0x0         Access: RW
 */
#define EC_CRYPTO_RX_PKT_TRIM_LEN_SIGN_MASK 0x00000300
#define EC_CRYPTO_RX_PKT_TRIM_LEN_SIGN_SHIFT 8
/*
 * crypto padding shift-reg length
 * Reset: 0x1         Access: RW
 */
#define EC_CRYPTO_RX_PKT_TRIM_LEN_CRYPTO_PADDING_MASK 0x00003000
#define EC_CRYPTO_RX_PKT_TRIM_LEN_CRYPTO_PADDING_SHIFT 12
/*
 * hardware chooses shift-registers configurations automatically - no need for sw configuration
 * Reset: 0x1         Access: RW
 */
#define EC_CRYPTO_RX_PKT_TRIM_LEN_AUTO_MODE (1 << 16)

/**** total_tx_secured_pkts_cipher_mode_cmpr register ****/
/* Reset: 0x9         Access: RW */
#define EC_CRYPTO_PERF_CNTR_TOTAL_TX_SECURED_PKTS_CIPHER_MODE_CMPR_MODE_MASK 0x0000000F
#define EC_CRYPTO_PERF_CNTR_TOTAL_TX_SECURED_PKTS_CIPHER_MODE_CMPR_MODE_SHIFT 0

/**** total_rx_secured_pkts_cipher_mode_cmpr register ****/
/* Reset: 0x9         Access: RW */
#define EC_CRYPTO_PERF_CNTR_TOTAL_RX_SECURED_PKTS_CIPHER_MODE_CMPR_MODE_MASK 0x0000000F
#define EC_CRYPTO_PERF_CNTR_TOTAL_RX_SECURED_PKTS_CIPHER_MODE_CMPR_MODE_SHIFT 0

/**** table_addr register ****/
/* Reset: 0x0         Access: RW */
#define EC_PN_REMAP_TABLE_ADDR_VAL_MASK  0x0000003F
#define EC_PN_REMAP_TABLE_ADDR_VAL_SHIFT 0

/**** table_data register ****/
/* Reset: 0x0         Access: RW */
#define EC_PN_REMAP_TABLE_DATA_VAL_MASK  0x00000003
#define EC_PN_REMAP_TABLE_DATA_VAL_SHIFT 0

/**** addr register ****/
/* Reset: 0x0         Access: RW */
#define EC_TMI_FWD_TABLE_ADDR_VAL_MASK   0x0000007F
#define EC_TMI_FWD_TABLE_ADDR_VAL_SHIFT  0

/**** fields register ****/
/*
 * FWD decision - FWD packet to TX MAC
 * Reset: 0x0         Access: RW
 */
#define EC_TMI_FWD_TABLE_FIELDS_FWD_TO_MAC (1 << 0)
/*
 * FWD decision - FWD packet to RX (loopback)
 * Reset: 0x0         Access: RW
 */
#define EC_TMI_FWD_TABLE_FIELDS_FWD_TO_RX (1 << 1)
/*
 * Packet generates MAC error
 * Reset: 0x0         Access: RW
 */
#define EC_TMI_FWD_TABLE_FIELDS_ERROR_ON_MAC (1 << 2)
/*
 * Packet generates completion stream error
 * Reset: 0x0         Access: RW
 */
#define EC_TMI_FWD_TABLE_FIELDS_CMPL_STREAM_ERROR (1 << 3)
/*
 * Indication in Cmpl metadata, offset is cmpl_metadata_fields.offset0
 * Reset: 0x0         Access: RW
 */
#define EC_TMI_FWD_TABLE_FIELDS_CMPL_METADATA0 (1 << 4)
/*
 * Indication in Cmpl metadata, offset is cmpl_metadata_fields.offset1
 * Reset: 0x0         Access: RW
 */
#define EC_TMI_FWD_TABLE_FIELDS_CMPL_METADATA1 (1 << 5)
/*
 * Ignore table decision
 * Reset: 0x0         Access: RW
 */
#define EC_TMI_FWD_TABLE_FIELDS_IGNORE_TABLE (1 << 6)

/**** fields_ignore register ****/
/*
 * FWD decision - FWD packet to TX MAC
 * Reset: 0x0         Access: RW
 */
#define EC_TMI_FWD_TABLE_FIELDS_IGNORE_FWD_TO_MAC (1 << 0)
/*
 * FWD decision - FWD packet to RX (loopback)
 * Reset: 0x0         Access: RW
 */
#define EC_TMI_FWD_TABLE_FIELDS_IGNORE_FWD_TO_RX (1 << 1)
/*
 * Packet generates MAC error
 * Reset: 0x0         Access: RW
 */
#define EC_TMI_FWD_TABLE_FIELDS_IGNORE_ERROR_ON_MAC (1 << 2)
/*
 * Packet generates completion stream error
 * Reset: 0x0         Access: RW
 */
#define EC_TMI_FWD_TABLE_FIELDS_IGNORE_CMPL_STREAM_ERROR (1 << 3)
/*
 * Indication in Cmpl metadata, offset is cmpl_metadata_fields.offset0
 * Reset: 0x0         Access: RW
 */
#define EC_TMI_FWD_TABLE_FIELDS_IGNORE_CMPL_METADATA0 (1 << 4)
/*
 * Indication in Cmpl metadata, offset is cmpl_metadata_fields.offset1
 * Reset: 0x0         Access: RW
 */
#define EC_TMI_FWD_TABLE_FIELDS_IGNORE_CMPL_METADATA1 (1 << 5)

/**** stream_info_fields register ****/
/* Reset: 0x0         Access: RW */
#define EC_TMI_FWD_TABLE_STREAM_INFO_FIELDS_OFFSET0_MASK 0x000001FF
#define EC_TMI_FWD_TABLE_STREAM_INFO_FIELDS_OFFSET0_SHIFT 0
/* Reset: 0x0         Access: RW */
#define EC_TMI_FWD_TABLE_STREAM_INFO_FIELDS_OFFSET1_MASK 0x01FF0000
#define EC_TMI_FWD_TABLE_STREAM_INFO_FIELDS_OFFSET1_SHIFT 16

/**** cmpl_metadata_fields register ****/
/* Reset: 0x0         Access: RW */
#define EC_TMI_FWD_TABLE_CMPL_METADATA_FIELDS_OFFSET0_MASK 0x0000007F
#define EC_TMI_FWD_TABLE_CMPL_METADATA_FIELDS_OFFSET0_SHIFT 0
/* Reset: 0x0         Access: RW */
#define EC_TMI_FWD_TABLE_CMPL_METADATA_FIELDS_OFFSET1_MASK 0x00007F00
#define EC_TMI_FWD_TABLE_CMPL_METADATA_FIELDS_OFFSET1_SHIFT 8

/**** cfg register ****/
/*
 * Ignore table decision - Global
 * Reset: 0x1         Access: RW
 */
#define EC_TMI_FWD_TABLE_CFG_IGNORE_FWD_TABLE (1 << 0)

/**** udma_select register ****/
/*
 * 0 - port maping disabled
 * 1 - port mapping enabled
 * Reset: 0x1         Access: RW
 */
#define EC_RFW_V4_UDMA_SELECT_PORT_MAP_EN (1 << 0)

/**** data_fifo_depth register ****/
/*
 * fifo depth size
 * Reset: 0x100       Access: RW
 */
#define EC_RFW_V4_DATA_FIFO_DEPTH_LIMIT_VALUE_MASK 0x000003FF
#define EC_RFW_V4_DATA_FIFO_DEPTH_LIMIT_VALUE_SHIFT 0

/**** v4_tx_gcp_table_addr register ****/
/*
 * parametrs table address
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_V4_TX_GCP_TABLE_ADDR_VAL_MASK 0x0000003F
#define EC_CRC_V4_TX_GCP_TABLE_ADDR_VAL_SHIFT 0

/**** v4_tx_gcp_table_gen register ****/
/*
 * polynomial selcet
 * 0-crc32(0x104C11DB7)
 * 1-crc32c(0x11EDC6F41)
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_V4_TX_GCP_TABLE_GEN_POLY_SEL (1 << 0)
/*
 * Enable bit complement on crc result
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_V4_TX_GCP_TABLE_GEN_CRC32_BIT_COMP (1 << 1)
/*
 * Enable bit swap on crc result
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_V4_TX_GCP_TABLE_GEN_CRC32_BIT_SWAP (1 << 2)
/*
 * Enable byte swap on crc result
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_V4_TX_GCP_TABLE_GEN_CRC32_BYTE_SWAP (1 << 3)
/*
 * Enable bit swap on input data
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_V4_TX_GCP_TABLE_GEN_DATA_BIT_SWAP (1 << 4)
/*
 * Enable byte swap on input data
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_V4_TX_GCP_TABLE_GEN_DATA_BYTE_SWAP (1 << 5)
/*
 * Number of bytes in trailer which are not part of crc calculation
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_V4_TX_GCP_TABLE_GEN_TRAIL_SIZE_MASK 0x00003FC0
#define EC_CRC_V4_TX_GCP_TABLE_GEN_TRAIL_SIZE_SHIFT 6
/*
 * Number of bytes in header which are not part of crc calculation
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_V4_TX_GCP_TABLE_GEN_HEAD_SIZE_MASK 0x00FF0000
#define EC_CRC_V4_TX_GCP_TABLE_GEN_HEAD_SIZE_SHIFT 16
/*
 * corrected offset calculation
 * 0- subtract head_size (roce)
 * 1- add head_size (fcoe)
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_V4_TX_GCP_TABLE_GEN_HEAD_CALC (1 << 24)
/*
 * 0-replace masked bits with 0
 * 1-replace masked bits with 1 (roce)
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_V4_TX_GCP_TABLE_GEN_MASK_POLARITY (1 << 25)

/**** v4_tx_gcp_table_res register ****/
/*
 * Not in use
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_V4_TX_GCP_TABLE_RES_SEL_MASK 0x0000001F
#define EC_CRC_V4_TX_GCP_TABLE_RES_SEL_SHIFT 0
/*
 * Not in use
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_V4_TX_GCP_TABLE_RES_EN    (1 << 5)
/*
 * Not in use
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_V4_TX_GCP_TABLE_RES_DEF   (1 << 6)

/**** v4_tx_gcp_table_alu_opcode register ****/
/*
 * first opcode
 * e.g. (A op1 B) op3 (C op2 D)
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_V4_TX_GCP_TABLE_ALU_OPCODE_OPCODE_1_MASK 0x0000003F
#define EC_CRC_V4_TX_GCP_TABLE_ALU_OPCODE_OPCODE_1_SHIFT 0
/*
 * second opcode
 * e.g. (A op1 B) op3 (C op2 D)
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_V4_TX_GCP_TABLE_ALU_OPCODE_OPCODE_2_MASK 0x00000FC0
#define EC_CRC_V4_TX_GCP_TABLE_ALU_OPCODE_OPCODE_2_SHIFT 6
/*
 * third opcode
 * e.g. (A op1 B) op3 (C op2 D)
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_V4_TX_GCP_TABLE_ALU_OPCODE_OPCODE_3_MASK 0x0003F000
#define EC_CRC_V4_TX_GCP_TABLE_ALU_OPCODE_OPCODE_3_SHIFT 12

/**** v4_tx_gcp_table_alu_opsel register ****/
/*
 * frst opsel, input selection
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_V4_TX_GCP_TABLE_ALU_OPSEL_OPSEL_1_MASK 0x0000000F
#define EC_CRC_V4_TX_GCP_TABLE_ALU_OPSEL_OPSEL_1_SHIFT 0
/*
 * second opsel, input selection
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_V4_TX_GCP_TABLE_ALU_OPSEL_OPSEL_2_MASK 0x000000F0
#define EC_CRC_V4_TX_GCP_TABLE_ALU_OPSEL_OPSEL_2_SHIFT 4
/*
 * third opsel, input selction
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_V4_TX_GCP_TABLE_ALU_OPSEL_OPSEL_3_MASK 0x00000F00
#define EC_CRC_V4_TX_GCP_TABLE_ALU_OPSEL_OPSEL_3_SHIFT 8
/*
 * fourth opsel, input selction
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_V4_TX_GCP_TABLE_ALU_OPSEL_OPSEL_4_MASK 0x0000F000
#define EC_CRC_V4_TX_GCP_TABLE_ALU_OPSEL_OPSEL_4_SHIFT 12

/**** v4_tx_gcp_table_alu_val register ****/
/*
 * value for alu input
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_V4_TX_GCP_TABLE_ALU_VAL_VAL_MASK 0x000001FF
#define EC_CRC_V4_TX_GCP_TABLE_ALU_VAL_VAL_SHIFT 0

/**** v4_tx_gcp_table_ext_1 register ****/
/*
 * {poly_sel_ext,poly_sel}
 * CRC (crc_cks_sel = 0)
 * 000 - crc32
 * 001 - crc32c
 * 010 - crc8
 * 011 - crc8n
 * 100 - crc16
 * Checksum (crc_cks_sel = 1)
 * 000 - cks8
 * 001 - cks16
 * 010 - cks32
 * 011 - cks32-adler
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_V4_TX_GCP_TABLE_EXT_1_POLY_SEL_EXT_MASK 0x00000003
#define EC_CRC_V4_TX_GCP_TABLE_EXT_1_POLY_SEL_EXT_SHIFT 0
/*
 * 0 - crc
 * 1 - checksum
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_V4_TX_GCP_TABLE_EXT_1_CRC_CKS_SEL (1 << 4)
/*
 * trailer calculation selection
 * 0 - trail_size is offset from eop (packet protection), limited to 31Byte
 * 1 - trail_size is offset from sop, after head_size correction (header protection)
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_V4_TX_GCP_TABLE_EXT_1_TRAIL_CALC (1 << 7)
/*
 * Trail ofsset ALU - frst opsel, input selection
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_V4_TX_GCP_TABLE_EXT_1_TRAIL_ALU_OPSEL_1_MASK 0x00000F00
#define EC_CRC_V4_TX_GCP_TABLE_EXT_1_TRAIL_ALU_OPSEL_1_SHIFT 8
/*
 * Trail ofsset ALU - second opsel, input selection
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_V4_TX_GCP_TABLE_EXT_1_TRAIL_ALU_OPSEL_2_MASK 0x0000F000
#define EC_CRC_V4_TX_GCP_TABLE_EXT_1_TRAIL_ALU_OPSEL_2_SHIFT 12
/*
 * Trail ofsset ALU - third opsel, input selection
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_V4_TX_GCP_TABLE_EXT_1_TRAIL_ALU_OPSEL_3_MASK 0x000F0000
#define EC_CRC_V4_TX_GCP_TABLE_EXT_1_TRAIL_ALU_OPSEL_3_SHIFT 16
/*
 * Trail ofsset ALU - fourth opsel, input selection
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_V4_TX_GCP_TABLE_EXT_1_TRAIL_ALU_OPSEL_4_MASK 0x00F00000
#define EC_CRC_V4_TX_GCP_TABLE_EXT_1_TRAIL_ALU_OPSEL_4_SHIFT 20
/*
 * Number of bytes in header which are not part of crc calculation
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_V4_TX_GCP_TABLE_EXT_1_HEAD_SIZE_EXT_MASK 0xFF000000
#define EC_CRC_V4_TX_GCP_TABLE_EXT_1_HEAD_SIZE_EXT_SHIFT 24

/**** v4_tx_gcp_table_ext_2 register ****/
/*
 * crc/cks field size in bits
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_V4_TX_GCP_TABLE_EXT_2_CRC_FIELD_SIZE_MASK 0x0000003F
#define EC_CRC_V4_TX_GCP_TABLE_EXT_2_CRC_FIELD_SIZE_SHIFT 0
/*
 * crc/cks field offset selection
 * 0 - crc field is after protected data
 * 1 - crc field offset is from start of crc
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_V4_TX_GCP_TABLE_EXT_2_CRC_FIELD_OFFSET_CALC (1 << 8)
/*
 * crc/cks field offset in bytes
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_V4_TX_GCP_TABLE_EXT_2_CRC_FIELD_OFFSET_MASK 0xFFFF0000
#define EC_CRC_V4_TX_GCP_TABLE_EXT_2_CRC_FIELD_OFFSET_SHIFT 16

/**** v4_tx_gcp_table_ext_6 register ****/
/*
 * Trail ofsset ALU - first opcode
 * e.g. (A op1 B) op3 (C op2 D)
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_V4_TX_GCP_TABLE_EXT_6_TRAIL_ALU_OPCODE_1_MASK 0x0000003F
#define EC_CRC_V4_TX_GCP_TABLE_EXT_6_TRAIL_ALU_OPCODE_1_SHIFT 0
/*
 * Trail ofsset ALU - second opcode
 * e.g. (A op1 B) op3 (C op2 D)
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_V4_TX_GCP_TABLE_EXT_6_TRAIL_ALU_OPCODE_2_MASK 0x00000FC0
#define EC_CRC_V4_TX_GCP_TABLE_EXT_6_TRAIL_ALU_OPCODE_2_SHIFT 6
/*
 * Trail ofsset ALU - third opcode
 * e.g. (A op1 B) op3 (C op2 D)
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_V4_TX_GCP_TABLE_EXT_6_TRAIL_ALU_OPCODE_3_MASK 0x0003F000
#define EC_CRC_V4_TX_GCP_TABLE_EXT_6_TRAIL_ALU_OPCODE_3_SHIFT 12
/*
 * crc/cks field replace select (Tx)
 * 0 - normal (calculated value)
 * 1 - if calculated value match check_val replace with replace_val
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_V4_TX_GCP_TABLE_EXT_6_CRC_REPLACE_SEL (1 << 30)
/*
 * crc/cks field detect select (Rx)
 * 0 - normal
 * 1 - if recieved value match detect_val indicate as good (ignore calculation)
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_V4_TX_GCP_TABLE_EXT_6_CRC_DETECT_SEL (1 << 31)

/**** v4_rx_gcp_table_addr register ****/
/*
 * parametrs table address
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_V4_RX_GCP_TABLE_ADDR_VAL_MASK 0x0000003F
#define EC_CRC_V4_RX_GCP_TABLE_ADDR_VAL_SHIFT 0

/**** v4_rx_gcp_table_gen register ****/
/*
 * polynomial selcet
 * 0-crc32(0x104C11DB7)
 * 1-crc32c(0x11EDC6F41)
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_V4_RX_GCP_TABLE_GEN_POLY_SEL (1 << 0)
/*
 * Enable bit complement on crc result
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_V4_RX_GCP_TABLE_GEN_CRC32_BIT_COMP (1 << 1)
/*
 * Enable bit swap on crc result
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_V4_RX_GCP_TABLE_GEN_CRC32_BIT_SWAP (1 << 2)
/*
 * Enable byte swap on crc result
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_V4_RX_GCP_TABLE_GEN_CRC32_BYTE_SWAP (1 << 3)
/*
 * Enable bit swap on input data
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_V4_RX_GCP_TABLE_GEN_DATA_BIT_SWAP (1 << 4)
/*
 * Enable byte swap on input data
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_V4_RX_GCP_TABLE_GEN_DATA_BYTE_SWAP (1 << 5)
/*
 * Number of bytes in trailer which are not part of crc calculation
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_V4_RX_GCP_TABLE_GEN_TRAIL_SIZE_MASK 0x00003FC0
#define EC_CRC_V4_RX_GCP_TABLE_GEN_TRAIL_SIZE_SHIFT 6
/*
 * Number of bytes in header which are not part of crc calculation
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_V4_RX_GCP_TABLE_GEN_HEAD_SIZE_MASK 0x00FF0000
#define EC_CRC_V4_RX_GCP_TABLE_GEN_HEAD_SIZE_SHIFT 16
/*
 * corrected offset calculation
 * 0- subtract head_size (roce)
 * 1- add head_size (fcoe)
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_V4_RX_GCP_TABLE_GEN_HEAD_CALC (1 << 24)
/*
 * 0-replace masked bits with 0
 * 1-replace masked bits with 1 (roce)
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_V4_RX_GCP_TABLE_GEN_MASK_POLARITY (1 << 25)

/**** v4_rx_gcp_table_res register ****/
/*
 * Bit mask for crc/checksum result options for metadata W0[13]
 * [0] - l3 inner/ no-tunnel checksum result
 * [1] - l4 inner/no-tunnel  checksum result
 * [2] - l3 outer checksum result
 * [3] - l4 outer checksum result
 * [4] - crc result
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_V4_RX_GCP_TABLE_RES_SEL_0_MASK 0x0000001F
#define EC_CRC_V4_RX_GCP_TABLE_RES_SEL_0_SHIFT 0
/*
 * Bit mask for crc/checksum result options for metadata W0[14]
 * [0] - l3 inner/ no-tunnel checksum result
 * [1] - l4 inner/no-tunnel  checksum result
 * [2] - l3 outer checksum result
 * [3] - l4 outer checksum result
 * [4] - crc result
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_V4_RX_GCP_TABLE_RES_SEL_1_MASK 0x000003E0
#define EC_CRC_V4_RX_GCP_TABLE_RES_SEL_1_SHIFT 5
/*
 * Bit mask for crc/checksum result options for metadata W3[29]
 * [0] - l3 inner/ no-tunnel checksum result
 * [1] - l4 inner/no-tunnel  checksum result
 * [2] - l3 outer checksum result
 * [3] - l4 outer checksum result
 * [4] - crc result
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_V4_RX_GCP_TABLE_RES_SEL_2_MASK 0x00007C00
#define EC_CRC_V4_RX_GCP_TABLE_RES_SEL_2_SHIFT 10
/*
 * Bit mask for crc/checksum result options for metadata W3[30]
 * [0] - l3 inner/ no-tunnel checksum result
 * [1] - l4 inner/no-tunnel  checksum result
 * [2] - l3 outer checksum result
 * [3] - l4 outer checksum result
 * [4] - crc result
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_V4_RX_GCP_TABLE_RES_SEL_3_MASK 0x000F8000
#define EC_CRC_V4_RX_GCP_TABLE_RES_SEL_3_SHIFT 15
/*
 * Bit mask for crc/checksum result options for metadata W3[31]
 * [0] - l3 inner/ no-tunnel checksum result
 * [1] - l4 inner/no-tunnel  checksum result
 * [2] - l3 outer checksum result
 * [3] - l4 outer checksum result
 * [4] - crc result
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_V4_RX_GCP_TABLE_RES_SEL_4_MASK 0x01F00000
#define EC_CRC_V4_RX_GCP_TABLE_RES_SEL_4_SHIFT 20
/*
 * enable crc result check
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_V4_RX_GCP_TABLE_RES_EN    (1 << 25)
/*
 * default value for crc check for non-crc protocol
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_V4_RX_GCP_TABLE_RES_DEF   (1 << 26)

/**** v4_rx_gcp_table_alu_opcode register ****/
/*
 * first opcode
 * e.g. (A op1 B) op3 (C op2 D)
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_V4_RX_GCP_TABLE_ALU_OPCODE_OPCODE_1_MASK 0x0000003F
#define EC_CRC_V4_RX_GCP_TABLE_ALU_OPCODE_OPCODE_1_SHIFT 0
/*
 * second opcode
 * e.g. (A op1 B) op3 (C op2 D)
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_V4_RX_GCP_TABLE_ALU_OPCODE_OPCODE_2_MASK 0x00000FC0
#define EC_CRC_V4_RX_GCP_TABLE_ALU_OPCODE_OPCODE_2_SHIFT 6
/*
 * third opcode
 * e.g. (A op1 B) op3 (C op2 D)
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_V4_RX_GCP_TABLE_ALU_OPCODE_OPCODE_3_MASK 0x0003F000
#define EC_CRC_V4_RX_GCP_TABLE_ALU_OPCODE_OPCODE_3_SHIFT 12

/**** v4_rx_gcp_table_alu_opsel register ****/
/*
 * frst opsel, input selection
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_V4_RX_GCP_TABLE_ALU_OPSEL_OPSEL_1_MASK 0x0000000F
#define EC_CRC_V4_RX_GCP_TABLE_ALU_OPSEL_OPSEL_1_SHIFT 0
/*
 * second opsel, input selection
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_V4_RX_GCP_TABLE_ALU_OPSEL_OPSEL_2_MASK 0x000000F0
#define EC_CRC_V4_RX_GCP_TABLE_ALU_OPSEL_OPSEL_2_SHIFT 4
/*
 * third opsel, input selction
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_V4_RX_GCP_TABLE_ALU_OPSEL_OPSEL_3_MASK 0x00000F00
#define EC_CRC_V4_RX_GCP_TABLE_ALU_OPSEL_OPSEL_3_SHIFT 8
/*
 * fourth opsel, input selction
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_V4_RX_GCP_TABLE_ALU_OPSEL_OPSEL_4_MASK 0x0000F000
#define EC_CRC_V4_RX_GCP_TABLE_ALU_OPSEL_OPSEL_4_SHIFT 12

/**** v4_rx_gcp_table_alu_val register ****/
/*
 * value for alu input
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_V4_RX_GCP_TABLE_ALU_VAL_VAL_MASK 0x000001FF
#define EC_CRC_V4_RX_GCP_TABLE_ALU_VAL_VAL_SHIFT 0

/**** v4_rx_gcp_table_ext_1 register ****/
/*
 * {poly_sel_ext,poly_sel}
 * CRC (crc_cks_sel = 0)
 * 000 - crc32
 * 001 - crc32c
 * 010 - crc8
 * 011 - crc8n
 * 100 - crc16
 * Checksum (crc_cks_sel = 1)
 * 000 - cks8
 * 001 - cks16
 * 010 - cks32
 * 011 - cks32-adler
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_V4_RX_GCP_TABLE_EXT_1_POLY_SEL_EXT_MASK 0x00000003
#define EC_CRC_V4_RX_GCP_TABLE_EXT_1_POLY_SEL_EXT_SHIFT 0
/*
 * 0 - crc
 * 1 - checksum
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_V4_RX_GCP_TABLE_EXT_1_CRC_CKS_SEL (1 << 4)
/*
 * trailer calculation selection
 * 0 - trail_size is offset from eop (packet protection), limited to 31Byte
 * 1 - trail_size is offset from sop, after head_size correction (header protection)
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_V4_RX_GCP_TABLE_EXT_1_TRAIL_CALC (1 << 7)
/*
 * Trail ofsset ALU - frst opsel, input selection
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_V4_RX_GCP_TABLE_EXT_1_TRAIL_ALU_OPSEL_1_MASK 0x00000F00
#define EC_CRC_V4_RX_GCP_TABLE_EXT_1_TRAIL_ALU_OPSEL_1_SHIFT 8
/*
 * Trail ofsset ALU - second opsel, input selection
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_V4_RX_GCP_TABLE_EXT_1_TRAIL_ALU_OPSEL_2_MASK 0x0000F000
#define EC_CRC_V4_RX_GCP_TABLE_EXT_1_TRAIL_ALU_OPSEL_2_SHIFT 12
/*
 * Trail ofsset ALU - third opsel, input selection
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_V4_RX_GCP_TABLE_EXT_1_TRAIL_ALU_OPSEL_3_MASK 0x000F0000
#define EC_CRC_V4_RX_GCP_TABLE_EXT_1_TRAIL_ALU_OPSEL_3_SHIFT 16
/*
 * Trail ofsset ALU - fourth opsel, input selection
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_V4_RX_GCP_TABLE_EXT_1_TRAIL_ALU_OPSEL_4_MASK 0x00F00000
#define EC_CRC_V4_RX_GCP_TABLE_EXT_1_TRAIL_ALU_OPSEL_4_SHIFT 20
/*
 * Number of bytes in header which are not part of crc calculation
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_V4_RX_GCP_TABLE_EXT_1_HEAD_SIZE_EXT_MASK 0xFF000000
#define EC_CRC_V4_RX_GCP_TABLE_EXT_1_HEAD_SIZE_EXT_SHIFT 24

/**** v4_rx_gcp_table_ext_2 register ****/
/*
 * crc/cks field size in bits
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_V4_RX_GCP_TABLE_EXT_2_CRC_FIELD_SIZE_MASK 0x0000003F
#define EC_CRC_V4_RX_GCP_TABLE_EXT_2_CRC_FIELD_SIZE_SHIFT 0
/*
 * crc/cks field offset selection
 * 0 - crc field is after protected data
 * 1 - crc field offset is from start of crc
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_V4_RX_GCP_TABLE_EXT_2_CRC_FIELD_OFFSET_CALC (1 << 8)
/*
 * crc/cks field offset in bytes
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_V4_RX_GCP_TABLE_EXT_2_CRC_FIELD_OFFSET_MASK 0xFFFF0000
#define EC_CRC_V4_RX_GCP_TABLE_EXT_2_CRC_FIELD_OFFSET_SHIFT 16

/**** v4_rx_gcp_table_ext_6 register ****/
/*
 * Trail ofsset ALU - first opcode
 * e.g. (A op1 B) op3 (C op2 D)
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_V4_RX_GCP_TABLE_EXT_6_TRAIL_ALU_OPCODE_1_MASK 0x0000003F
#define EC_CRC_V4_RX_GCP_TABLE_EXT_6_TRAIL_ALU_OPCODE_1_SHIFT 0
/*
 * Trail ofsset ALU - second opcode
 * e.g. (A op1 B) op3 (C op2 D)
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_V4_RX_GCP_TABLE_EXT_6_TRAIL_ALU_OPCODE_2_MASK 0x00000FC0
#define EC_CRC_V4_RX_GCP_TABLE_EXT_6_TRAIL_ALU_OPCODE_2_SHIFT 6
/*
 * Trail ofsset ALU - third opcode
 * e.g. (A op1 B) op3 (C op2 D)
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_V4_RX_GCP_TABLE_EXT_6_TRAIL_ALU_OPCODE_3_MASK 0x0003F000
#define EC_CRC_V4_RX_GCP_TABLE_EXT_6_TRAIL_ALU_OPCODE_3_SHIFT 12
/*
 * address for extended mask table
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_V4_RX_GCP_TABLE_EXT_6_EXTENDED_MASK_SEL_MASK 0x001C0000
#define EC_CRC_V4_RX_GCP_TABLE_EXT_6_EXTENDED_MASK_SEL_SHIFT 18
/*
 * 0 - use mask from gcp table (96Byte) - protocol number
 * 1-  use mask from extended mask table (256 Byte) - protocol number mapping
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_V4_RX_GCP_TABLE_EXT_6_EXTENDED_MASK_EN (1 << 21)
/*
 * crc/cks field replace select (Tx)
 * 0 - normal (calculated value)
 * 1 - if calculated value match check_val replace with replace_val
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_V4_RX_GCP_TABLE_EXT_6_CRC_REPLACE_SEL (1 << 30)
/*
 * crc/cks field detect select (Rx)
 * 0 - normal
 * 1 - if recieved value match detect_val indicate as good (ignore calculation)
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_V4_RX_GCP_TABLE_EXT_6_CRC_DETECT_SEL (1 << 31)

/**** v4_tx_gcp_alu_p1 register ****/
/*
 * Location in bytes of field 1 in the descriptor vector
 * Reset: 0x4         Access: RW
 */
#define EC_CRC_V4_TX_GCP_ALU_P1_OFFSET_MASK 0x000003FF
#define EC_CRC_V4_TX_GCP_ALU_P1_OFFSET_SHIFT 0
/*
 * Right shift for field 1 in the descriptor vector
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_V4_TX_GCP_ALU_P1_SHIFT_MASK 0x000F0000
#define EC_CRC_V4_TX_GCP_ALU_P1_SHIFT_SHIFT 16
/*
 * field merge size
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_V4_TX_GCP_ALU_P1_SIZE_MASK 0x00F00000
#define EC_CRC_V4_TX_GCP_ALU_P1_SIZE_SHIFT 20

/**** v4_tx_gcp_alu_p2 register ****/
/*
 * Location in bytes of field 2 in the descriptor vector
 * Reset: 0x46        Access: RW
 */
#define EC_CRC_V4_TX_GCP_ALU_P2_OFFSET_MASK 0x000003FF
#define EC_CRC_V4_TX_GCP_ALU_P2_OFFSET_SHIFT 0
/*
 * Right shift for field 2 in the parser result vector
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_V4_TX_GCP_ALU_P2_SHIFT_MASK 0x000F0000
#define EC_CRC_V4_TX_GCP_ALU_P2_SHIFT_SHIFT 16
/*
 * field merge size
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_V4_TX_GCP_ALU_P2_SIZE_MASK 0x00F00000
#define EC_CRC_V4_TX_GCP_ALU_P2_SIZE_SHIFT 20

/**** v4_tx_gcp_alu_p3 register ****/
/*
 * Location in bytes of field 3 in the descriptor vector
 * Reset: 0x42        Access: RW
 */
#define EC_CRC_V4_TX_GCP_ALU_P3_OFFSET_MASK 0x000003FF
#define EC_CRC_V4_TX_GCP_ALU_P3_OFFSET_SHIFT 0

/**** v4_tx_gcp_alu_p4 register ****/
/*
 * Location in bytes of field 4 in the descriptor vector
 * Reset: 0x88        Access: RW
 */
#define EC_CRC_V4_TX_GCP_ALU_P4_OFFSET_MASK 0x000003FF
#define EC_CRC_V4_TX_GCP_ALU_P4_OFFSET_SHIFT 0

/**** v4_tx_gcp_alu_p5 register ****/
/*
 * Location in bytes of field 5 in the descriptor vector
 * Reset: 0x88        Access: RW
 */
#define EC_CRC_V4_TX_GCP_ALU_P5_OFFSET_MASK 0x000003FF
#define EC_CRC_V4_TX_GCP_ALU_P5_OFFSET_SHIFT 0

/**** v4_tx_gcp_alu_p6 register ****/
/*
 * Location in bytes of field 6 in the descriptor vector
 * Reset: 0x84        Access: RW
 */
#define EC_CRC_V4_TX_GCP_ALU_P6_OFFSET_MASK 0x000003FF
#define EC_CRC_V4_TX_GCP_ALU_P6_OFFSET_SHIFT 0

/**** v4_tx_gcp_alu_const register ****/
/*
 * const value 0
 * Reset: 0x1         Access: RW
 */
#define EC_CRC_V4_TX_GCP_ALU_CONST_VAL_0_MASK 0x000000FF
#define EC_CRC_V4_TX_GCP_ALU_CONST_VAL_0_SHIFT 0
/*
 * reserved
 * Reset: 0x2         Access: RW
 */
#define EC_CRC_V4_TX_GCP_ALU_CONST_VAL_1_MASK 0x0000FF00
#define EC_CRC_V4_TX_GCP_ALU_CONST_VAL_1_SHIFT 8
/*
 * reserved
 * Reset: 0x4         Access: RW
 */
#define EC_CRC_V4_TX_GCP_ALU_CONST_VAL_2_MASK 0x00FF0000
#define EC_CRC_V4_TX_GCP_ALU_CONST_VAL_2_SHIFT 16
/*
 * reserved
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_V4_TX_GCP_ALU_CONST_VAL_3_MASK 0xFF000000
#define EC_CRC_V4_TX_GCP_ALU_CONST_VAL_3_SHIFT 24

/**** v4_tx_gcp_alu_const_table_addr register ****/
/*
 * alu const table address
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_V4_TX_GCP_ALU_CONST_TABLE_ADDR_VAL_MASK 0x0000000F
#define EC_CRC_V4_TX_GCP_ALU_CONST_TABLE_ADDR_VAL_SHIFT 0
/*
 * hardware address select
 * 0 - hw address is from extracted bits from descriptort (per gce)
 * 1 - hw address is from crc extended protocol control table
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_V4_TX_GCP_ALU_CONST_TABLE_ADDR_HW_SEL (1 << 4)

/**** v4_tx_gcp_alu_const_table_1 register ****/
/* Reset: 0x0         Access: RW */
#define EC_CRC_V4_TX_GCP_ALU_CONST_TABLE_1_VAL_MASK 0x000001FF
#define EC_CRC_V4_TX_GCP_ALU_CONST_TABLE_1_VAL_SHIFT 0

/**** v4_tx_gcp_alu_const_table_2 register ****/
/* Reset: 0x0         Access: RW */
#define EC_CRC_V4_TX_GCP_ALU_CONST_TABLE_2_VAL_MASK 0x000001FF
#define EC_CRC_V4_TX_GCP_ALU_CONST_TABLE_2_VAL_SHIFT 0

/**** v4_tx_gcp_alu_const_table_3 register ****/
/* Reset: 0x0         Access: RW */
#define EC_CRC_V4_TX_GCP_ALU_CONST_TABLE_3_VAL_MASK 0x000001FF
#define EC_CRC_V4_TX_GCP_ALU_CONST_TABLE_3_VAL_SHIFT 0

/**** v4_rx_gcp_alu_p1 register ****/
/*
 * Location in bytes of field 1 in the parser result vector
 * Reset: 0x4         Access: RW
 */
#define EC_CRC_V4_RX_GCP_ALU_P1_OFFSET_MASK 0x000003FF
#define EC_CRC_V4_RX_GCP_ALU_P1_OFFSET_SHIFT 0
/*
 * Right shift for field 1 in the parser result vector
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_V4_RX_GCP_ALU_P1_SHIFT_MASK 0x000F0000
#define EC_CRC_V4_RX_GCP_ALU_P1_SHIFT_SHIFT 16
/*
 * field merge size
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_V4_RX_GCP_ALU_P1_SIZE_MASK 0x00F00000
#define EC_CRC_V4_RX_GCP_ALU_P1_SIZE_SHIFT 20

/**** v4_rx_gcp_alu_p2 register ****/
/*
 * Location in bytes of field 2 in the parser result vector
 * Reset: 0x46        Access: RW
 */
#define EC_CRC_V4_RX_GCP_ALU_P2_OFFSET_MASK 0x000003FF
#define EC_CRC_V4_RX_GCP_ALU_P2_OFFSET_SHIFT 0
/*
 * Right shift for field 2 in the parser result vector
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_V4_RX_GCP_ALU_P2_SHIFT_MASK 0x000F0000
#define EC_CRC_V4_RX_GCP_ALU_P2_SHIFT_SHIFT 16
/*
 * field merge size
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_V4_RX_GCP_ALU_P2_SIZE_MASK 0x00F00000
#define EC_CRC_V4_RX_GCP_ALU_P2_SIZE_SHIFT 20

/**** v4_rx_gcp_alu_const register ****/
/*
 * const value 0
 * Reset: 0x1         Access: RW
 */
#define EC_CRC_V4_RX_GCP_ALU_CONST_VAL_0_MASK 0x000000FF
#define EC_CRC_V4_RX_GCP_ALU_CONST_VAL_0_SHIFT 0
/*
 * const value 1
 * Reset: 0x2         Access: RW
 */
#define EC_CRC_V4_RX_GCP_ALU_CONST_VAL_1_MASK 0x0000FF00
#define EC_CRC_V4_RX_GCP_ALU_CONST_VAL_1_SHIFT 8
/*
 * const value 2
 * Reset: 0x4         Access: RW
 */
#define EC_CRC_V4_RX_GCP_ALU_CONST_VAL_2_MASK 0x00FF0000
#define EC_CRC_V4_RX_GCP_ALU_CONST_VAL_2_SHIFT 16
/*
 * reserved
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_V4_RX_GCP_ALU_CONST_VAL_3_MASK 0xFF000000
#define EC_CRC_V4_RX_GCP_ALU_CONST_VAL_3_SHIFT 24

/**** v4_rx_gcp_alu_p3 register ****/
/*
 * Location in bits of field 3 in the parser result vector
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_V4_RX_GCP_ALU_P3_OFFSET_MASK 0x00000FFF
#define EC_CRC_V4_RX_GCP_ALU_P3_OFFSET_SHIFT 0

/**** v4_rx_gcp_alu_p4 register ****/
/*
 * Location in bits of field 4 in the parser result vector
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_V4_RX_GCP_ALU_P4_OFFSET_MASK 0x00000FFF
#define EC_CRC_V4_RX_GCP_ALU_P4_OFFSET_SHIFT 0

/**** v4_rx_gcp_alu_p5 register ****/
/*
 * Location in bits of field 3 in the parser result vector
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_V4_RX_GCP_ALU_P5_OFFSET_MASK 0x00000FFF
#define EC_CRC_V4_RX_GCP_ALU_P5_OFFSET_SHIFT 0

/**** v4_rx_gcp_alu_p6 register ****/
/*
 * Location in bits of field 4 in the parser result vector
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_V4_RX_GCP_ALU_P6_OFFSET_MASK 0x00000FFF
#define EC_CRC_V4_RX_GCP_ALU_P6_OFFSET_SHIFT 0

/**** v4_rx_gcp_alu_const_table_addr register ****/
/*
 * alu const table address (software access)
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_V4_RX_GCP_ALU_CONST_TABLE_ADDR_VAL_MASK 0x0000000F
#define EC_CRC_V4_RX_GCP_ALU_CONST_TABLE_ADDR_VAL_SHIFT 0
/*
 * hardware address select
 * 0 - hw address is from extracted bits from parser result (per gce)
 * 1 - hw address is from crc extended protocol control table
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_V4_RX_GCP_ALU_CONST_TABLE_ADDR_HW_SEL (1 << 4)

/**** v4_rx_gcp_alu_const_table_1 register ****/
/* Reset: 0x0         Access: RW */
#define EC_CRC_V4_RX_GCP_ALU_CONST_TABLE_1_VAL_MASK 0x000001FF
#define EC_CRC_V4_RX_GCP_ALU_CONST_TABLE_1_VAL_SHIFT 0

/**** v4_rx_gcp_alu_const_table_2 register ****/
/* Reset: 0x0         Access: RW */
#define EC_CRC_V4_RX_GCP_ALU_CONST_TABLE_2_VAL_MASK 0x000001FF
#define EC_CRC_V4_RX_GCP_ALU_CONST_TABLE_2_VAL_SHIFT 0

/**** mask_table_addr register ****/
/*
 * crc extended mask table address (software access)
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_EXTENDED_MASK_TABLE_ADDR_VAL_MASK 0x00000007
#define EC_CRC_EXTENDED_MASK_TABLE_ADDR_VAL_SHIFT 0
/*
 * hardware address select
 * 0 - hw address is from gcp
 * 1 - hw address is from crc extended protocol control table
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_EXTENDED_MASK_TABLE_ADDR_HW_SEL (1 << 3)

/**** rx_protocol_control_table_addr register ****/
/*
 * Rx crc protocol control table address (4x1bit FE, protocol_number[5:0]}
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_EXTENDED_RX_PROTOCOL_CONTROL_TABLE_ADDR_VAL_MASK 0x000003FF
#define EC_CRC_EXTENDED_RX_PROTOCOL_CONTROL_TABLE_ADDR_VAL_SHIFT 0

/**** rx_protocol_control_table_1 register ****/
/*
 * alu input value table address
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_EXTENDED_RX_PROTOCOL_CONTROL_TABLE_1_ALU_INPUT_SEL_MASK 0x0000000F
#define EC_CRC_EXTENDED_RX_PROTOCOL_CONTROL_TABLE_1_ALU_INPUT_SEL_SHIFT 0
/*
 * address for extended mask table
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_EXTENDED_RX_PROTOCOL_CONTROL_TABLE_1_EXTENDED_MASK_SEL_MASK 0x00000070
#define EC_CRC_EXTENDED_RX_PROTOCOL_CONTROL_TABLE_1_EXTENDED_MASK_SEL_SHIFT 4
/*
 * spare bits in memory
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_EXTENDED_RX_PROTOCOL_CONTROL_TABLE_1_RESERVED_7 (1 << 7)
/*
 * Per Rx Generic CRC Engine
 * 0 - use mask from gcp table (96Byte) - protocol number
 * 1-  use mask from extended mask table (256 Byte) - protocol number mapping
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_EXTENDED_RX_PROTOCOL_CONTROL_TABLE_1_EXTENDED_MASK_EN_MASK 0x00000F00
#define EC_CRC_EXTENDED_RX_PROTOCOL_CONTROL_TABLE_1_EXTENDED_MASK_EN_SHIFT 8
/*
 * ec_gce 0
 * [0] - 0: use gce result,  1: use force bit
 * [1] - force bit value
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_EXTENDED_RX_PROTOCOL_CONTROL_TABLE_1_CRC_FORCE_GCE_0_MASK 0x00003000
#define EC_CRC_EXTENDED_RX_PROTOCOL_CONTROL_TABLE_1_CRC_FORCE_GCE_0_SHIFT 12
/*
 * ec_gce 1
 * [0] - 0: use gce result,  1: use force bit
 * [1] - force bit value
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_EXTENDED_RX_PROTOCOL_CONTROL_TABLE_1_CRC_FORCE_GCE_1_MASK 0x0000C000
#define EC_CRC_EXTENDED_RX_PROTOCOL_CONTROL_TABLE_1_CRC_FORCE_GCE_1_SHIFT 14
/*
 * ec_gce 2
 * [0] - 0: use gce result,  1: use force bit
 * [1] - force bit value
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_EXTENDED_RX_PROTOCOL_CONTROL_TABLE_1_CRC_FORCE_GCE_2_MASK 0x00030000
#define EC_CRC_EXTENDED_RX_PROTOCOL_CONTROL_TABLE_1_CRC_FORCE_GCE_2_SHIFT 16
/*
 * ec_gce 3
 * [0] - 0: use gce result,  1: use force bit
 * [1] - force bit value
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_EXTENDED_RX_PROTOCOL_CONTROL_TABLE_1_CRC_FORCE_GCE_3_MASK 0x000C0000
#define EC_CRC_EXTENDED_RX_PROTOCOL_CONTROL_TABLE_1_CRC_FORCE_GCE_3_SHIFT 18
/*
 * csp_gce 0
 * [0] - 0: use gce result,  1: use force bit
 * [1] - force bit value
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_EXTENDED_RX_PROTOCOL_CONTROL_TABLE_1_CRC_FORCE_GCE_CSP_0_MASK 0x00300000
#define EC_CRC_EXTENDED_RX_PROTOCOL_CONTROL_TABLE_1_CRC_FORCE_GCE_CSP_0_SHIFT 20
/*
 * csp_gce 1
 * [0] - 0: use gce result,  1: use force bit
 * [1] - force bit value
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_EXTENDED_RX_PROTOCOL_CONTROL_TABLE_1_CRC_FORCE_GCE_CSP_1_MASK 0x00C00000
#define EC_CRC_EXTENDED_RX_PROTOCOL_CONTROL_TABLE_1_CRC_FORCE_GCE_CSP_1_SHIFT 22
/*
 * spare bits in memory
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_EXTENDED_RX_PROTOCOL_CONTROL_TABLE_1_SPARE (1 << 24)

/**** tx_protocol_control_table_addr register ****/
/*
 * Tx crc protocol control table address (4x1bit FE, protocol_number[5:0]}
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_EXTENDED_TX_PROTOCOL_CONTROL_TABLE_ADDR_VAL_MASK 0x000003FF
#define EC_CRC_EXTENDED_TX_PROTOCOL_CONTROL_TABLE_ADDR_VAL_SHIFT 0

/**** tx_protocol_control_table_1 register ****/
/*
 * alu input value table address
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_EXTENDED_TX_PROTOCOL_CONTROL_TABLE_1_ALU_INPUT_SEL_MASK 0x0000000F
#define EC_CRC_EXTENDED_TX_PROTOCOL_CONTROL_TABLE_1_ALU_INPUT_SEL_SHIFT 0
/*
 * crc enable table address
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_EXTENDED_TX_PROTOCOL_CONTROL_TABLE_1_CRC_EN_SEL_MASK 0x000003F0
#define EC_CRC_EXTENDED_TX_PROTOCOL_CONTROL_TABLE_1_CRC_EN_SEL_SHIFT 4
/*
 * Generic crc engines selection for store end forward
 * 0(8bit),1(8bit),2(16bit),3(32bit)
 * 0 - GCE0, GCE1, GCE2, GCE3
 * 1 - GCE1, GCE2, GCE3, GCE0
 * 2 - GCE2, GCE3, GCE0, GCE1
 * 3 - GCE3, GCE0, GCE1, GCE2
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_EXTENDED_TX_PROTOCOL_CONTROL_TABLE_1_CRC_SAF_SEL_MASK 0x00000C00
#define EC_CRC_EXTENDED_TX_PROTOCOL_CONTROL_TABLE_1_CRC_SAF_SEL_SHIFT 10
/*
 * spare bits in memory
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_EXTENDED_TX_PROTOCOL_CONTROL_TABLE_1_SPARE_MASK 0x0001F000
#define EC_CRC_EXTENDED_TX_PROTOCOL_CONTROL_TABLE_1_SPARE_SHIFT 12

/**** tx_insert_en_table_addr register ****/
/*
 * Tx CRC replace enable table address
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_EXTENDED_TX_INSERT_EN_TABLE_ADDR_VAL_MASK 0x0000003F
#define EC_CRC_EXTENDED_TX_INSERT_EN_TABLE_ADDR_VAL_SHIFT 0

/**** tx_insert_en_table_1 register ****/
/*
 * gce_0
 * [0] -insert enable table select - 0: select Tx descriptor, 1: select table value
 * [1] -insert enable table value - 0: disable crc insertion, 1: enable crc insertion
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_EXTENDED_TX_INSERT_EN_TABLE_1_GCE_0_MASK 0x00000003
#define EC_CRC_EXTENDED_TX_INSERT_EN_TABLE_1_GCE_0_SHIFT 0
/*
 * gce_1
 * [0] -insert enable table select - 0: select Tx descriptor, 1: select table value
 * [1] -insert enable table value - 0: disable crc insertion, 1: enable crc insertion
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_EXTENDED_TX_INSERT_EN_TABLE_1_GCE_1_MASK 0x0000000C
#define EC_CRC_EXTENDED_TX_INSERT_EN_TABLE_1_GCE_1_SHIFT 2
/*
 * gce_2
 * [0] -insert enable table select - 0: select Tx descriptor, 1: select table value
 * [1] -insert enable table value - 0: disable crc insertion, 1: enable crc insertion
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_EXTENDED_TX_INSERT_EN_TABLE_1_GCE_2_MASK 0x00000030
#define EC_CRC_EXTENDED_TX_INSERT_EN_TABLE_1_GCE_2_SHIFT 4
/*
 * gce_3
 * [0] -insert enable table select - 0: select Tx descriptor, 1: select table value
 * [1] -insert enable table value - 0: disable crc insertion, 1: enable crc insertion
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_EXTENDED_TX_INSERT_EN_TABLE_1_GCE_3_MASK 0x000000C0
#define EC_CRC_EXTENDED_TX_INSERT_EN_TABLE_1_GCE_3_SHIFT 6
/*
 * saf enable, per gce
 * 00 - insert after FIFO disabled
 * 01 - insert after FIFO 8bit
 * 10 - insert after FIFO 16 bit (crc 2, 3 only)
 * 11 - insert after FIFO 32 bit (crc 3 only)
 * Reset: 0x0         Access: RW
 */
#define EC_CRC_EXTENDED_TX_INSERT_EN_TABLE_1_SAF_EN_MASK 0x0000FF00
#define EC_CRC_EXTENDED_TX_INSERT_EN_TABLE_1_SAF_EN_SHIFT 8

/**** arb_cfg register ****/
/*
 * arbiter enable
 * Reset: 0x1         Access: RW
 */
#define EC_OUTSTANDING_GEN_ARB_CFG_EN    (1 << 0)
/*
 * 0-dwrr
 * 1-tdm
 * Reset: 0x0         Access: RW
 */
#define EC_OUTSTANDING_GEN_ARB_CFG_TDM   (1 << 1)
/*
 * tdm arbiter type
 * 0 - switch queue each clock
 * 1 - switch queue each dequeue
 * Reset: 0x0         Access: RW
 */
#define EC_OUTSTANDING_GEN_ARB_CFG_TDM_TYPE (1 << 2)

/**** arb_cfg_1 register ****/
/*
 * per EC
 * Soft reset of arbiter credit counter
 * Reset: 0x0         Access: RW
 */
#define EC_OUTSTANDING_ARB_CFG_1_ARB_SOFT_RESET (1 << 0)
/*
 * per EC
 * 0-credit will be reset when queue is empty
 * 1-credit will not be reset when queue is empty
 * Reset: 0x1         Access: RW
 */
#define EC_OUTSTANDING_ARB_CFG_1_ARB_RST_CREDIT_DIS (1 << 1)
/*
 * per EC
 * 0- reset counter to zero
 * 1- cut counter at cnt_max_rst
 * Reset: 0x1         Access: RW
 */
#define EC_OUTSTANDING_ARB_CFG_1_ARB_CNT_RST_SEL (1 << 2)
/*
 * per EC
 * Arbiter queue enable
 * Reset: 0x1         Access: RW
 */
#define EC_OUTSTANDING_ARB_CFG_1_ARB_QUEUE_EN (1 << 3)
/*
 * per EC
 * Strict priority  value
 * Reset: 0x1         Access: RW
 */
#define EC_OUTSTANDING_ARB_CFG_1_ARB_STRICT_PRIO_MASK 0x00000030
#define EC_OUTSTANDING_ARB_CFG_1_ARB_STRICT_PRIO_SHIFT 4
/*
 * per EC
 * maximum value for the credit counter at reset
 * Reset: 0x1         Access: RW
 */
#define EC_OUTSTANDING_ARB_CFG_1_ARB_CNT_MAX_RST_MASK 0xFFFFFF00
#define EC_OUTSTANDING_ARB_CFG_1_ARB_CNT_MAX_RST_SHIFT 8

/**** arb_cfg_2 register ****/
/*
 * per EC
 * weight value
 * Reset: 0x1         Access: RW
 */
#define EC_OUTSTANDING_ARB_CFG_2_ARB_WEIGHT_MASK 0x000000FF
#define EC_OUTSTANDING_ARB_CFG_2_ARB_WEIGHT_SHIFT 0
/*
 * per EC
 * maximum value for the credit counter
 * Reset: 0x1         Access: RW
 */
#define EC_OUTSTANDING_ARB_CFG_2_ARB_CNT_MAX_VAL_MASK 0xFFFFFF00
#define EC_OUTSTANDING_ARB_CFG_2_ARB_CNT_MAX_VAL_SHIFT 8

/**** to_rfw_shared register ****/
/*
 * rx credit bus init delay
 * Reset: 0x64        Access: RW
 */
#define EC_RFF_TO_RFW_SHARED_RX_DELAY_INIT_MASK 0x0000FFFF
#define EC_RFF_TO_RFW_SHARED_RX_DELAY_INIT_SHIFT 0
/*
 * rx credit bus init credit
 * Reset: 0x8         Access: RW
 */
#define EC_RFF_TO_RFW_SHARED_RX_INIT_CRDT_BUS_MASK 0x00FF0000
#define EC_RFF_TO_RFW_SHARED_RX_INIT_CRDT_BUS_SHIFT 16
/*
 * bypass rfw_shared
 * Reset: 0x1         Access: RW
 */
#define EC_RFF_TO_RFW_SHARED_BYPASS      (1 << 24)
/*
 * rx credit bus sw reset
 * Reset: 0x0         Access: RW
 */
#define EC_RFF_TO_RFW_SHARED_RX_SW_RESET (1 << 25)
/*
 * tx credit bus sw reset
 * Reset: 0x0         Access: RW
 */
#define EC_RFF_TO_RFW_SHARED_TX_SW_RESET (1 << 26)

/**** data_fifo_depth_limit register ****/
/*
 * fifo depth size
 * Reset: 0x40        Access: RW
 */
#define EC_RFF_DATA_FIFO_DEPTH_LIMIT_VALUE_MASK 0x000000FF
#define EC_RFF_DATA_FIFO_DEPTH_LIMIT_VALUE_SHIFT 0

/**** table_1 register ****/
/*
 * protocol_index selection for rfw control_table adressing (per procol_numebr)
 * 0 - selected procol_index (v3)
 * 1 - selected protocol_number (ec_rfw / shared_rfw)
 * 2 - from table (val_ctrl_table)
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_PROT_INDEX_TABLE_1_SEL_CTRL_TABLE_MASK 0x00000007
#define EC_RFW_PROT_INDEX_TABLE_1_SEL_CTRL_TABLE_SHIFT 0
/*
 * protocol_index value for rfw control_table adressing (per procol_numebr)
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_PROT_INDEX_TABLE_1_VAL_CTRL_TABLE_MASK 0x000000F8
#define EC_RFW_PROT_INDEX_TABLE_1_VAL_CTRL_TABLE_SHIFT 3

/**** table_2 register ****/
/*
 * protocol_index selection for rfw l3 checksum (per procol_numebr)
 * 0 - selected procol_index (v3)
 * 1 - selected protocol_number (ec_rfw / shared_rfw)
 * 2 - from table (val_ctrl_table)
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_PROT_INDEX_TABLE_2_SEL_L3_CKS_MASK 0x00000007
#define EC_RFW_PROT_INDEX_TABLE_2_SEL_L3_CKS_SHIFT 0
/*
 * protocol_index value for rfw l3 checksum (per procol_numebr)
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_PROT_INDEX_TABLE_2_VAL_L3_CKS_MASK 0x000000F8
#define EC_RFW_PROT_INDEX_TABLE_2_VAL_L3_CKS_SHIFT 3
/*
 * protocol_index selection for rfw l4 checksum (per procol_numebr)
 * 0 - selected procol_index (v3)
 * 1 - selected protocol_number (ec_rfw / shared_rfw)
 * 2 - from table (val_ctrl_table)
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_PROT_INDEX_TABLE_2_SEL_L4_CKS_MASK 0x00000700
#define EC_RFW_PROT_INDEX_TABLE_2_SEL_L4_CKS_SHIFT 8
/*
 * protocol_index value for rfw l4 checksum (per procol_numebr)
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_PROT_INDEX_TABLE_2_VAL_L4_CKS_MASK 0x0000F800
#define EC_RFW_PROT_INDEX_TABLE_2_VAL_L4_CKS_SHIFT 11
/*
 * protocol_index selection for rfw l3 tunnel checksum (per procol_numebr)
 * 0 - selected procol_index (v3)
 * 1 - selected protocol_number (ec_rfw / shared_rfw)
 * 2 - from table (val_ctrl_table)
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_PROT_INDEX_TABLE_2_SEL_L3_TCKS_MASK 0x00070000
#define EC_RFW_PROT_INDEX_TABLE_2_SEL_L3_TCKS_SHIFT 16
/*
 * protocol_index value for rfw l3 tunnel checksum (per procol_numebr)
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_PROT_INDEX_TABLE_2_VAL_L3_TCKS_MASK 0x00F80000
#define EC_RFW_PROT_INDEX_TABLE_2_VAL_L3_TCKS_SHIFT 19
/*
 * protocol_index selection for rfw l4 tunnerl checksum (per procol_numebr)
 * 0 - selected procol_index (v3)
 * 1 - selected protocol_number (ec_rfw / shared_rfw)
 * 2 - from table (val_ctrl_table)
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_PROT_INDEX_TABLE_2_SEL_L4_TCKS_MASK 0x07000000
#define EC_RFW_PROT_INDEX_TABLE_2_SEL_L4_TCKS_SHIFT 24
/*
 * protocol_index value for rfw l4 tunnel checksum (per procol_numebr)
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_PROT_INDEX_TABLE_2_VAL_L4_TCKS_MASK 0xF8000000
#define EC_RFW_PROT_INDEX_TABLE_2_VAL_L4_TCKS_SHIFT 27

/**** table_3 register ****/
/*
 * l3_offset selection for rfw l3 checksum (per procol_numebr)
 * 0 - selected procol_index (v3)
 * 1 - selected protocol_number (ec_rfw / shared_rfw)
 * 2 - from table (val_ctrl_table)
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_PROT_INDEX_TABLE_3_SEL_L3_CKS_OFFSET_MASK 0x00000007
#define EC_RFW_PROT_INDEX_TABLE_3_SEL_L3_CKS_OFFSET_SHIFT 0
/*
 * l3_offset value for rfw l3 checksum (per procol_numebr)
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_PROT_INDEX_TABLE_3_VAL_L3_CKS_OFFSET_MASK 0x00000FF8
#define EC_RFW_PROT_INDEX_TABLE_3_VAL_L3_CKS_OFFSET_SHIFT 3
/*
 * l3_header_length selection for rfw l3 checksum (per procol_numebr)
 * 0 - selected procol_index (v3)
 * 1 - selected protocol_number (ec_rfw / shared_rfw)
 * 2 - from table (val_ctrl_table)
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_PROT_INDEX_TABLE_3_SEL_L3_CKS_HDR_LEN_MASK 0x00070000
#define EC_RFW_PROT_INDEX_TABLE_3_SEL_L3_CKS_HDR_LEN_SHIFT 16
/*
 * l3_header_length value for rfw l3 checksum (per procol_numebr)
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_PROT_INDEX_TABLE_3_VAL_L3_CKS_HDR_LEN_MASK 0x0FF80000
#define EC_RFW_PROT_INDEX_TABLE_3_VAL_L3_CKS_HDR_LEN_SHIFT 19

/**** table_4 register ****/
/*
 * l3_offset selection for rfw l3 tunnel checksum (per procol_numebr)
 * 0 - selected procol_index (v3)
 * 1 - selected protocol_number (ec_rfw / shared_rfw)
 * 2 - from table (val_ctrl_table)
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_PROT_INDEX_TABLE_4_SEL_L3_TCKS_OFFSET_MASK 0x00000007
#define EC_RFW_PROT_INDEX_TABLE_4_SEL_L3_TCKS_OFFSET_SHIFT 0
/*
 * l3_offset value for rfw l3 tunnel checksum (per procol_numebr)
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_PROT_INDEX_TABLE_4_VAL_L3_TCKS_OFFSET_MASK 0x00000FF8
#define EC_RFW_PROT_INDEX_TABLE_4_VAL_L3_TCKS_OFFSET_SHIFT 3
/*
 * l3_header_length selection for rfw l3 tunnel checksum (per procol_numebr)
 * 0 - selected procol_index (v3)
 * 1 - selected protocol_number (ec_rfw / shared_rfw)
 * 2 - from table (val_ctrl_table)
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_PROT_INDEX_TABLE_4_SEL_L3_TCKS_HDR_LEN_MASK 0x00070000
#define EC_RFW_PROT_INDEX_TABLE_4_SEL_L3_TCKS_HDR_LEN_SHIFT 16
/*
 * l3_header_length value for rfw l3 tunnel checksum (per procol_numebr)
 * Reset: 0x0         Access: RW
 */
#define EC_RFW_PROT_INDEX_TABLE_4_VAL_L3_TCKS_HDR_LEN_MASK 0x0FF80000
#define EC_RFW_PROT_INDEX_TABLE_4_VAL_L3_TCKS_HDR_LEN_SHIFT 19

/**** offset_from_sop0 register ****/
/*
 * offset from sop 0
 * Reset: 0x0         Access: RW
 */
#define EC_UDP_LEN_INSERTION_OFFSET_FROM_SOP0_VAL_MASK 0x00003FFF
#define EC_UDP_LEN_INSERTION_OFFSET_FROM_SOP0_VAL_SHIFT 0

/**** offset_from_sop1 register ****/
/*
 * offset from sop 1
 * Reset: 0x0         Access: RW
 */
#define EC_UDP_LEN_INSERTION_OFFSET_FROM_SOP1_VAL_MASK 0x00003FFF
#define EC_UDP_LEN_INSERTION_OFFSET_FROM_SOP1_VAL_SHIFT 0

/**** offset_from_sop2 register ****/
/*
 * offset from sop 2
 * Reset: 0x0         Access: RW
 */
#define EC_UDP_LEN_INSERTION_OFFSET_FROM_SOP2_VAL_MASK 0x00003FFF
#define EC_UDP_LEN_INSERTION_OFFSET_FROM_SOP2_VAL_SHIFT 0

/**** mask register ****/
/*
 * mask
 * Reset: 0x0         Access: RW
 */
#define EC_UDP_LEN_INSERTION_MASK_VAL_MASK 0x0000FFFF
#define EC_UDP_LEN_INSERTION_MASK_VAL_SHIFT 0

/**** enable register ****/
/*
 * enable from descriptor
 * 0 - from register
 * 1 - from descriptor
 * Reset: 0x0         Access: RW
 */
#define EC_UDP_LEN_INSERTION_ENABLE_FROM_DESC (1 << 0)
/*
 * enable from register
 * 0 - disable
 * 1 - enable
 * Reset: 0x0         Access: RW
 */
#define EC_UDP_LEN_INSERTION_ENABLE_FROM_REG (1 << 1)
/*
 * udp len insertion offset selection
 * 0 - from register
 * 1 - from descriptor
 * Reset: 0x0         Access: RW
 */
#define EC_UDP_LEN_INSERTION_ENABLE_OFFSET_FROM_DESC (1 << 2)

/**** protocol_number register ****/
/*
 * offset (in bits) of protocol_number field in  info vector
 * Reset: 0x0         Access: RW
 */
#define EC_TMI_V4_PROTOCOL_NUMBER_OFFSET_MASK 0x0000FFFF
#define EC_TMI_V4_PROTOCOL_NUMBER_OFFSET_SHIFT 0

/**** req register ****/
/* Reset: 0x0         Access: RW */
#define EC_CRDT_OS2SR_WR_REQ_INIT_LEVEL_SIGNAL (1 << 0)

/**** res register ****/
/* Reset: 0x0         Access: RW */
#define EC_CRDT_OS2SR_WR_RES_INIT_LEVEL_SIGNAL (1 << 0)
/* Reset: 0x55        Access: RW */
#define EC_CRDT_OS2SR_WR_RES_DELAY_INIT_MASK 0x0001FFFE
#define EC_CRDT_OS2SR_WR_RES_DELAY_INIT_SHIFT 1
/* Reset: 0x6         Access: RW */
#define EC_CRDT_OS2SR_WR_RES_INIT_CRDT_BUS_MASK 0x000E0000
#define EC_CRDT_OS2SR_WR_RES_INIT_CRDT_BUS_SHIFT 17

#ifdef __cplusplus
}
#endif

#endif

/** @} */
