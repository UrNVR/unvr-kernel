/*
 * Copyright 2018, Amazon.com, Inc. or its affiliates. All Rights Reserved
 */

/**
 *  @{
 * @file   al_hal_eth_mac_v4_regs.h
 *
 * @brief eth_mac_v4 registers
 *
 * This file was auto-generated by RegGen v1.2.1
 *
 */

#ifndef __AL_HAL_ETH_MAC_V4_REGS_H__
#define __AL_HAL_ETH_MAC_V4_REGS_H__

#include "al_hal_plat_types.h"

#ifdef __cplusplus
extern "C" {
#endif

/*
 * Unit Registers
 */

/*
 * Ethernet MPS Version register
 */
struct al_eth_mac_v4_gen {
	/* [0x0] Ethernet Controller Version */
	uint32_t version;
	/* [0x4] Read-only register showing what MAC speeds are supported in this channel */
	uint32_t avail;
	/* [0x8] Read-only register showing which channel thie register block is in */
	uint32_t ch_num;
	/* [0xc] */
	uint32_t rsrvd_0;
	/* [0x10] MAC selection configuration */
	uint32_t cfg;
	/* [0x14] */
	uint32_t rsrvd_1[3];
	/* [0x20] MDIO control register for MDIO interface 1 */
	uint32_t mdio_ctrl_1;
	/* [0x24] MDIO information register for MDIO interface 1 */
	uint32_t mdio_1;
	/* [0x28] */
	uint32_t rsrvd_2[2];
	/*
	 * [0x30] Scratch register 0
	 * Scratch value
	 * Reset: 0x0         Access: RW
	 */
	uint32_t scratch0;
	/*
	 * [0x34] Scratch register 1
	 * Scratch value
	 * Reset: 0x0         Access: RW
	 */
	uint32_t scratch1;
	/* [0x38] */
	uint32_t rsrvd_3[6];
	/* [0x50] Ethernet LED configuration */
	uint32_t led_cfg;
	/* [0x54] */
	uint32_t rsrvd_4[3];
	/* [0x60] TX Rate Counter configuration */
	uint32_t tx_rate_cnt;
	/*
	 * [0x64] TX Rate Counter window length
	 * Measurement window length (units of 2ns)
	 * Reset: 0x0         Access: RW
	 */
	uint32_t tx_rate_cnt_win;
	/*
	 * [0x68] TX Rate Counter Frame count
	 * Frames measured during the window
	 * Reset: 0x0         Access: RO
	 */
	uint32_t tx_rate_cnt_frame;
	/*
	 * [0x6c] TX Rate Counter Byte count
	 * Bytes measured during the window
	 * Reset: 0x0         Access: RO
	 */
	uint32_t tx_rate_cnt_byte;
	/* [0x70] */
	uint32_t rsrvd_5[4];
	/* [0x80] RX Rate Counter configuration */
	uint32_t rx_rate_cnt;
	/*
	 * [0x84] RX Rate Counter window length
	 * Measurement window length (units of 2ns)
	 * Reset: 0x0         Access: RW
	 */
	uint32_t rx_rate_cnt_win;
	/*
	 * [0x88] TX Rate Counter Frame count
	 * Frames measured during the window
	 * Reset: 0x0         Access: RO
	 */
	uint32_t rx_rate_cnt_frame;
	/*
	 * [0x8c] TX Rate Counter Byte count
	 * Bytes measured during the window
	 * Reset: 0x0         Access: RO
	 */
	uint32_t rx_rate_cnt_byte;
	/* [0x90] */
	uint32_t rsrvd_6[24];
	/*
	 * [0xf0] Spare registers. Reset to 0.
	 * Reset: 0x0         Access: RW
	 */
	uint32_t spare_zero_lo;
	/*
	 * [0xf4] Spare registers. Reset to 0.
	 * Reset: 0x0         Access: RW
	 */
	uint32_t spare_zero_hi;
	/*
	 * [0xf8] Spare registers. Reset to 1.
	 * Reset: 0xffffffff  Access: RW
	 */
	uint32_t spare_one_lo;
	/*
	 * [0xfc] Spare registers. Reset to 1.
	 * Reset: 0xffffffff  Access: RW
	 */
	uint32_t spare_one_hi;
};

struct al_eth_mac_v4_mtip {
	/* [0x0] 100G PCS Core regs address. Only relevant for Channel 0. */
	uint32_t pcs_100g_addr;
	/* [0x4] 100G PCS Core regs data. Only relevant for Channel 0. */
	uint32_t pcs_100g_data;
	/* [0x8] */
	uint32_t rsrvd_0[2];
	/* [0x10] 100G MAC Core regs address. Only relevant for Channel 0. */
	uint32_t mac_100g_addr;
	/*
	 * [0x14] 100G MAC Core regs data. Only relevant for Channel 0.
	 * MTIP 100G MAC Data (32 bits)
	 * Reset: 0x0         Access: RW
	 */
	uint32_t mac_100g_data;
	/* [0x18] */
	uint32_t rsrvd_1[2];
	/* [0x20] */
	uint32_t pcs_50g_addr;
	/* [0x24] */
	uint32_t pcs_50g_data;
	/* [0x28] */
	uint32_t rsrvd_2[2];
	/* [0x30] */
	uint32_t mac_50g_addr;
	/*
	 * [0x34] MTIP 50G MAC Data (32 bits)
	 * Reset: 0x0         Access: RW
	 */
	uint32_t mac_50g_data;
	/* [0x38] */
	uint32_t rsrvd_3[2];
	/* [0x40] AN/LT wrapper  register file address */
	uint32_t an_lt_0_addr;
	/*
	 * [0x44] AN/LT wrapper register file data
	 * Data value
	 * Reset: 0x0         Access: RW
	 */
	uint32_t an_lt_0_data;
	/* [0x48] AN/LT wrapper  register file address */
	uint32_t an_lt_1_addr;
	/*
	 * [0x4c] AN/LT wrapper register file data
	 * Data value
	 * Reset: 0x0         Access: RW
	 */
	uint32_t an_lt_1_data;
	/* [0x50] AN/LT wrapper  register file address */
	uint32_t an_lt_2_addr;
	/*
	 * [0x54] AN/LT wrapper register file data
	 * Data value
	 * Reset: 0x0         Access: RW
	 */
	uint32_t an_lt_2_data;
	/* [0x58] AN/LT wrapper  register file address */
	uint32_t an_lt_3_addr;
	/*
	 * [0x5c] AN/LT wrapper register file data
	 * Data value
	 * Reset: 0x0         Access: RW
	 */
	uint32_t an_lt_3_data;
	/* [0x60] */
	uint32_t rsrvd_4[40];
};

/*
 * Statistics counters
 */
struct al_eth_mac_v4_stat_pcs {
	/*
	 * [0x0] PCS 100G align_lock counter
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t align_lock;
	/*
	 * [0x4] PCS 100G  Block lock counter (masked using pcs_block_lock_bus_mask)
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t block_lock_bus;
	/*
	 * [0x8] PCS 100G  Block lock counter (individual bit selected with pcs_block_lock_bit_sel)
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t block_lock_bit;
	/*
	 * [0xc] PCS 100G link status counter
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t link_status;
	/* [0x10] */
	uint32_t rsrvd_0[4];
	/*
	 * [0x20] PCS 50G link status counter for channel 0
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t xl_link_status0;
	/*
	 * [0x24] PCS 50G link status counter for channel 1
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t xl_link_status1;
	/*
	 * [0x28] PCS 50G link status counter for channel 2
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t xl_link_status2;
	/*
	 * [0x2c] PCS 50G link status counter for channel 3
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t xl_link_status3;
	/* [0x30] */
	uint32_t rsrvd_1[4];
	/*
	 * [0x40] PCS amps_lock 0 counter
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t amps_lock0;
	/*
	 * [0x44] PCS amps_lock 1 counter
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t amps_lock1;
	/*
	 * [0x48] PCS amps_lock 2 counter
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t amps_lock2;
	/*
	 * [0x4c] PCS amps_lock 3 counter
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t amps_lock3;
	/* [0x50] */
	uint32_t rsrvd_2[4];
	/*
	 * [0x60] RSFEC aligned 0 counter
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t rsfec_aligned0;
	/*
	 * [0x64] RSFEC aligned 1 counter
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t rsfec_aligned1;
	/*
	 * [0x68] RSFEC aligned 2 counter
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t rsfec_aligned2;
	/*
	 * [0x6c] RSFEC aligned 3 counter
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t rsfec_aligned3;
	/* [0x70] */
	uint32_t rsrvd_3[4];
	/*
	 * [0x80] PCS FEC Correctable error count for Virtual Lane 0
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t fec_locked_0;
	/*
	 * [0x84] PCS FEC Correctable error count for Virtual Lane 1
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t fec_locked_1;
	/*
	 * [0x88] PCS FEC Correctable error count for Virtual Lane 2
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t fec_locked_2;
	/*
	 * [0x8c] PCS FEC Correctable error count for Virtual Lane 3
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t fec_locked_3;
	/*
	 * [0x90] PCS FEC Correctable error count for Virtual Lane 4
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t fec_locked_4;
	/*
	 * [0x94] PCS FEC Correctable error count for Virtual Lane 5
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t fec_locked_5;
	/*
	 * [0x98] PCS FEC Correctable error count for Virtual Lane 6
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t fec_locked_6;
	/*
	 * [0x9c] PCS FEC Correctable error count for Virtual Lane 7
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t fec_locked_7;
	/* [0xa0] */
	uint32_t rsrvd_4[4];
	/*
	 * [0xb0] PCS FEC Correctable error count for Virtual Lane 0
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t fec_cerr_0;
	/*
	 * [0xb4] PCS FEC Correctable error count for Virtual Lane 1
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t fec_cerr_1;
	/*
	 * [0xb8] PCS FEC Correctable error count for Virtual Lane 2
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t fec_cerr_2;
	/*
	 * [0xbc] PCS FEC Correctable error count for Virtual Lane 3
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t fec_cerr_3;
	/*
	 * [0xc0] PCS FEC Correctable error count for Virtual Lane 4
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t fec_cerr_4;
	/*
	 * [0xc4] PCS FEC Correctable error count for Virtual Lane 5
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t fec_cerr_5;
	/*
	 * [0xc8] PCS FEC Correctable error count for Virtual Lane 6
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t fec_cerr_6;
	/*
	 * [0xcc] PCS FEC Correctable error count for Virtual Lane 7
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t fec_cerr_7;
	/* [0xd0] */
	uint32_t rsrvd_5[4];
	/*
	 * [0xe0] PCS FEC Non Correctable error count for Virtual Lane 0
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t fec_ncerr_0;
	/*
	 * [0xe4] PCS FEC Non Correctable error count for Virtual Lane 1
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t fec_ncerr_1;
	/*
	 * [0xe8] PCS FEC Non Correctable error count for Virtual Lane 2
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t fec_ncerr_2;
	/*
	 * [0xec] PCS FEC Non Correctable error count for Virtual Lane 3
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t fec_ncerr_3;
	/*
	 * [0xf0] PCS FEC Non Correctable error count for Virtual Lane 4
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t fec_ncerr_4;
	/*
	 * [0xf4] PCS FEC Non Correctable error count for Virtual Lane 5
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t fec_ncerr_5;
	/*
	 * [0xf8] PCS FEC Non Correctable error count for Virtual Lane 6
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t fec_ncerr_6;
	/*
	 * [0xfc] PCS FEC Non Correctable error count for Virtual Lane 7
	 * Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t fec_ncerr_7;
};

/*
 * General configuration for the MAC V4 integration
 */
struct al_eth_mac_v4_gen_v4 {
	/* [0x0] ASYNC FIFOs control */
	uint32_t afifo_ctrl;
	/* [0x4] TX ASYNC FIFO configuration */
	uint32_t tx_afifo_cfg_1;
	/* [0x8] TX ASYNC FIFO configuration */
	uint32_t tx_afifo_cfg_2;
	/* [0xc] TX ASYNC FIFO configuration */
	uint32_t tx_afifo_cfg_3;
	/* [0x10] TX ASYNC FIFO configuration */
	uint32_t tx_afifo_cfg_4;
	/* [0x14] TX ASYNC FIFO configuration */
	uint32_t tx_afifo_cfg_5;
	/* [0x18] RX ASYNC FIFO configuration */
	uint32_t rx_afifo_cfg_1;
	/* [0x1c] RX ASYNC FIFO configuration */
	uint32_t rx_afifo_cfg_2;
	/* [0x20] RX ASYNC FIFO configuration */
	uint32_t rx_afifo_cfg_3;
	/* [0x24] RX ASYNC FIFO configuration */
	uint32_t rx_afifo_cfg_4;
	/* [0x28] RX ASYNC FIFO configuration */
	uint32_t rx_afifo_cfg_5;
	/* [0x2c] */
	uint32_t rsrvd_0;
	/* [0x30] MAC selection configuration. */
	uint32_t mac;
	/* [0x34] */
	uint32_t rsrvd_1[3];
	/* [0x40] Energy Efficient Ethernet (EEE) PCS Pin Configuration */
	uint32_t pcs_eee_pin_cfg;
	/* [0x44] Energy Efficient Ethernet (EEE) PCS Pin Status */
	uint32_t pcs_eee_pin_status;
	/* [0x48] */
	uint32_t rsrvd_2[2];
	/*
	 * [0x50] 50G PCS Pin Configuration
	 * Reset: 0x0         Access: RW
	 */
	uint32_t pcs_50g_pin_cfg;
	/* [0x54] 50G PCS Pin Status */
	uint32_t pcs_50g_pin_status;
	/* [0x58] */
	uint32_t rsrvd_3[2];
	/* [0x60] 40/100G MAC Configuration (to pins on instance) */
	uint32_t mac_100g_pin_cfg;
	/* [0x64] 40/100G MAC Status (from pins on instance) */
	uint32_t mac_100g_pin_status;
	/* [0x68] */
	uint32_t rsrvd_4[2];
	/* [0x70] 10/25/40/50G MAC Configuration (to pins on instance) */
	uint32_t mac_50g_pin_cfg;
	/* [0x74] 10/25/40/50G MAC Status (from pins on instance) */
	uint32_t mac_50g_pin_status;
	/* [0x78] */
	uint32_t rsrvd_5[2];
	/* [0x80] 100G MAC programmable VLAN values */
	uint32_t mac_100g_vlan01;
	/* [0x84] 100G MAC programmable VLAN values */
	uint32_t mac_100g_vlan23;
	/* [0x88] 100G MAC programmable VLAN values */
	uint32_t mac_100g_vlan45;
	/* [0x8c] 100G MAC programmable VLAN values */
	uint32_t mac_100g_vlan67;
	/* [0x90] */
	uint32_t rsrvd_6[4];
	/* [0xa0] Preamble configuration (high [55:32]) */
	uint32_t tx_preamble_cfg_high;
	/*
	 * [0xa4] Preamble configuration (low [31:0])
	 * TX preamble value
	 * Reset: 0x55555555  Access: RW
	 */
	uint32_t tx_preamble_cfg_low;
	/* [0xa8] */
	uint32_t rsrvd_7[2];
	/* [0xb0] RX Preamble status (high [55:32]) */
	uint32_t rx_preamble_status_high;
	/*
	 * [0xb4] RX Preamble status (low [31:0])
	 * RX preamble value
	 * Reset: 0x0         Access: RO
	 */
	uint32_t rx_preamble_status_low;
	/* [0xb8] */
	uint32_t rsrvd_8[2];
	/* [0xc0] PCS 100G Counter edge selection */
	uint32_t stat_cfg_mac_100g;
	/* [0xc4] PCS 100G Counter edge selection */
	uint32_t stat_cfg_mac_50g;
	/* [0xc8] EEE Counter edge selection */
	uint32_t stat_cfg_eee;
	/* [0xcc] */
	uint32_t rsrvd_9;
	/* [0xd0] MAC 50G Interrupt edge detection */
	uint32_t int_cfg_lmac;
	/* [0xd4] MAC 100G Interrupt edge detection */
	uint32_t int_cfg_cmac;
	/* [0xd8] Miscellaneous interrupt edge detection */
	uint32_t int_cfg;
	/* [0xdc] */
	uint32_t rsrvd_10[9];
};

/*
 * Statistic counters
 */
struct al_eth_mac_v4_stat {
	/*
	 * [0x0] Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t tx_afifo_in_pkt;
	/*
	 * [0x4] Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t tx_afifo_in_short_pkt;
	/*
	 * [0x8] Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t tx_afifo_in_long_pkt;
	/*
	 * [0xc] Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t tx_afifo_out_pkt;
	/*
	 * [0x10] Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t tx_afifo_out_short_pkt;
	/*
	 * [0x14] Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t tx_afifo_out_long_pkt;
	/*
	 * [0x18] Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t tx_afifo_out_drop_pkt;
	/* [0x1c] */
	uint32_t rsrvd_0;
	/*
	 * [0x20] Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t rx_afifo_in_pkt;
	/*
	 * [0x24] Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t rx_afifo_in_short_pkt;
	/*
	 * [0x28] Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t rx_afifo_in_long_pkt;
	/*
	 * [0x2c] Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t rx_afifo_out_pkt;
	/*
	 * [0x30] Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t rx_afifo_out_short_pkt;
	/*
	 * [0x34] Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t rx_afifo_out_long_pkt;
	/*
	 * [0x38] Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t rx_afifo_out_drop_pkt;
	/* [0x3c] */
	uint32_t rsrvd_1[5];
	/*
	 * [0x50] Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t mac_100g_tx_underflow;
	/*
	 * [0x54] Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t mac_100g_rx_overflow;
	/*
	 * [0x58] Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t mac_100g_rem_fault;
	/*
	 * [0x5c] Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t mac_100g_loc_fault;
	/*
	 * [0x60] Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t mac_100g_lpi_ind;
	/*
	 * [0x64] Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t mac_100g_ff_tx_pfc_ack;
	/* [0x68] */
	uint32_t rsrvd_2[6];
	/*
	 * [0x80] Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t mac_50g_tx_underflow;
	/*
	 * [0x84] Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t mac_50g_rx_overflow;
	/*
	 * [0x88] Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t mac_50g_li_fault;
	/*
	 * [0x8c] Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t mac_50g_rem_fault;
	/*
	 * [0x90] Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t mac_50g_loc_fault;
	/*
	 * [0x94] Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t mac_50g_reg_lowp;
	/* [0x98] */
	uint32_t rsrvd_3[6];
	/*
	 * [0xb0] Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t eee_ec_active;
	/*
	 * [0xb4] Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t eee_rx_lpi_active;
	/* [0xb8] */
	uint32_t rsrvd_4[2];
	/*
	 * [0xc0] Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t tx_afifo_in_eop_err;
	/*
	 * [0xc4] Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t tx_afifo_in_sop_err;
	/*
	 * [0xc8] Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t tx_afifo_out_eop_err;
	/* [0xcc] */
	uint32_t rsrvd_5;
	/*
	 * [0xd0] Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t rx_afifo_in_eop_err;
	/*
	 * [0xd4] Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t rx_afifo_in_sop_err;
	/*
	 * [0xd8] Counter value
	 * Reset: 0x0         Access: RW, RtoClr
	 */
	uint32_t rx_afifo_out_eop_err;
	/* [0xdc] */
	uint32_t rsrvd_6[9];
};

/*
 * Shared registers status brought out to channels
 */
struct al_eth_mac_v4_gen_v4_sr {
	/* [0x0] */
	uint32_t rsrvd_0;
	/* [0x4] PCS Status for all channels */
	uint32_t pcs_all_pin_status;
	/* [0x8] */
	uint32_t rsrvd_1[3];
	/* [0x14] 100G PCS Pin Status (Only connected on Channel #0) */
	uint32_t pcs_100g_pin_status;
	/* [0x18] */
	uint32_t rsrvd_2[3];
	/* [0x24] PCS FEC Status */
	uint32_t pcs_fec_pin_status;
	/* [0x28] */
	uint32_t rsrvd_3[54];
};

struct al_eth_mac_v4_regs {
	/* [0x0] Ethernet MPS Version register */
	struct al_eth_mac_v4_gen gen;
	/* [0x100] 4 groups of interrupts */
	uint32_t int_ctrl_mem[64];
	/* [0x200] */
	struct al_eth_mac_v4_mtip mtip;
	/* [0x300] Statistics counters */
	struct al_eth_mac_v4_stat_pcs stat_pcs;
	/* [0x400] */
	uint32_t rsrvd_0[64];
	/* [0x500] General configuration for the MAC V4 integration */
	struct al_eth_mac_v4_gen_v4 gen_v4;
	/* [0x600] Statistic counters */
	struct al_eth_mac_v4_stat stat;
	/* [0x700] Shared registers status brought out to channels */
	struct al_eth_mac_v4_gen_v4_sr gen_v4_sr;
	/* [0x800] */
	uint32_t rsrvd_1[15872];
};


/*
 * Registers Fields
 */

/**** version register ****/
/*
 * Revision number (Minor)
 * Reset: 0x0         Access: RO
 */
#define ETH_MAC_V4_GEN_VERSION_RELEASE_NUM_MINOR_MASK 0x000000FF
#define ETH_MAC_V4_GEN_VERSION_RELEASE_NUM_MINOR_SHIFT 0
/*
 * Revision number (Major)
 * Reset: 0x0         Access: RO
 */
#define ETH_MAC_V4_GEN_VERSION_RELEASE_NUM_MAJOR_MASK 0x0000FF00
#define ETH_MAC_V4_GEN_VERSION_RELEASE_NUM_MAJOR_SHIFT 8
/*
 * Date of release
 * Reset: 0x0         Access: RO
 */
#define ETH_MAC_V4_GEN_VERSION_DATE_DAY_MASK 0x001F0000
#define ETH_MAC_V4_GEN_VERSION_DATE_DAY_SHIFT 16
/*
 * Month of release
 * Reset: 0x0         Access: RO
 */
#define ETH_MAC_V4_GEN_VERSION_DATA_MONTH_MASK 0x01E00000
#define ETH_MAC_V4_GEN_VERSION_DATA_MONTH_SHIFT 21
/*
 * Year of release (starting from 2000)
 * Reset: 0x0         Access: RO
 */
#define ETH_MAC_V4_GEN_VERSION_DATE_YEAR_MASK 0x3E000000
#define ETH_MAC_V4_GEN_VERSION_DATE_YEAR_SHIFT 25
/*
 * Reserved
 * Reset: 0x0         Access: RO
 */
#define ETH_MAC_V4_GEN_VERSION_RESERVED_MASK 0xC0000000
#define ETH_MAC_V4_GEN_VERSION_RESERVED_SHIFT 30

/**** avail register ****/
/*
 * A 50G MAC is available in this channel
 * Reset: 0x0         Access: RO
 */
#define ETH_MAC_V4_GEN_AVAIL_MAC_50G     (1 << 0)
/*
 * A 100G MAC is available in this channel
 * Reset: 0x0         Access: RO
 */
#define ETH_MAC_V4_GEN_AVAIL_MAC_100G    (1 << 4)

/**** ch_num register ****/
/*
 * Channel number (0 to 3)
 * Reset: 0x0         Access: RO
 */
#define ETH_MAC_V4_GEN_CH_NUM_VAL_MASK   0x00000003
#define ETH_MAC_V4_GEN_CH_NUM_VAL_SHIFT  0

/**** cfg register ****/
/*
 * MDIO select. 0 = 50G MAC, 1 = 100G MAC.
 * Reset: 0x0         Access: RW
 */
#define ETH_MAC_V4_GEN_CFG_MDIO_100_50B_SEL (1 << 0)
/*
 * Swap MDC output
 * 0 - Normal
 * 1 - Flipped
 * Reset: 0x0         Access: RW
 */
#define ETH_MAC_V4_GEN_CFG_MDIO_POL      (1 << 11)

/**** mdio_ctrl_1 register ****/
/*
 * Available indication
 * 0 - The port was available and it is captured by this Ethernet controller.
 * 1 - The port is used by another Ethernet controller.
 * Reset: 0x1         Access: RW
 */
#define ETH_MAC_V4_GEN_MDIO_CTRL_1_AVAIL (1 << 0)

/**** mdio_1 register ****/
/*
 * Current Ethernet interface number that controls the MDIO port
 * Reset: 0x0         Access: RO
 */
#define ETH_MAC_V4_GEN_MDIO_1_INFO_MASK  0x000000FF
#define ETH_MAC_V4_GEN_MDIO_1_INFO_SHIFT 0

/**** led_cfg register ****/
/*
 * 0 = led_cfg_def
 * 1 = tx_in_s_valid
 * 2 = rx_out_s_valid
 * 3 = (rx_out_s_valid | tx_in_s_valid)
 * 10 = ~(eth_led_blink_signal & eth_led_activity_signal)
 * 11 = eth_led_blink_signal & eth_led_activity_signal
 *
 * All others reserved (0)
 * Reset: 0x0         Access: RW
 */
#define ETH_MAC_V4_GEN_LED_CFG_SEL_MASK  0x0000000F
#define ETH_MAC_V4_GEN_LED_CFG_SEL_SHIFT 0
/*
 * LED default value
 * Reset: 0x0         Access: RW
 */
#define ETH_MAC_V4_GEN_LED_CFG_DEF       (1 << 4)
/*
 * LED signal polarity
 * Reset: 0x0         Access: RW
 */
#define ETH_MAC_V4_GEN_LED_CFG_POL       (1 << 5)
/*
 * activity timer (MSB)
 * 32 bit timer @SB clock
 * Reset: 0x14        Access: RW
 */
#define ETH_MAC_V4_GEN_LED_CFG_ACT_TIMER_MASK 0x00FF0000
#define ETH_MAC_V4_GEN_LED_CFG_ACT_TIMER_SHIFT 16
/*
 * activity timer (MSB)
 * 32 bit timer @SB clock
 * Reset: 0x14        Access: RW
 */
#define ETH_MAC_V4_GEN_LED_CFG_BLINK_TIMER_MASK 0xFF000000
#define ETH_MAC_V4_GEN_LED_CFG_BLINK_TIMER_SHIFT 24

/**** tx_rate_cnt register ****/
/*
 * - One-shot mode: Write 1 and then 0 to take single measurement
 * - Other modes: Write 1 to take continuous measurements. Write 0 to stop.
 * Reset: 0x0         Access: RW
 */
#define ETH_MAC_V4_GEN_TX_RATE_CNT_START (1 << 0)
/*
 * Rate counter mode. 0 = one-shot, 1 = windowed, 2 = moving average, 3 = rsvd
 * Reset: 0x0         Access: RW
 */
#define ETH_MAC_V4_GEN_TX_RATE_CNT_MODE_MASK 0x00000006
#define ETH_MAC_V4_GEN_TX_RATE_CNT_MODE_SHIFT 1

/**** rx_rate_cnt register ****/
/*
 * - One-shot mode: Write 1 and then 0 to take single measurement
 * - Other modes: Write 1 to take continuous measurements. Write 0 to stop.
 * Reset: 0x0         Access: RW
 */
#define ETH_MAC_V4_GEN_RX_RATE_CNT_START (1 << 0)
/*
 * Rate counter mode. 0 = one-shot, 1 = windowed, 2 = moving average, 3 = rsvd
 * Reset: 0x0         Access: RW
 */
#define ETH_MAC_V4_GEN_RX_RATE_CNT_MODE_MASK 0x00000006
#define ETH_MAC_V4_GEN_RX_RATE_CNT_MODE_SHIFT 1

/**** pcs_100g_addr register ****/
/*
 * MTIP 100G PCS Address. Byte addressed and 16-bit word aligned.
 * Reset: 0x0         Access: RW
 */
#define ETH_MAC_V4_MTIP_PCS_100G_ADDR_VAL_MASK 0x0001FFFF
#define ETH_MAC_V4_MTIP_PCS_100G_ADDR_VAL_SHIFT 0

/**** pcs_100g_data register ****/
/*
 * MTIP 100G PCS Data (16 bits)
 * Reset: 0x0         Access: RW
 */
#define ETH_MAC_V4_MTIP_PCS_100G_DATA_VAL_MASK 0x0000FFFF
#define ETH_MAC_V4_MTIP_PCS_100G_DATA_VAL_SHIFT 0

/**** mac_100g_addr register ****/
/*
 * MTIP 100G MAC Address. Byte addressed and 32-bit word aligned.
 * Reset: 0x0         Access: RW
 */
#define ETH_MAC_V4_MTIP_MAC_100G_ADDR_VAL_MASK 0x000003FF
#define ETH_MAC_V4_MTIP_MAC_100G_ADDR_VAL_SHIFT 0

/**** pcs_50g_addr register ****/
/*
 * MTIP 50G PCS Address. Byte addressed and 16-bit word aligned.
 * Reset: 0x0         Access: RW
 */
#define ETH_MAC_V4_MTIP_PCS_50G_ADDR_VAL_MASK 0x0001FFFF
#define ETH_MAC_V4_MTIP_PCS_50G_ADDR_VAL_SHIFT 0

/**** pcs_50g_data register ****/
/*
 * MTIP 50G PCS Data (16 bits)
 * Reset: 0x0         Access: RW
 */
#define ETH_MAC_V4_MTIP_PCS_50G_DATA_VAL_MASK 0x0000FFFF
#define ETH_MAC_V4_MTIP_PCS_50G_DATA_VAL_SHIFT 0

/**** mac_50g_addr register ****/
/*
 * MTIP 50G MAC Address. Byte addressed and 32-bit word aligned.
 * Reset: 0x0         Access: RW
 */
#define ETH_MAC_V4_MTIP_MAC_50G_ADDR_VAL_MASK 0x000003FF
#define ETH_MAC_V4_MTIP_MAC_50G_ADDR_VAL_SHIFT 0

/**** an_lt_0_addr register ****/
/*
 * Address value
 * Reset: 0x0         Access: RW
 */
#define ETH_MAC_V4_MTIP_AN_LT_0_ADDR_VAL_MASK 0x0000FFFF
#define ETH_MAC_V4_MTIP_AN_LT_0_ADDR_VAL_SHIFT 0

/**** an_lt_1_addr register ****/
/*
 * Address value
 * Reset: 0x0         Access: RW
 */
#define ETH_MAC_V4_MTIP_AN_LT_1_ADDR_VAL_MASK 0x0000FFFF
#define ETH_MAC_V4_MTIP_AN_LT_1_ADDR_VAL_SHIFT 0

/**** an_lt_2_addr register ****/
/*
 * Address value
 * Reset: 0x0         Access: RW
 */
#define ETH_MAC_V4_MTIP_AN_LT_2_ADDR_VAL_MASK 0x0000FFFF
#define ETH_MAC_V4_MTIP_AN_LT_2_ADDR_VAL_SHIFT 0

/**** an_lt_3_addr register ****/
/*
 * Address value
 * Reset: 0x0         Access: RW
 */
#define ETH_MAC_V4_MTIP_AN_LT_3_ADDR_VAL_MASK 0x0000FFFF
#define ETH_MAC_V4_MTIP_AN_LT_3_ADDR_VAL_SHIFT 0

/**** afifo_ctrl register ****/
/*
 * enable tx input operation
 * Reset: 0x0         Access: RW
 */
#define ETH_MAC_V4_GEN_V4_AFIFO_CTRL_EN_TX_IN (1 << 0)
/*
 * enable tx output operation
 * Reset: 0x0         Access: RW
 */
#define ETH_MAC_V4_GEN_V4_AFIFO_CTRL_EN_TX_OUT (1 << 1)
/*
 * enable rx input operation
 * Reset: 0x0         Access: RW
 */
#define ETH_MAC_V4_GEN_V4_AFIFO_CTRL_EN_RX_IN (1 << 4)
/*
 * enable rx output operation
 * Reset: 0x0         Access: RW
 */
#define ETH_MAC_V4_GEN_V4_AFIFO_CTRL_EN_RX_OUT (1 << 5)
/*
 * enable tx FIFO input operation
 * Reset: 0x0         Access: RW
 */
#define ETH_MAC_V4_GEN_V4_AFIFO_CTRL_EN_TX_FIFO_IN (1 << 8)
/*
 * enable tx FIFO output operation
 * Reset: 0x0         Access: RW
 */
#define ETH_MAC_V4_GEN_V4_AFIFO_CTRL_EN_TX_FIFO_OUT (1 << 9)
/*
 * enable rx FIFO input operation
 * Reset: 0x0         Access: RW
 */
#define ETH_MAC_V4_GEN_V4_AFIFO_CTRL_EN_RX_FIFO_IN (1 << 12)
/*
 * enable rx FIFO output operation
 * Reset: 0x0         Access: RW
 */
#define ETH_MAC_V4_GEN_V4_AFIFO_CTRL_EN_RX_FIFO_OUT (1 << 13)
/*
 * 1 = Enable AFIFO ff_tx_err assertion, 0 = Disable.
 * Reset: 0x0         Access: RW
 */
#define ETH_MAC_V4_GEN_V4_AFIFO_CTRL_EN_TX_FIFO_ERR (1 << 16)

/**** tx_afifo_cfg_1 register ****/
/*
 * minimum packet size configuration
 * Reset: 0x40        Access: RW
 */
#define ETH_MAC_V4_GEN_V4_TX_AFIFO_CFG_1_MIN_PKT_SIZE_MASK 0x0000FFFF
#define ETH_MAC_V4_GEN_V4_TX_AFIFO_CFG_1_MIN_PKT_SIZE_SHIFT 0

/**** tx_afifo_cfg_2 register ****/
/*
 * maximum packet size configuration
 * Reset: 0x2710      Access: RW
 */
#define ETH_MAC_V4_GEN_V4_TX_AFIFO_CFG_2_MAX_PKT_SIZE_MASK 0x0000FFFF
#define ETH_MAC_V4_GEN_V4_TX_AFIFO_CFG_2_MAX_PKT_SIZE_SHIFT 0

/**** tx_afifo_cfg_3 register ****/
/*
 * input bus width
 * Reset: 0x80        Access: RW
 */
#define ETH_MAC_V4_GEN_V4_TX_AFIFO_CFG_3_INPUT_BUS_W_MASK 0x0000FFFF
#define ETH_MAC_V4_GEN_V4_TX_AFIFO_CFG_3_INPUT_BUS_W_SHIFT 0
/*
 * input bus width divide factor
 * Reset: 0x2         Access: RW
 */
#define ETH_MAC_V4_GEN_V4_TX_AFIFO_CFG_3_INPUT_BUS_W_F_MASK 0xFFFF0000
#define ETH_MAC_V4_GEN_V4_TX_AFIFO_CFG_3_INPUT_BUS_W_F_SHIFT 16

/**** tx_afifo_cfg_4 register ****/
/*
 * output bus width
 * Reset: 0x100       Access: RW
 */
#define ETH_MAC_V4_GEN_V4_TX_AFIFO_CFG_4_OUTPUT_BUS_W_MASK 0x0000FFFF
#define ETH_MAC_V4_GEN_V4_TX_AFIFO_CFG_4_OUTPUT_BUS_W_SHIFT 0
/*
 * output bus width divide factor
 * Reset: 0x1         Access: RW
 */
#define ETH_MAC_V4_GEN_V4_TX_AFIFO_CFG_4_OUTPUT_BUS_W_F_MASK 0xFFFF0000
#define ETH_MAC_V4_GEN_V4_TX_AFIFO_CFG_4_OUTPUT_BUS_W_F_SHIFT 16

/**** tx_afifo_cfg_5 register ****/
/*
 * Not used in eth_mps_v4 (TX input hard-wired to valid/ready)
 * Reset: 0x1         Access: RW
 */
#define ETH_MAC_V4_GEN_V4_TX_AFIFO_CFG_5_INPUT_BUS_VALID_RDY (1 << 0)
/*
 * determines if the output bus is valid/read or "write enable".
 * 0 - write enable
 * 1 - valid/ready
 * Reset: 0x1         Access: RW
 */
#define ETH_MAC_V4_GEN_V4_TX_AFIFO_CFG_5_OUTPUT_BUS_VALID_RDY (1 << 1)
/*
 * Swap input bus bytes
 * Reset: 0x0         Access: RW
 */
#define ETH_MAC_V4_GEN_V4_TX_AFIFO_CFG_5_INPUT_BUS_SWAP_BYTES (1 << 4)
/*
 * Swap output bus bytes
 * Reset: 0x1         Access: RW
 */
#define ETH_MAC_V4_GEN_V4_TX_AFIFO_CFG_5_OUTPUT_BUS_SWAP_BYTES (1 << 5)
/*
 * relevant only when reg_gen_input_bus_valid_ready_out=0 (write-enable-mode)  number of writes that
 * will be accepetd when almost full (not including eop)
 * Reset: 0x0         Access: RW
 */
#define ETH_MAC_V4_GEN_V4_TX_AFIFO_CFG_5_INPUT_BUS_AFULL_ABSORB_VAL_MASK 0x00000F00
#define ETH_MAC_V4_GEN_V4_TX_AFIFO_CFG_5_INPUT_BUS_AFULL_ABSORB_VAL_SHIFT 8
/*
 * relevant only when reg_gen_input_bus_valid_ready_out=0 (write-enable-mode)  0: normal, 1: drop
 * writes if fifo is not ready exept for eop write
 * Reset: 0x1         Access: RW
 */
#define ETH_MAC_V4_GEN_V4_TX_AFIFO_CFG_5_INPUT_BUS_EOP_READY (1 << 12)
/*
 * 0 - zero padding disabled
 * 1 - zero padding enabled, data bus will be padded with zero according to byte cnt
 * Reset: 0x1         Access: RW
 */
#define ETH_MAC_V4_GEN_V4_TX_AFIFO_CFG_5_INPUT_BUS_ZERO_PAD_EN (1 << 13)
/*
 * 1 = disable Redmine xxxx fix, 0 = enable fix.
 * Reset: 0x0         Access: RW
 */
#define ETH_MAC_V4_GEN_V4_TX_AFIFO_CFG_5_RMXXXX_CHICKEN (1 << 16)
/*
 * 1 = disable Redmine 5483 fix, 0 = enable fix.
 * Reset: 0x0         Access: RW
 */
#define ETH_MAC_V4_GEN_V4_TX_AFIFO_CFG_5_RM5483_CHICKEN (1 << 17)
/*
 * Data FIFO store and forward threshold (relevant only when data_fifo_saf_en = 1)
 * Reset: 0x8         Access: RW
 */
#define ETH_MAC_V4_GEN_V4_TX_AFIFO_CFG_5_DATA_FIFO_SAF_THRESHOLD_MASK 0x3F000000
#define ETH_MAC_V4_GEN_V4_TX_AFIFO_CFG_5_DATA_FIFO_SAF_THRESHOLD_SHIFT 24
/*
 * Data FIFO store and forward enable
 * Reset: 0x1         Access: RW
 */
#define ETH_MAC_V4_GEN_V4_TX_AFIFO_CFG_5_DATA_FIFO_SAF_EN (1 << 31)

/**** rx_afifo_cfg_1 register ****/
/*
 * minimum packet size configuration
 * Reset: 0x40        Access: RW
 */
#define ETH_MAC_V4_GEN_V4_RX_AFIFO_CFG_1_MIN_PKT_SIZE_MASK 0x0000FFFF
#define ETH_MAC_V4_GEN_V4_RX_AFIFO_CFG_1_MIN_PKT_SIZE_SHIFT 0

/**** rx_afifo_cfg_2 register ****/
/*
 * maximum packet size configuration
 * Reset: 0x2710      Access: RW
 */
#define ETH_MAC_V4_GEN_V4_RX_AFIFO_CFG_2_MAX_PKT_SIZE_MASK 0x0000FFFF
#define ETH_MAC_V4_GEN_V4_RX_AFIFO_CFG_2_MAX_PKT_SIZE_SHIFT 0

/**** rx_afifo_cfg_3 register ****/
/*
 * input bus width
 * Reset: 0x80        Access: RW
 */
#define ETH_MAC_V4_GEN_V4_RX_AFIFO_CFG_3_INPUT_BUS_W_MASK 0x0000FFFF
#define ETH_MAC_V4_GEN_V4_RX_AFIFO_CFG_3_INPUT_BUS_W_SHIFT 0
/*
 * input bus width divide factor
 * Reset: 0x2         Access: RW
 */
#define ETH_MAC_V4_GEN_V4_RX_AFIFO_CFG_3_INPUT_BUS_W_F_MASK 0xFFFF0000
#define ETH_MAC_V4_GEN_V4_RX_AFIFO_CFG_3_INPUT_BUS_W_F_SHIFT 16

/**** rx_afifo_cfg_4 register ****/
/*
 * output bus width
 * Reset: 0x100       Access: RW
 */
#define ETH_MAC_V4_GEN_V4_RX_AFIFO_CFG_4_OUTPUT_BUS_W_MASK 0x0000FFFF
#define ETH_MAC_V4_GEN_V4_RX_AFIFO_CFG_4_OUTPUT_BUS_W_SHIFT 0
/*
 * output bus width divide factor
 * Reset: 0x8         Access: RW
 */
#define ETH_MAC_V4_GEN_V4_RX_AFIFO_CFG_4_OUTPUT_BUS_W_F_MASK 0xFFFF0000
#define ETH_MAC_V4_GEN_V4_RX_AFIFO_CFG_4_OUTPUT_BUS_W_F_SHIFT 16

/**** rx_afifo_cfg_5 register ****/
/*
 * determines if the input bus is valid/read or "write enable".
 * 0 - write enable
 * 1 - valid/ready
 * Reset: 0x1         Access: RW
 */
#define ETH_MAC_V4_GEN_V4_RX_AFIFO_CFG_5_INPUT_BUS_VALID_RDY (1 << 0)
/*
 * Not used in eth_mps_v4 (RX output hard-wired to valid/ready)
 * Reset: 0x1         Access: RW
 */
#define ETH_MAC_V4_GEN_V4_RX_AFIFO_CFG_5_OUTPUT_BUS_VALID_RDY (1 << 1)
/*
 * Swap input bus bytes
 * Reset: 0x1         Access: RW
 */
#define ETH_MAC_V4_GEN_V4_RX_AFIFO_CFG_5_INPUT_BUS_SWAP_BYTES (1 << 4)
/*
 * Swap output bus bytes
 * Reset: 0x1         Access: RW
 */
#define ETH_MAC_V4_GEN_V4_RX_AFIFO_CFG_5_OUTPUT_BUS_SWAP_BYTES (1 << 5)
/*
 * relevant only when reg_gen_input_bus_valid_ready_out=0 (write-enable-mode)  number of writes that
 * will be accepetd when almost full (not including eop)
 * Reset: 0x0         Access: RW
 */
#define ETH_MAC_V4_GEN_V4_RX_AFIFO_CFG_5_INPUT_BUS_AFULL_ABSORB_VAL_MASK 0x00000F00
#define ETH_MAC_V4_GEN_V4_RX_AFIFO_CFG_5_INPUT_BUS_AFULL_ABSORB_VAL_SHIFT 8
/*
 * relevant only when reg_gen_input_bus_valid_ready_out=0 (write-enable-mode)  0: normal, 1: drop
 * writes if fifo is not ready exept for eop write
 * Reset: 0x1         Access: RW
 */
#define ETH_MAC_V4_GEN_V4_RX_AFIFO_CFG_5_INPUT_BUS_EOP_READY (1 << 12)
/*
 * 0 - zero padding disabled
 * 1 - zero padding enabled, data bus will be padded with zero according to byte cnt
 * Reset: 0x1         Access: RW
 */
#define ETH_MAC_V4_GEN_V4_RX_AFIFO_CFG_5_INPUT_BUS_ZERO_PAD_EN (1 << 13)
/*
 * 1 = disable Redmine xxxx fix, 0 = enable fix.
 * Reset: 0x0         Access: RW
 */
#define ETH_MAC_V4_GEN_V4_RX_AFIFO_CFG_5_RMXXXX_CHICKEN (1 << 16)
/*
 * 1 = disable Redmine 5483 fix, 0 = enable fix.
 * Reset: 0x0         Access: RW
 */
#define ETH_MAC_V4_GEN_V4_RX_AFIFO_CFG_5_RM5483_CHICKEN (1 << 17)
/*
 * Data FIFO store and forward threshold (relevant only when data_fifo_saf_en = 1)
 * Reset: 0x0         Access: RW
 */
#define ETH_MAC_V4_GEN_V4_RX_AFIFO_CFG_5_DATA_FIFO_SAF_THRESHOLD_MASK 0x3F000000
#define ETH_MAC_V4_GEN_V4_RX_AFIFO_CFG_5_DATA_FIFO_SAF_THRESHOLD_SHIFT 24
/*
 * Data FIFO store and forward enable
 * Reset: 0x0         Access: RW
 */
#define ETH_MAC_V4_GEN_V4_RX_AFIFO_CFG_5_DATA_FIFO_SAF_EN (1 << 31)

/**** mac register ****/
/*
 * Enable the 50G MAC in this channel.
 * Reset: 0x0         Access: RW
 */
#define ETH_MAC_V4_GEN_V4_MAC_EN_50G     (1 << 0)
/*
 * Enable the 100G MAC in this channel. 100G MAC takes priority over the 50G MAC (if both are in the
 * same channel). Only relevant for CH0.
 * Reset: 0x0         Access: RW
 */
#define ETH_MAC_V4_GEN_V4_MAC_EN_100G    (1 << 4)

/**** pcs_eee_pin_cfg register ****/
/*
 * Timer value for LPI tick (units are 1.167ns). 0 means de-activate timer.
 * Reset: 0x0         Access: RW
 */
#define ETH_MAC_V4_GEN_V4_PCS_EEE_PIN_CFG_LPI_TIMER_VAL_MASK 0x000000FF
#define ETH_MAC_V4_GEN_V4_PCS_EEE_PIN_CFG_LPI_TIMER_VAL_SHIFT 0

/**** pcs_eee_pin_status register ****/
/*
 * TX LPI mode
 * Reset: 0x0         Access: RO
 */
#define ETH_MAC_V4_GEN_V4_PCS_EEE_PIN_STATUS_TX_LPI_MODE_MASK 0x00000003
#define ETH_MAC_V4_GEN_V4_PCS_EEE_PIN_STATUS_TX_LPI_MODE_SHIFT 0
/*
 * TX LPI state
 * Reset: 0x0         Access: RO
 */
#define ETH_MAC_V4_GEN_V4_PCS_EEE_PIN_STATUS_TX_LPI_STATE_MASK 0x00000070
#define ETH_MAC_V4_GEN_V4_PCS_EEE_PIN_STATUS_TX_LPI_STATE_SHIFT 4
/*
 * TX LPI mode
 * Reset: 0x0         Access: RO
 */
#define ETH_MAC_V4_GEN_V4_PCS_EEE_PIN_STATUS_RX_LPI_MODE (1 << 8)
/*
 * TX LPI state
 * Reset: 0x0         Access: RO
 */
#define ETH_MAC_V4_GEN_V4_PCS_EEE_PIN_STATUS_RX_LPI_STATE_MASK 0x00007000
#define ETH_MAC_V4_GEN_V4_PCS_EEE_PIN_STATUS_RX_LPI_STATE_SHIFT 12
/*
 * TX LPI active
 * Reset: 0x0         Access: RO
 */
#define ETH_MAC_V4_GEN_V4_PCS_EEE_PIN_STATUS_RX_LPI_ACTIVE (1 << 15)

/**** pcs_50g_pin_status register ****/
/*
 * 1 = Link is established and operating normally.
 * Reset: 0x0         Access: RO
 */
#define ETH_MAC_V4_GEN_V4_PCS_50G_PIN_STATUS_XL_LINK_STATUS (1 << 0)
/*
 * 1 = Link indicates high number of invalid sync headers seen.
 * Reset: 0x0         Access: RO
 */
#define ETH_MAC_V4_GEN_V4_PCS_50G_PIN_STATUS_XL_HI_BER (1 << 1)
/*
 * 1 = RX LPI Active, 0 = RX LPI Inactive.
 * Reset: 0x0         Access: RO
 */
#define ETH_MAC_V4_GEN_V4_PCS_50G_PIN_STATUS_RX_LPI_ACTIVE (1 << 4)

/**** mac_100g_pin_cfg register ****/
/*
 * change TX CRC polarity
 * Reset: 0x0         Access: RW
 */
#define ETH_MAC_V4_GEN_V4_MAC_100G_PIN_CFG_SWAP_FF_TX_CRC (1 << 0)
/*
 * force TX local fault
 * Reset: 0x0         Access: RW
 */
#define ETH_MAC_V4_GEN_V4_MAC_100G_PIN_CFG_TX_REM_FAULT (1 << 4)
/*
 * force TX remote fault
 * Reset: 0x0         Access: RW
 */
#define ETH_MAC_V4_GEN_V4_MAC_100G_PIN_CFG_TX_LOC_FAULT (1 << 5)
/*
 * PHY LOS indication selection
 * 00 - Select register value from phy_los_def
 * 01 - Select input from the SerDes
 * 10 - Select input from GPIO
 * 11 - Select inverted input from GPIO
 * Reset: 0x0         Access: RW
 */
#define ETH_MAC_V4_GEN_V4_MAC_100G_PIN_CFG_PHY_LOS_SEL_MASK 0x00000300
#define ETH_MAC_V4_GEN_V4_MAC_100G_PIN_CFG_PHY_LOS_SEL_SHIFT 8
/*
 * PHY LOS default value
 * Reset: 0x0         Access: RW
 */
#define ETH_MAC_V4_GEN_V4_MAC_100G_PIN_CFG_PHY_LOS_DEF (1 << 10)
/*
 * PHY LOS polarity
 * Reset: 0x0         Access: RW
 */
#define ETH_MAC_V4_GEN_V4_MAC_100G_PIN_CFG_PHY_LOS_POL (1 << 11)
/*
 * 1 = RS layer should prevent MAC from transmitting LPI sequences.
 * Reset: 0x0         Access: RW
 */
#define ETH_MAC_V4_GEN_V4_MAC_100G_PIN_CFG_LPI_TXHOLD (1 << 16)
/*
 * 1 = RS layer should transmit LPI sequences.
 * Reset: 0x0         Access: RW
 */
#define ETH_MAC_V4_GEN_V4_MAC_100G_PIN_CFG_LPI_REQ (1 << 17)

/**** mac_100g_pin_status register ****/
/*
 * Onehot PFC pause for MAC channels.
 * Reset: 0x0         Access: RO
 */
#define ETH_MAC_V4_GEN_V4_MAC_100G_PIN_STATUS_FF_RX_PFC_XOFF_MASK 0x000000FF
#define ETH_MAC_V4_GEN_V4_MAC_100G_PIN_STATUS_FF_RX_PFC_XOFF_SHIFT 0
/*
 * local fault indication received
 * Reset: 0x0         Access: RO
 */
#define ETH_MAC_V4_GEN_V4_MAC_100G_PIN_STATUS_LOC_FAULT (1 << 8)
/*
 * remote fault indication received
 * Reset: 0x0         Access: RO
 */
#define ETH_MAC_V4_GEN_V4_MAC_100G_PIN_STATUS_REM_FAULT (1 << 9)
/*
 * PHY TX enabled
 * Reset: 0x0         Access: RO
 */
#define ETH_MAC_V4_GEN_V4_MAC_100G_PIN_STATUS_PHY_TXENA (1 << 12)
/*
 * Loopback enabled
 * Reset: 0x0         Access: RO
 */
#define ETH_MAC_V4_GEN_V4_MAC_100G_PIN_STATUS_LOOP_ENA (1 << 13)
/*
 * RS Layer LPI receive indication
 * Reset: 0x0         Access: RO
 */
#define ETH_MAC_V4_GEN_V4_MAC_100G_PIN_STATUS_LPI_IND (1 << 16)
/*
 * Transmit flow control acknowledge status
 * Reset: 0x0         Access: RO
 */
#define ETH_MAC_V4_GEN_V4_MAC_100G_PIN_STATUS_FF_TX_PFC_ACK (1 << 17)

/**** mac_50g_pin_cfg register ****/
/*
 * change TX CRC polarity
 * Reset: 0x0         Access: RW
 */
#define ETH_MAC_V4_GEN_V4_MAC_50G_PIN_CFG_SWAP_FF_TX_CRC (1 << 0)
/*
 * force TX local fault
 * Reset: 0x0         Access: RW
 */
#define ETH_MAC_V4_GEN_V4_MAC_50G_PIN_CFG_TX_REM_FAULT (1 << 4)
/*
 * force TX remote fault
 * Reset: 0x0         Access: RW
 */
#define ETH_MAC_V4_GEN_V4_MAC_50G_PIN_CFG_TX_LOC_FAULT (1 << 5)
/*
 * force TX Link fault
 * Reset: 0x0         Access: RW
 */
#define ETH_MAC_V4_GEN_V4_MAC_50G_PIN_CFG_TX_LI_FAULT (1 << 6)
/*
 * PHY LOS indication selection
 * 00 - Select register value from phy_los_def
 * 01 - Select input from the SerDes
 * 10 - Select input from GPIO
 * 11 - Select inverted input from GPIO
 * Reset: 0x0         Access: RW
 */
#define ETH_MAC_V4_GEN_V4_MAC_50G_PIN_CFG_PHY_LOS_SEL_MASK 0x00000300
#define ETH_MAC_V4_GEN_V4_MAC_50G_PIN_CFG_PHY_LOS_SEL_SHIFT 8
/*
 * PHY LOS default value
 * Reset: 0x0         Access: RW
 */
#define ETH_MAC_V4_GEN_V4_MAC_50G_PIN_CFG_PHY_LOS_DEF (1 << 10)
/*
 * PHY LOS polarity
 * Reset: 0x0         Access: RW
 */
#define ETH_MAC_V4_GEN_V4_MAC_50G_PIN_CFG_PHY_LOS_POL (1 << 11)
/*
 * Force the MAC to stop TX transmission after low power mode.
 * Reset: 0x0         Access: RW
 */
#define ETH_MAC_V4_GEN_V4_MAC_50G_PIN_CFG_LPI_TXHOLD (1 << 16)
/*
 * Force MAC to send LPI signalling after current TX frame
 * Reset: 0x0         Access: RW
 */
#define ETH_MAC_V4_GEN_V4_MAC_50G_PIN_CFG_REG_LOWP_ENA (1 << 17)

/**** mac_50g_pin_status register ****/
/*
 * pause on indication
 * Reset: 0x0         Access: RO
 */
#define ETH_MAC_V4_GEN_V4_MAC_50G_PIN_STATUS_PAUSE_ON_MASK 0x000000FF
#define ETH_MAC_V4_GEN_V4_MAC_50G_PIN_STATUS_PAUSE_ON_SHIFT 0
/*
 * local fault indication received
 * Reset: 0x0         Access: RO
 */
#define ETH_MAC_V4_GEN_V4_MAC_50G_PIN_STATUS_LOC_FAULT (1 << 8)
/*
 * remote fault indication received
 * Reset: 0x0         Access: RO
 */
#define ETH_MAC_V4_GEN_V4_MAC_50G_PIN_STATUS_REM_FAULT (1 << 9)
/*
 * Link fault indication
 * Reset: 0x0         Access: RO
 */
#define ETH_MAC_V4_GEN_V4_MAC_50G_PIN_STATUS_LI_FAULT (1 << 10)
/*
 * PHY TX enabled
 * Reset: 0x0         Access: RO
 */
#define ETH_MAC_V4_GEN_V4_MAC_50G_PIN_STATUS_PHY_TXENA (1 << 12)
/*
 * Loopback enabled
 * Reset: 0x0         Access: RO
 */
#define ETH_MAC_V4_GEN_V4_MAC_50G_PIN_STATUS_LOOP_ENA (1 << 13)
/*
 * Transmit timestamp available. Same as Core STATUS register bit TS_AVAIL
 * Reset: 0x0         Access: RO
 */
#define ETH_MAC_V4_GEN_V4_MAC_50G_PIN_STATUS_REG_TS_AVAIL (1 << 14)
/*
 * Low-power condition detected by MAC.
 * Reset: 0x0         Access: RO
 */
#define ETH_MAC_V4_GEN_V4_MAC_50G_PIN_STATUS_REG_LOWP (1 << 15)
/*
 * 1 = PFC mode, 0 = PAUSE mode.
 * Reset: 0x0         Access: RO
 */
#define ETH_MAC_V4_GEN_V4_MAC_50G_PIN_STATUS_PFC_MODE (1 << 16)

/**** mac_100g_vlan01 register ****/
/*
 * VLAN0 programmable value
 * Reset: 0x8100      Access: RW
 */
#define ETH_MAC_V4_GEN_V4_MAC_100G_VLAN01_VLAN0_MASK 0x0000FFFF
#define ETH_MAC_V4_GEN_V4_MAC_100G_VLAN01_VLAN0_SHIFT 0
/*
 * VLAN1 programmable value
 * Reset: 0x8100      Access: RW
 */
#define ETH_MAC_V4_GEN_V4_MAC_100G_VLAN01_VLAN1_MASK 0xFFFF0000
#define ETH_MAC_V4_GEN_V4_MAC_100G_VLAN01_VLAN1_SHIFT 16

/**** mac_100g_vlan23 register ****/
/*
 * VLAN2 programmable value
 * Reset: 0x8100      Access: RW
 */
#define ETH_MAC_V4_GEN_V4_MAC_100G_VLAN23_VLAN2_MASK 0x0000FFFF
#define ETH_MAC_V4_GEN_V4_MAC_100G_VLAN23_VLAN2_SHIFT 0
/*
 * VLAN3 programmable value
 * Reset: 0x8100      Access: RW
 */
#define ETH_MAC_V4_GEN_V4_MAC_100G_VLAN23_VLAN3_MASK 0xFFFF0000
#define ETH_MAC_V4_GEN_V4_MAC_100G_VLAN23_VLAN3_SHIFT 16

/**** mac_100g_vlan45 register ****/
/*
 * VLAN4 programmable value
 * Reset: 0x8100      Access: RW
 */
#define ETH_MAC_V4_GEN_V4_MAC_100G_VLAN45_VLAN4_MASK 0x0000FFFF
#define ETH_MAC_V4_GEN_V4_MAC_100G_VLAN45_VLAN4_SHIFT 0
/*
 * VLAN5 programmable value
 * Reset: 0x8100      Access: RW
 */
#define ETH_MAC_V4_GEN_V4_MAC_100G_VLAN45_VLAN5_MASK 0xFFFF0000
#define ETH_MAC_V4_GEN_V4_MAC_100G_VLAN45_VLAN5_SHIFT 16

/**** mac_100g_vlan67 register ****/
/*
 * VLAN6 programmable value
 * Reset: 0x8100      Access: RW
 */
#define ETH_MAC_V4_GEN_V4_MAC_100G_VLAN67_VLAN6_MASK 0x0000FFFF
#define ETH_MAC_V4_GEN_V4_MAC_100G_VLAN67_VLAN6_SHIFT 0
/*
 * VLAN7 programmable value
 * Reset: 0x8100      Access: RW
 */
#define ETH_MAC_V4_GEN_V4_MAC_100G_VLAN67_VLAN7_MASK 0xFFFF0000
#define ETH_MAC_V4_GEN_V4_MAC_100G_VLAN67_VLAN7_SHIFT 16

/**** tx_preamble_cfg_high register ****/
/*
 * TX preamble value
 * Reset: 0xd55555    Access: RW
 */
#define ETH_MAC_V4_GEN_V4_TX_PREAMBLE_CFG_HIGH_VAL_MASK 0x00FFFFFF
#define ETH_MAC_V4_GEN_V4_TX_PREAMBLE_CFG_HIGH_VAL_SHIFT 0

/**** rx_preamble_status_high register ****/
/*
 * RX preamble value
 * Reset: 0x0         Access: RO
 */
#define ETH_MAC_V4_GEN_V4_RX_PREAMBLE_STATUS_HIGH_VAL_MASK 0x00FFFFFF
#define ETH_MAC_V4_GEN_V4_RX_PREAMBLE_STATUS_HIGH_VAL_SHIFT 0

/**** stat_cfg_mac_100g register ****/
/*
 * 0 = disabled, 1 = rising edges, 2 = falling edges, 3 = both edges
 * Reset: 0x1         Access: RW
 */
#define ETH_MAC_V4_GEN_V4_STAT_CFG_MAC_100G_TX_UNDERFLOW_MASK 0x00000003
#define ETH_MAC_V4_GEN_V4_STAT_CFG_MAC_100G_TX_UNDERFLOW_SHIFT 0
/*
 * 0 = disabled, 1 = rising edges, 2 = falling edges, 3 = both edges
 * Reset: 0x1         Access: RW
 */
#define ETH_MAC_V4_GEN_V4_STAT_CFG_MAC_100G_RX_OVERFLOW_MASK 0x00000030
#define ETH_MAC_V4_GEN_V4_STAT_CFG_MAC_100G_RX_OVERFLOW_SHIFT 4
/*
 * 0 = disabled, 1 = rising edges, 2 = falling edges, 3 = both edges
 * Reset: 0x1         Access: RW
 */
#define ETH_MAC_V4_GEN_V4_STAT_CFG_MAC_100G_REM_FAULT_MASK 0x00003000
#define ETH_MAC_V4_GEN_V4_STAT_CFG_MAC_100G_REM_FAULT_SHIFT 12
/*
 * 0 = disabled, 1 = rising edges, 2 = falling edges, 3 = both edges
 * Reset: 0x1         Access: RW
 */
#define ETH_MAC_V4_GEN_V4_STAT_CFG_MAC_100G_LOC_FAULT_MASK 0x00030000
#define ETH_MAC_V4_GEN_V4_STAT_CFG_MAC_100G_LOC_FAULT_SHIFT 16
/*
 * 0 = disabled, 1 = rising edges, 2 = falling edges, 3 = both edges
 * Reset: 0x1         Access: RW
 */
#define ETH_MAC_V4_GEN_V4_STAT_CFG_MAC_100G_LPI_IND_MASK 0x00300000
#define ETH_MAC_V4_GEN_V4_STAT_CFG_MAC_100G_LPI_IND_SHIFT 20
/*
 * 0 = disabled, 1 = rising edges, 2 = falling edges, 3 = both edges
 * Reset: 0x1         Access: RW
 */
#define ETH_MAC_V4_GEN_V4_STAT_CFG_MAC_100G_FF_TX_PFC_ACK_MASK 0x03000000
#define ETH_MAC_V4_GEN_V4_STAT_CFG_MAC_100G_FF_TX_PFC_ACK_SHIFT 24

/**** stat_cfg_mac_50g register ****/
/*
 * 0 = disabled, 1 = rising edges, 2 = falling edges, 3 = both edges
 * Reset: 0x1         Access: RW
 */
#define ETH_MAC_V4_GEN_V4_STAT_CFG_MAC_50G_TX_UNDERFLOW_MASK 0x00000003
#define ETH_MAC_V4_GEN_V4_STAT_CFG_MAC_50G_TX_UNDERFLOW_SHIFT 0
/*
 * 0 = disabled, 1 = rising edges, 2 = falling edges, 3 = both edges
 * Reset: 0x1         Access: RW
 */
#define ETH_MAC_V4_GEN_V4_STAT_CFG_MAC_50G_RX_OVERFLOW_MASK 0x00000030
#define ETH_MAC_V4_GEN_V4_STAT_CFG_MAC_50G_RX_OVERFLOW_SHIFT 4
/*
 * 0 = disabled, 1 = rising edges, 2 = falling edges, 3 = both edges
 * Reset: 0x1         Access: RW
 */
#define ETH_MAC_V4_GEN_V4_STAT_CFG_MAC_50G_LI_FAULT_MASK 0x00000300
#define ETH_MAC_V4_GEN_V4_STAT_CFG_MAC_50G_LI_FAULT_SHIFT 8
/*
 * 0 = disabled, 1 = rising edges, 2 = falling edges, 3 = both edges
 * Reset: 0x1         Access: RW
 */
#define ETH_MAC_V4_GEN_V4_STAT_CFG_MAC_50G_REM_FAULT_MASK 0x00003000
#define ETH_MAC_V4_GEN_V4_STAT_CFG_MAC_50G_REM_FAULT_SHIFT 12
/*
 * 0 = disabled, 1 = rising edges, 2 = falling edges, 3 = both edges
 * Reset: 0x1         Access: RW
 */
#define ETH_MAC_V4_GEN_V4_STAT_CFG_MAC_50G_LOC_FAULT_MASK 0x00030000
#define ETH_MAC_V4_GEN_V4_STAT_CFG_MAC_50G_LOC_FAULT_SHIFT 16
/*
 * 0 = disabled, 1 = rising edges, 2 = falling edges, 3 = both edges
 * Reset: 0x1         Access: RW
 */
#define ETH_MAC_V4_GEN_V4_STAT_CFG_MAC_50G_REG_LOWP_MASK 0x00300000
#define ETH_MAC_V4_GEN_V4_STAT_CFG_MAC_50G_REG_LOWP_SHIFT 20

/**** stat_cfg_eee register ****/
/*
 * 0 = disabled, 1 = rising edges, 2 = falling edges, 3 = both edges
 * Reset: 0x1         Access: RW
 */
#define ETH_MAC_V4_GEN_V4_STAT_CFG_EEE_EC_ACTIVE_MASK 0x00000003
#define ETH_MAC_V4_GEN_V4_STAT_CFG_EEE_EC_ACTIVE_SHIFT 0

/**** int_cfg_lmac register ****/
/*
 * 0 = disabled, 1 = rising edges, 2 = falling edges, 3 = both edges
 * Reset: 0x1         Access: RW
 */
#define ETH_MAC_V4_GEN_V4_INT_CFG_LMAC_FF_TX_ERR_MASK 0x00000003
#define ETH_MAC_V4_GEN_V4_INT_CFG_LMAC_FF_TX_ERR_SHIFT 0
/*
 * 0 = disabled, 1 = rising edges, 2 = falling edges, 3 = both edges
 * Reset: 0x1         Access: RW
 */
#define ETH_MAC_V4_GEN_V4_INT_CFG_LMAC_FF_RX_ERR_MASK 0x00000030
#define ETH_MAC_V4_GEN_V4_INT_CFG_LMAC_FF_RX_ERR_SHIFT 4
/*
 * 0 = disabled, 1 = rising edges, 2 = falling edges, 3 = both edges
 * Reset: 0x1         Access: RW
 */
#define ETH_MAC_V4_GEN_V4_INT_CFG_LMAC_TX_SFD_O_MASK 0x00000300
#define ETH_MAC_V4_GEN_V4_INT_CFG_LMAC_TX_SFD_O_SHIFT 8
/*
 * 0 = disabled, 1 = rising edges, 2 = falling edges, 3 = both edges
 * Reset: 0x1         Access: RW
 */
#define ETH_MAC_V4_GEN_V4_INT_CFG_LMAC_RX_SFD_O_MASK 0x00003000
#define ETH_MAC_V4_GEN_V4_INT_CFG_LMAC_RX_SFD_O_SHIFT 12
/*
 * 0 = disabled, 1 = rising edges, 2 = falling edges, 3 = both edges
 * Reset: 0x1         Access: RW
 */
#define ETH_MAC_V4_GEN_V4_INT_CFG_LMAC_TX_TS_VAL_MASK 0x00030000
#define ETH_MAC_V4_GEN_V4_INT_CFG_LMAC_TX_TS_VAL_SHIFT 16
/*
 * 0 = disabled, 1 = rising edges, 2 = falling edges, 3 = both edges
 * Reset: 0x1         Access: RW
 */
#define ETH_MAC_V4_GEN_V4_INT_CFG_LMAC_PAUSE_ON_MASK 0x00300000
#define ETH_MAC_V4_GEN_V4_INT_CFG_LMAC_PAUSE_ON_SHIFT 20
/*
 * 0 = disabled, 1 = rising edges, 2 = falling edges, 3 = both edges
 * Reset: 0x1         Access: RW
 */
#define ETH_MAC_V4_GEN_V4_INT_CFG_LMAC_STAT_PAR_ERR_MASK 0x03000000
#define ETH_MAC_V4_GEN_V4_INT_CFG_LMAC_STAT_PAR_ERR_SHIFT 24

/**** int_cfg_cmac register ****/
/*
 * 0 = disabled, 1 = rising edges, 2 = falling edges, 3 = both edges
 * Reset: 0x1         Access: RW
 */
#define ETH_MAC_V4_GEN_V4_INT_CFG_CMAC_FF_TX_ERR_MASK 0x00000003
#define ETH_MAC_V4_GEN_V4_INT_CFG_CMAC_FF_TX_ERR_SHIFT 0
/*
 * 0 = disabled, 1 = rising edges, 2 = falling edges, 3 = both edges
 * Reset: 0x1         Access: RW
 */
#define ETH_MAC_V4_GEN_V4_INT_CFG_CMAC_FF_RX_ERR_MASK 0x00000030
#define ETH_MAC_V4_GEN_V4_INT_CFG_CMAC_FF_RX_ERR_SHIFT 4
/*
 * 0 = disabled, 1 = rising edges, 2 = falling edges, 3 = both edges
 * Reset: 0x1         Access: RW
 */
#define ETH_MAC_V4_GEN_V4_INT_CFG_CMAC_TX_TS_VAL_MASK 0x00000300
#define ETH_MAC_V4_GEN_V4_INT_CFG_CMAC_TX_TS_VAL_SHIFT 8
/*
 * 0 = disabled, 1 = rising edges, 2 = falling edges, 3 = both edges
 * Reset: 0x1         Access: RW
 */
#define ETH_MAC_V4_GEN_V4_INT_CFG_CMAC_FF_RX_PFC_XOFF_MASK 0x00003000
#define ETH_MAC_V4_GEN_V4_INT_CFG_CMAC_FF_RX_PFC_XOFF_SHIFT 12
/*
 * 0 = disabled, 1 = rising edges, 2 = falling edges, 3 = both edges
 * Reset: 0x1         Access: RW
 */
#define ETH_MAC_V4_GEN_V4_INT_CFG_CMAC_FF_TX_SEPTY_MASK 0x00030000
#define ETH_MAC_V4_GEN_V4_INT_CFG_CMAC_FF_TX_SEPTY_SHIFT 16

/**** int_cfg register ****/
/*
 * 0 = disabled, 1 = rising edges, 2 = falling edges, 3 = both edges
 * Reset: 0x1         Access: RW
 */
#define ETH_MAC_V4_GEN_V4_INT_CFG_MAC_GPIO_INT_IN_MASK 0x00000003
#define ETH_MAC_V4_GEN_V4_INT_CFG_MAC_GPIO_INT_IN_SHIFT 0

/**** pcs_all_pin_status register ****/
/*
 * 4 bit per lane tx decoupling buffer level threshold (5..7 depending on refclk)
 * Reset: 0x0         Access: RO
 */
#define ETH_MAC_V4_GEN_V4_SR_PCS_ALL_PIN_STATUS_TX_LANE_THRESH0_MASK 0x0000000F
#define ETH_MAC_V4_GEN_V4_SR_PCS_ALL_PIN_STATUS_TX_LANE_THRESH0_SHIFT 0
/*
 * 4 bit per lane tx decoupling buffer level threshold (5..7 depending on refclk)
 * Reset: 0x0         Access: RO
 */
#define ETH_MAC_V4_GEN_V4_SR_PCS_ALL_PIN_STATUS_TX_LANE_THRESH1_MASK 0x000000F0
#define ETH_MAC_V4_GEN_V4_SR_PCS_ALL_PIN_STATUS_TX_LANE_THRESH1_SHIFT 4
/*
 * 4 bit per lane tx decoupling buffer level threshold (5..7 depending on refclk)
 * Reset: 0x0         Access: RO
 */
#define ETH_MAC_V4_GEN_V4_SR_PCS_ALL_PIN_STATUS_TX_LANE_THRESH2_MASK 0x00000F00
#define ETH_MAC_V4_GEN_V4_SR_PCS_ALL_PIN_STATUS_TX_LANE_THRESH2_SHIFT 8
/*
 * 4 bit per lane tx decoupling buffer level threshold (5..7 depending on refclk)
 * Reset: 0x0         Access: RO
 */
#define ETH_MAC_V4_GEN_V4_SR_PCS_ALL_PIN_STATUS_TX_LANE_THRESH3_MASK 0x0000F000
#define ETH_MAC_V4_GEN_V4_SR_PCS_ALL_PIN_STATUS_TX_LANE_THRESH3_SHIFT 12
/*
 * Channel 0 Number of Active Lanes
 * Reset: 0x0         Access: RO
 */
#define ETH_MAC_V4_GEN_V4_SR_PCS_ALL_PIN_STATUS_PCS0_LANE_ACTIVE_MASK 0x000F0000
#define ETH_MAC_V4_GEN_V4_SR_PCS_ALL_PIN_STATUS_PCS0_LANE_ACTIVE_SHIFT 16
/*
 * Channel 2 Number of Active Lanes
 * Reset: 0x0         Access: RO
 */
#define ETH_MAC_V4_GEN_V4_SR_PCS_ALL_PIN_STATUS_PCS2_LANE_ACTIVE_MASK 0x00300000
#define ETH_MAC_V4_GEN_V4_SR_PCS_ALL_PIN_STATUS_PCS2_LANE_ACTIVE_SHIFT 20

/**** pcs_100g_pin_status register ****/
/*
 * 100G MAC block lock synchronisation
 * Reset: 0x0         Access: RO
 */
#define ETH_MAC_V4_GEN_V4_SR_PCS_100G_PIN_STATUS_BLOCK_LOCK_MASK 0x000FFFFF
#define ETH_MAC_V4_GEN_V4_SR_PCS_100G_PIN_STATUS_BLOCK_LOCK_SHIFT 0
/*
 * 1 = Alignment markers of all virtual lanes locked onto.
 * Reset: 0x0         Access: RO
 */
#define ETH_MAC_V4_GEN_V4_SR_PCS_100G_PIN_STATUS_ALIGN_LOCK (1 << 20)
/*
 * High Bit Error Rate indication.
 * Reset: 0x0         Access: RO
 */
#define ETH_MAC_V4_GEN_V4_SR_PCS_100G_PIN_STATUS_HI_BER (1 << 24)
/*
 * Final link status for 100G PCS. Logical result of (align_lock & !hi_ber)
 * Reset: 0x0         Access: RO
 */
#define ETH_MAC_V4_GEN_V4_SR_PCS_100G_PIN_STATUS_LINK_STATUS (1 << 25)

/**** pcs_fec_pin_status register ****/
/*
 * RS-FEC Per-serdes codeword alignment
 * Reset: 0x0         Access: RO
 */
#define ETH_MAC_V4_GEN_V4_SR_PCS_FEC_PIN_STATUS_AMPS_LOCK_MASK 0x0000000F
#define ETH_MAC_V4_GEN_V4_SR_PCS_FEC_PIN_STATUS_AMPS_LOCK_SHIFT 0
/*
 * RS-FEC alignment status for each channel
 * Reset: 0x0         Access: RO
 */
#define ETH_MAC_V4_GEN_V4_SR_PCS_FEC_PIN_STATUS_RSFEC_ALIGNED_MASK 0x000000F0
#define ETH_MAC_V4_GEN_V4_SR_PCS_FEC_PIN_STATUS_RSFEC_ALIGNED_SHIFT 4
/*
 * Per FEC receive lock indication
 * Reset: 0x0         Access: RO
 */
#define ETH_MAC_V4_GEN_V4_SR_PCS_FEC_PIN_STATUS_FEC_LOCKED_MASK 0x0000FF00
#define ETH_MAC_V4_GEN_V4_SR_PCS_FEC_PIN_STATUS_FEC_LOCKED_SHIFT 8

#ifdef __cplusplus
}
#endif

#endif

/** @} */
