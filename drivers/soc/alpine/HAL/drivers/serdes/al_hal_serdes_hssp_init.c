/*******************************************************************************
Copyright (C) 2013 Annapurna Labs Ltd.

This file is licensed under the terms of the Annapurna Labs' Commercial License
Agreement distributed with the file or available on the software download site.
Recipient shall use the content of this file only on semiconductor devices or
systems developed by or for Annapurna Labs.

 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

*******************************************************************************/

#include "al_hal_serdes_hssp_init.h"
#include "al_hal_pbs_regs.h"
#include "al_hal_serdes_hssp_regs.h"
#include "al_hal_serdes_hssp_internal_regs.h"

#define SRDS_CORE_REG_ADDR(page, type, offset)\
	(((page) << 13) | ((type) << 12) | (offset))

/**
 * Nanoseconds delay
 */
static void al_serdes_ns_delay(
	int cnt);

/**
 * SERDES core reg write
 */
static void al_serdes_grp_reg_write(
	struct al_serdes_grp_obj	*grp_obj,
	enum al_serdes_reg_page		page,
	enum al_serdes_reg_type		type,
	uint16_t			offset,
	uint8_t				data);

/**
 * SERDES core masked reg write
 */
static void al_serdes_grp_reg_masked_write(
	struct al_serdes_grp_obj	*grp_obj,
	enum al_serdes_reg_page		page,
	enum al_serdes_reg_type		type,
	uint16_t			offset,
	uint8_t				mask,
	uint8_t				data);

/*
 * SERDES core extra configurations
 * These are auto generated by VSemi tool and therefore are in separate files
 */
#include "al_hal_serdes_hssp_xtra_cfg_kr_125.h"
#include "al_hal_serdes_hssp_xtra_cfg_kr_156.h"
#include "al_hal_serdes_hssp_xtra_cfg_sgmii_125.h"
#include "al_hal_serdes_hssp_xtra_cfg_sgmii_100.h"
#include "al_hal_serdes_hssp_xtra_cfg_sgmii_156.h"
#include "al_hal_serdes_hssp_xtra_cfg_sgmii_2_5g_100.h"
#include "al_hal_serdes_hssp_xtra_cfg_sgmii_2_5g_156.h"
#include "al_hal_serdes_hssp_xtra_cfg_pcie3.h"
#include "al_hal_serdes_hssp_xtra_cfg_sata_125.h"
#include "al_hal_serdes_hssp_xtra_cfg_sata_100.h"

/******************************************************************************/
/******************************************************************************/
int al_serdes_hssp_group_ictl_pma_val_set(
	struct al_serdes_grp_obj	*grp_obj,
	uint32_t			*ictl_pma_val,
	enum al_serdes_clk_src		clk_src_r2l,
	enum al_serdes_clk_src		clk_src_l2r,
	enum al_serdes_clk_src		clk_src_core)
{
	struct al_serdes_regs __iomem	*regs_base = grp_obj->regs_base;
	int status = 0;

	*ictl_pma_val = 0;

	switch (clk_src_core) {
	case AL_SRDS_CLK_SRC_REF_PINS:
		*ictl_pma_val |=
			SERDES_GEN_ICTL_PMA_REF_SEL_NT_REF;
		break;

	case AL_SRDS_CLK_SRC_L2R:
		*ictl_pma_val |=
			SERDES_GEN_ICTL_PMA_REF_SEL_NT_L2R;
		break;

	case AL_SRDS_CLK_SRC_R2L:
		*ictl_pma_val |=
			SERDES_GEN_ICTL_PMA_REF_SEL_NT_R2L;
		break;

	default:
		al_err(
			"%s: invalid core clock source: %d\n",
			__func__,
			clk_src_core);
		status = -EINVAL;
		goto done;
	}

	switch (clk_src_r2l) {
	case AL_SRDS_CLK_SRC_LOGIC_0:
		*ictl_pma_val |=
		SERDES_GEN_ICTL_PMA_REFBUSRIGHT2LEFT_MODE_NT_0;
		break;

	case AL_SRDS_CLK_SRC_REF_PINS:
		*ictl_pma_val |=
		SERDES_GEN_ICTL_PMA_REFBUSRIGHT2LEFT_MODE_NT_REF;
		break;

	case AL_SRDS_CLK_SRC_R2L:
		*ictl_pma_val |=
		SERDES_GEN_ICTL_PMA_REFBUSRIGHT2LEFT_MODE_NT_R2L;
		break;

	default:
		al_err(
			"%s: invalid R2L clock source: %d\n",
			__func__,
			clk_src_r2l);
		status = -EINVAL;
		goto done;
	}

	switch (clk_src_l2r) {
	case AL_SRDS_CLK_SRC_LOGIC_0:
		*ictl_pma_val |=
		SERDES_GEN_ICTL_PMA_REFBUSLEFT2RIGHT_MODE_NT_0;
		break;

	case AL_SRDS_CLK_SRC_REF_PINS:
		*ictl_pma_val |=
		SERDES_GEN_ICTL_PMA_REFBUSLEFT2RIGHT_MODE_NT_REF;
		break;

	case AL_SRDS_CLK_SRC_L2R:
		*ictl_pma_val |=
		SERDES_GEN_ICTL_PMA_REFBUSLEFT2RIGHT_MODE_NT_L2R;
		break;

	default:
		al_err(
			"%s: invalid L2R clock source: %d\n",
			__func__,
			clk_src_l2r);
		status = -EINVAL;
		goto done;
	}

	al_reg_write32(
		&regs_base->gen.ictl_pma ,
		*ictl_pma_val);

done:
	return status;
}

/******************************************************************************/
/******************************************************************************/
int al_serdes_hssp_group_ictl_pma_val_set_flp(
	struct al_serdes_grp_obj	*grp_obj,
	uint32_t			*ictl_pma_val,
	enum al_serdes_clk_src		clk_src_r2l,
	enum al_serdes_clk_src		clk_src_l2r,
	enum al_serdes_clk_src		clk_src_core)
{
	struct al_serdes_regs __iomem	*regs_base = grp_obj->regs_base;
	int status = 0;

	*ictl_pma_val = 0;

	switch (clk_src_core) {
	case AL_SRDS_CLK_SRC_REF_PINS:
		*ictl_pma_val |=
			SERDES_GEN_ICTL_PMA_REF_SEL_NT_REF;
		break;

	case AL_SRDS_CLK_SRC_L2R:
		*ictl_pma_val |=
			SERDES_GEN_ICTL_PMA_REF_SEL_NT_R2L;
		break;

	case AL_SRDS_CLK_SRC_R2L:
	case AL_SRDS_CLK_SRC_R2L_PLL:
		*ictl_pma_val |=
			SERDES_GEN_ICTL_PMA_REF_SEL_NT_L2R;
		break;

	default:
		al_err(
			"%s: invalid core clock source: %d\n",
			__func__,
			clk_src_core);
		status = -EINVAL;
		goto done;
	}

	switch (clk_src_l2r) {
	case AL_SRDS_CLK_SRC_LOGIC_0:
		*ictl_pma_val |=
		SERDES_GEN_ICTL_PMA_REFBUSRIGHT2LEFT_MODE_NT_0;
		break;

	case AL_SRDS_CLK_SRC_REF_PINS:
		*ictl_pma_val |=
		SERDES_GEN_ICTL_PMA_REFBUSRIGHT2LEFT_MODE_NT_REF;
		break;

	case AL_SRDS_CLK_SRC_L2R:
		*ictl_pma_val |=
		SERDES_GEN_ICTL_PMA_REFBUSRIGHT2LEFT_MODE_NT_R2L;
		break;

	default:
		al_err(
			"%s: invalid R2L clock source: %d\n",
			__func__,
			clk_src_l2r);
		status = -EINVAL;
		goto done;
	}

	switch (clk_src_r2l) {
	case AL_SRDS_CLK_SRC_LOGIC_0:
		*ictl_pma_val |=
		SERDES_GEN_ICTL_PMA_REFBUSLEFT2RIGHT_MODE_NT_0;
		break;

	case AL_SRDS_CLK_SRC_REF_PINS:
		*ictl_pma_val |=
		SERDES_GEN_ICTL_PMA_REFBUSLEFT2RIGHT_MODE_NT_REF;
		break;

	case AL_SRDS_CLK_SRC_R2L:
	case AL_SRDS_CLK_SRC_R2L_PLL:
		*ictl_pma_val |=
		SERDES_GEN_ICTL_PMA_REFBUSLEFT2RIGHT_MODE_NT_L2R;
		break;

	default:
		al_err(
			"%s: invalid L2R clock source: %d\n",
			__func__,
			clk_src_r2l);
		status = -EINVAL;
		goto done;
	}

	al_reg_write32(
		&regs_base->gen.ictl_pma ,
		*ictl_pma_val);

done:
	return status;
}



/******************************************************************************/
/******************************************************************************/
static void al_serdes_ns_delay(int cnt)
{
	al_udelay((cnt + 999) / 1000);
}

/******************************************************************************/
/******************************************************************************/
static void al_serdes_grp_reg_write(
	struct al_serdes_grp_obj	*grp_obj,
	enum al_serdes_reg_page		page,
	enum al_serdes_reg_type		type,
	uint16_t			offset,
	uint8_t				data)
{
	struct al_serdes_regs __iomem	*regs_base = grp_obj->regs_base;

	al_reg_write32(
		&regs_base->gen.reg_addr,
		SRDS_CORE_REG_ADDR(page, type, offset));

	al_reg_write32(&regs_base->gen.reg_data, data);
}


/******************************************************************************/
/******************************************************************************/
static void al_serdes_grp_reg_masked_write(
	struct al_serdes_grp_obj	*grp_obj,
	enum al_serdes_reg_page		page,
	enum al_serdes_reg_type		type,
	uint16_t			offset,
	uint8_t				mask,
	uint8_t				data)
{
	struct al_serdes_regs __iomem	*regs_base = grp_obj->regs_base;
	uint8_t val;

	al_reg_write32(
		&regs_base->gen.reg_addr,
		SRDS_CORE_REG_ADDR(page, type, offset));

	val = al_reg_read32(&regs_base->gen.reg_data);
	val &= ~mask;
	val |= data;
	al_reg_write32(&regs_base->gen.reg_data, val);
}

/******************************************************************************/
/******************************************************************************/
void al_serdes_hssp_group_lanes_tx_rx_pol_inv(
	struct al_serdes_grp_obj	*grp_obj,
	al_bool				*inv_tx_lanes,
	al_bool				*inv_rx_lanes)
{
	int i;

	for (i = 0; i < AL_SRDS_NUM_LANES; i++) {
		if (inv_tx_lanes[i] == AL_TRUE)
			al_serdes_grp_reg_masked_write(
				grp_obj,
				i,
				AL_SRDS_REG_TYPE_PMA,
				SERDES_IREG_FLD_POLARITY_TX_REG_NUM,
				SERDES_IREG_FLD_POLARITY_TX_INV,
				SERDES_IREG_FLD_POLARITY_TX_INV);
		if (inv_rx_lanes[i] == AL_TRUE)
			al_serdes_grp_reg_masked_write(
				grp_obj,
				i,
				AL_SRDS_REG_TYPE_PMA,
				SERDES_IREG_FLD_POLARITY_RX_REG_NUM,
				SERDES_IREG_FLD_POLARITY_RX_INV,
				SERDES_IREG_FLD_POLARITY_RX_INV);
	}
}

void al_serdes_hssp_basic_power_up(
	struct al_serdes_grp_obj	*grp_obj,
	al_bool				r2l_pll)
{
	struct al_serdes_regs __iomem	*regs_base = grp_obj->regs_base;

	/* Enable SRDS to pass reference clock before it is configured */
	al_reg_write32(&regs_base->gen.ipd_multi_synth , 0x0001);
	/* SerDes Reset */
	al_reg_write32(&regs_base->gen.irst, 0x1000);
	/*
	 * Take R2L from right group or from PLL
	 * (relevant for group C and has no effect on other groups)
	 */
	al_reg_write32(&regs_base->gen.clk_out, r2l_pll ? 0 : AL_BIT(5));
}


/******************************************************************************/
/******************************************************************************/
int al_serdes_hssp_group_non_active_lanes_pd(
	struct al_serdes_grp_obj	*grp_obj,
	al_bool				*active_lanes)
{
	struct al_serdes_regs __iomem	*regs_base = grp_obj->regs_base;
	int i;

	/* Power Down per lane */
	for (i = 0; i < AL_SRDS_NUM_LANES; i++) {
		if (active_lanes[i] == AL_FALSE) {
			al_reg_write32(
				&regs_base->lane[i].ipd_multi,
				0);
			al_reg_write32_masked(
				&regs_base->gen.irst,
				(SERDES_GEN_IRST_PIPE_RST_L0_B_A_SEL >> i) |
				(SERDES_GEN_IRST_PIPE_RST_L0_B_A >> i),
				0);
		}
	}

	return 0;
}

/******************************************************************************/
/******************************************************************************/
int al_serdes_hssp_group_cfg_off(
	struct al_serdes_grp_obj	*grp_obj)
{
	struct al_serdes_regs __iomem	*regs_base = grp_obj->regs_base;
	int i;

	/* Set SerDes in multi mode */
	al_reg_write32(&regs_base->gen.ictl_pcs , 0);

	/* Individual Synthesizer (PD) power-down control */
	al_reg_write32(&regs_base->gen.ipd_multi_synth, 0);

	/* SerDes Reset */
	al_reg_write32(&regs_base->gen.irst, 0);

	/* Power Down per lane */
	for (i = 0; i < AL_SRDS_NUM_LANES; i++)
		al_reg_write32(&regs_base->lane[i].ipd_multi, 0);

	return 0;
}

/******************************************************************************/
/******************************************************************************/
int al_serdes_hssp_group_cfg_off_bp(
	struct al_serdes_grp_obj	*grp_obj)
{
	struct al_serdes_regs __iomem	*regs_base = grp_obj->regs_base;
	int i;

	/* Set SerDes in multi mode */
	al_reg_write32(&regs_base->gen.ictl_pcs , 0);

	/* Individual Synthesizer (PD) power-down control */
	al_reg_write32(&regs_base->gen.ipd_multi_synth, 0);

	/* SerDes Reset */
	al_reg_write32(&regs_base->gen.irst, 0x1000);

	/* Power Down per lane */
	for (i = 0; i < AL_SRDS_NUM_LANES; i++)
		al_reg_write32(&regs_base->lane[i].ipd_multi, 0);

	return 0;
}

/******************************************************************************/
/******************************************************************************/
int al_serdes_hssp_group_cfg_sata_mode(
	struct al_serdes_grp_obj	*grp_obj,
	int				skip_core_init,
	uint32_t			ictl_pma_val,
	enum al_serdes_clk_freq		core_clk_freq,
	al_bool				ssc_en)
{
	struct al_serdes_regs __iomem	*regs_base = grp_obj->regs_base;
	int status = 0;

	/*PHY_IRST_MULTI_HARD_TXRX_B_A From IF*/
	al_reg_write32(&regs_base->gen.irst, 0x0);
	/**
	 * PHY_ICTL_MULTI_TXRATE_,PHY_ICTL_MULTI_TXRATE_,
	 * PHY_ICTL_MULTI_PSTATE_ from if
	 **/
	al_reg_write32(&regs_base->lane[0].ictl_multi, 0x30990034);
	al_reg_write32(&regs_base->lane[1].ictl_multi, 0x30990034);
	al_reg_write32(&regs_base->lane[2].ictl_multi, 0x30990034);
	al_reg_write32(&regs_base->lane[3].ictl_multi, 0x30990034);
	/**
	 * PHY_ICTL_MULTI_LB_RX2TXUNTIMEDEN_NT,
	 * PHY_ICTL_MULTI_LB_TX2RXBUFTIMEDEN_NT from IF
	 **/
	al_reg_write32(&regs_base->lane[0].ictl_multi_lb, 0x300);
	al_reg_write32(&regs_base->lane[1].ictl_multi_lb, 0x300);
	al_reg_write32(&regs_base->lane[2].ictl_multi_lb, 0x300);
	al_reg_write32(&regs_base->lane[3].ictl_multi_lb, 0x300);
	/*PHY_IDAT_MULTI_TXELECIDLE_ from IF*/
	al_reg_write32(&regs_base->lane[0].idat_multi, 0x10);
	al_reg_write32(&regs_base->lane[1].idat_multi, 0x10);
	al_reg_write32(&regs_base->lane[2].idat_multi, 0x10);
	al_reg_write32(&regs_base->lane[3].idat_multi, 0x10);
	/*SERDES Init Sequence*/
	al_reg_write32(&regs_base->gen.irst, 0x1000);
	al_serdes_ns_delay(800);
	al_reg_write32(&regs_base->gen.irst, 0x0);
	al_serdes_ns_delay(500);
	al_reg_write32(&regs_base->gen.irst, 0x1000);
	al_serdes_ns_delay(500);
	al_reg_write32(&regs_base->gen.ipd_multi_synth , 0x0001);
	/*IPD*/
	al_reg_write32(&regs_base->gen.ipd_multi_synth , 0x0001);
	al_reg_write32(&regs_base->lane[0].ipd_multi, 0x0003);
	al_reg_write32(&regs_base->lane[1].ipd_multi, 0x0003);
	al_reg_write32(&regs_base->lane[2].ipd_multi, 0x0003);
	al_reg_write32(&regs_base->lane[3].ipd_multi, 0x0003);

	if (!skip_core_init) {
		switch (core_clk_freq) {
		case AL_SRDS_CLK_FREQ_125_MHZ:
			al_serdes_group_cfg_WrReg_SATA_125_Extra_Config_4lane(grp_obj);

			if (ssc_en == AL_TRUE) {
				/* SYNTHFDIV_SSCMAXCODE */
				al_serdes_grp_reg_write(
					grp_obj,
					AL_SRDS_REG_PAGE_4_COMMON,
					AL_SRDS_REG_TYPE_PMA,
					0x32,
					0xfc);
				al_serdes_grp_reg_write(
					grp_obj,
					AL_SRDS_REG_PAGE_4_COMMON,
					AL_SRDS_REG_TYPE_PMA,
					0x33,
					0x40);

				/* SYNTHFDIV_SSCSTEPSIZE */
				al_serdes_grp_reg_write(
					grp_obj,
					AL_SRDS_REG_PAGE_4_COMMON,
					AL_SRDS_REG_TYPE_PMA,
					0x34,
					0xf0);

				/* SYNTHFDIV_SSCUPDATECYCLE */
				al_serdes_grp_reg_write(
					grp_obj,
					AL_SRDS_REG_PAGE_4_COMMON,
					AL_SRDS_REG_TYPE_PMA,
					0x35,
					0x20);

				/*
				 * SYNTHFDIV_MODULATOREN, SYNTHFDIV_SSCGENEN
				 * Enable the SSC modulation
				 */
				al_serdes_grp_reg_masked_write(
					grp_obj,
					AL_SRDS_REG_PAGE_4_COMMON,
					AL_SRDS_REG_TYPE_PMA,
					0x36,
					0x03,
					0x03);

				/*
				 * SYNTHVCO_PROPGAINC_MUXD 0/1
				 * Change PLL Loop bandwidth to much narrower
				 * setting (2), adequate for SSC
				 */
				al_serdes_grp_reg_write(
					grp_obj,
					AL_SRDS_REG_PAGE_4_COMMON,
					AL_SRDS_REG_TYPE_PMA,
					0xd5,
					0x22);

				/*
				 * SYNTHFBDIV_BYPASSFDIV
				 * Enable PLL won't lock to the freq and avoid
				 * jitter and spurs
				 */
				al_serdes_grp_reg_masked_write(
					grp_obj,
					AL_SRDS_REG_PAGE_4_COMMON,
					AL_SRDS_REG_TYPE_PMA,
					0x2ca,
					0x01,
					0x00);
			}

			break;

		case AL_SRDS_CLK_FREQ_100_MHZ:
			al_serdes_group_cfg_WrReg_SATA_100_Extra_Config_4lane(grp_obj);

			if (ssc_en == AL_TRUE) {
				/* SYNTHFDIV_SSCMAXCODE */
				al_serdes_grp_reg_write(
					grp_obj,
					AL_SRDS_REG_PAGE_4_COMMON,
					AL_SRDS_REG_TYPE_PMA,
					0x32,
					0xfb);
				al_serdes_grp_reg_write(
					grp_obj,
					AL_SRDS_REG_PAGE_4_COMMON,
					AL_SRDS_REG_TYPE_PMA,
					0x33,
					0x50);

				/* SYNTHFDIV_SSCSTEPSIZE */
				al_serdes_grp_reg_write(
					grp_obj,
					AL_SRDS_REG_PAGE_4_COMMON,
					AL_SRDS_REG_TYPE_PMA,
					0x34,
					0xf0);

				/* SYNTHFDIV_SSCUPDATECYCLE */
				al_serdes_grp_reg_write(
					grp_obj,
					AL_SRDS_REG_PAGE_4_COMMON,
					AL_SRDS_REG_TYPE_PMA,
					0x35,
					0x15);

				/*
				 * SYNTHFDIV_MODULATOREN, SYNTHFDIV_SSCGENEN
				 * Enable the SSC modulation
				 */
				al_serdes_grp_reg_masked_write(
					grp_obj,
					AL_SRDS_REG_PAGE_4_COMMON,
					AL_SRDS_REG_TYPE_PMA,
					0x36,
					0x03,
					0x03);

				/*
				 * SYNTHVCO_PROPGAINC_MUXD 0/1
				 * Change PLL Loop bandwidth to much narrower
				 * setting (2), adequate for SSC
				 */
				al_serdes_grp_reg_write(
					grp_obj,
					AL_SRDS_REG_PAGE_4_COMMON,
					AL_SRDS_REG_TYPE_PMA,
					0xd5,
					0x22);

				/*
				 * SYNTHFBDIV_BYPASSFDIV
				 * Enable PLL won't lock to the freq and avoid
				 * jitter and spurs
				 */
				al_serdes_grp_reg_masked_write(
					grp_obj,
					AL_SRDS_REG_PAGE_4_COMMON,
					AL_SRDS_REG_TYPE_PMA,
					0x2ca,
					0x01,
					0x00);
			}

			break;

		default:
			al_err(
				"%s: invalid core clock freq (%d)\n",
				__func__,
				core_clk_freq);
			status = -EINVAL;
			return -EINVAL;
		}
	}

	/* RX lost of signal detector enable */
	al_serdes_grp_reg_masked_write(
		grp_obj,
		AL_SRDS_REG_PAGE_4_COMMON,
		AL_SRDS_REG_TYPE_PMA,
		SERDES_IREG_FLD_RXLOSDET_ENABLE_REG_NUM,
		SERDES_IREG_FLD_RXLOSDET_ENABLE,
		SERDES_IREG_FLD_RXLOSDET_ENABLE);

	/* Set LOS detect threshold level */
	al_serdes_grp_reg_masked_write(
		grp_obj,
		AL_SRDS_REG_PAGE_4_COMMON,
		AL_SRDS_REG_TYPE_PMA,
		SERDES_IREG_FLD_RXLOSDET_THRESH_REG_NUM,
		SERDES_IREG_FLD_RXLOSDET_THRESH_MASK,
		3 << SERDES_IREG_FLD_RXLOSDET_THRESH_SHIFT);

	/* PMA_TX_EN*/
	al_reg_write32(
		&regs_base->gen.ictl_pma ,
		ictl_pma_val | SERDES_GEN_ICTL_PMA_TXENABLE_A);

	/* ICTL_PCS_EN_NT = 0 (Multi)*/
	al_reg_write32(&regs_base->gen.ictl_pcs , 0);

	/* TXDRV override enable - clear bit 5 */
	al_serdes_grp_reg_write(
		grp_obj,
		AL_SRDS_REG_PAGE_0123_LANES_0123,
		AL_SRDS_REG_TYPE_PMA,
		87,
		0x1f);

	/*Enable comma in serdes pcs*/
	al_serdes_grp_reg_write(
		grp_obj,
		AL_SRDS_REG_PAGE_4_COMMON,
		AL_SRDS_REG_TYPE_PCS,
		0x2e,
		0x00a3);

	al_serdes_grp_reg_write(
		grp_obj,
		AL_SRDS_REG_PAGE_4_COMMON,
		AL_SRDS_REG_TYPE_PCS,
		0x30,
		0x0053);

	al_reg_write32(&regs_base->gen.irst, 0x11f0);
	al_serdes_ns_delay(500);

	/*
	 * Rx rate change software flow - begin
	 */

	/*
	 * Write lane PMA register in offset 201
	 * with below bits values:
	 *	b0: RSTPDOVR_RX_AETRREGRX_DROPLEV = 0
	 *	b1: RSTPDOVR_RX_AETRRXPHD_MUTE = 0
	 *	b2: RSTPDOVR_RX_AETRRX_CDRFBDIVCKEN = 1
	 *	b3: RSTPDOVR_RX_AETRRX_TERMHIZ_EN = 1
	 *	b4: RSTPDOVR_RX_APDREGRX = 1
	 *	b5: RSTPDOVR_RX_APDRXIASMIRROR = 1
	 *	b6: RSTPDOVR_RX_APDRX_DFE = 1
	 *	b7: RSTPDOVR_RX_APDRX_HIFREQAGC = 1
	 */
	al_serdes_grp_reg_write(
			grp_obj, AL_SRDS_REG_PAGE_0123_LANES_0123, AL_SRDS_REG_TYPE_PMA,
			201, 0xfc);
	/*
	 * Write lane PMA register in offset 202
	 * with below bits values:
	 *	b0: RSTPDOVR_RX_APDRX_LOSDET = 1
	 *	b1: RSTPDOVR_RX_APDRX_ROAMCOMP = 1
	 *	b2: RSTPDOVR_RX_APDRX_S2PA = 1
	 *	b3: RSTPDOVR_RX_APDRX_S2PB = 1
	 *	b4: RSTPDOVR_RX_APDRX_SIGDET = 1
	 *	b5: RSTPDOVR_RX_APDRX_VCO = 1
	 *	b6: RSTPDOVR_RX_ARSTRX_CDRFBDIV = 1
	 *	b7: RSTPDOVR_RX_ARSTRX_PDET = 1
	 */
	al_serdes_grp_reg_write(
			grp_obj, AL_SRDS_REG_PAGE_0123_LANES_0123, AL_SRDS_REG_TYPE_PMA,
			202, 0xff);
	/*
	 * Write lane PMA register in offset 203
	 * with below bits values:
	 *	b0: RSTPDOVR_RX_ARSTRX_PFD = 1
	 *	b1: RSTPDOVR_RX_ARSTRX_REFDIV = 1
	 *	b2: RSTPDOVR_RX_ARSTRX_S2PA = 1
	 *	b3: RSTPDOVR_RX_ARSTRX_S2PB = 1
	 *	b4: RSTPDOVR_RX_ARSTRX_VCO = 1
	 *	b5: RSTPDOVR_RX_CLKGENMUXSELPCSRXWORD_KEEPALIVESEL = 1
	 *	b6: RSTPDOVR_RX_CLKGENMUXSELREFRX_KEEPALIVESEL = 1
	 *	b7: RSTPDOVR_RX_DRSTRX_CALDUTYFSM = 1
	 */
	al_serdes_grp_reg_write(
			grp_obj, AL_SRDS_REG_PAGE_0123_LANES_0123, AL_SRDS_REG_TYPE_PMA,
			203, 0xff);
	/*
	 * Write lane PMA register in offset 204
	 * with below bits values:
	 *	b0: RSTPDOVR_RX_DRSTRX_CALDUTYMEASCYCLE = 1
	 *	b1: RSTPDOVR_RX_DRSTRX_CALFOSCFSM = 1
	 *	b2: RSTPDOVR_RX_DRSTRX_CALFOSCMEASCYCLE = 1
	 *	b3: RSTPDOVR_RX_DRSTRX_CALOFFSETFSM = 1
	 *	b4: RSTPDOVR_RX_DRSTRX_CALOFFSETMEASCYCLE = 1
	 *	b5: RSTPDOVR_RX_DRSTRX_CALROAMDELAYFSM = 1
	 *	b6: RSTPDOVR_RX_DRSTRX_CALROAMDELAYMEASCYCLE = 1
	 *	b7: RSTPDOVR_RX_DRSTRX_CALROAMEYEMEASCYCLE = 1
	 */
	al_serdes_grp_reg_write(
			grp_obj, AL_SRDS_REG_PAGE_0123_LANES_0123, AL_SRDS_REG_TYPE_PMA,
			204, 0xff);
	/*
	 * Write lane PMA register in offset 205
	 * with below bits values:
	 *	b0: RSTPDOVR_RX_DRSTRX_DATAPATHA = 1
	 *	b1: RSTPDOVR_RX_DRSTRX_DATAPATHB = 1
	 *	b2: RSTPDOVR_RX_DRSTRX_DPIF = 1
	 *	b3: RSTPDOVR_RX_DRSTRX_EYEDIAGFSM = 1
	 *	b4: RSTPDOVR_RX_DRSTRX_FBDIVSLIP = 1
	 *	b5: RSTPDOVR_RX_DRSTRX_PPM = 1
	 *	b6: RSTPDOVR_RX_DRSTRX_SIGDET = 1
	 *	b7: RSTPDOVR_RX_OVREN = 0
	 */
	al_serdes_grp_reg_write(
			grp_obj, AL_SRDS_REG_PAGE_0123_LANES_0123, AL_SRDS_REG_TYPE_PMA,
			205, 0x7f);
	/* Enable RX OVR by writting lane PMA register in offset 205
	 * with setted bit7
	 *	b0: RSTPDOVR_RX_DRSTRX_DATAPATHA = 1
	 *	b1: RSTPDOVR_RX_DRSTRX_DATAPATHB = 1
	 *	b2: RSTPDOVR_RX_DRSTRX_DPIF = 1
	 *	b3: RSTPDOVR_RX_DRSTRX_EYEDIAGFSM = 1
	 *	b4: RSTPDOVR_RX_DRSTRX_FBDIVSLIP = 1
	 *	b5: RSTPDOVR_RX_DRSTRX_PPM = 1
	 *	b6: RSTPDOVR_RX_DRSTRX_SIGDET = 1
	 *	b7: RSTPDOVR_RX_OVREN = 1
	 */
	al_serdes_grp_reg_write(
			grp_obj, AL_SRDS_REG_PAGE_0123_LANES_0123, AL_SRDS_REG_TYPE_PMA,
			205, 0xff);

	al_serdes_ns_delay(500);

	/*
	 * Rx rate change software flow - end
	 */

	return status;
}

/******************************************************************************/
/******************************************************************************/
int al_serdes_hssp_group_cfg_pcie3_mode(
	struct al_serdes_grp_obj	*grp_obj,
	int				skip_core_init,
	uint32_t			ictl_pma_val,
	int				inhibit_gen3,
	int				x8_lanes_4_to_7,
	al_bool				override_agc_ac_boost,
	uint8_t				override_agc_ac_boost_val)
{
	struct al_serdes_regs __iomem	*regs_base = grp_obj->regs_base;
	int status = 0;

	/*PCIE - Group 1 (x4)*/
	al_serdes_ns_delay(100);
	al_reg_write32(&regs_base->gen.irst, 0xF1000);
	al_serdes_ns_delay(800);
	al_reg_write32(&regs_base->gen.irst, 0xF0000);
	al_serdes_ns_delay(500);
	al_reg_write32(&regs_base->gen.irst, 0xF1000);
	al_serdes_ns_delay(500);

	if (!skip_core_init)
		al_serdes_group_cfg_WrReg_PCIE3_Extra_Config_4lane(grp_obj);

	/* Inhibit gen3 */
	if (inhibit_gen3)
		al_serdes_grp_reg_write(grp_obj,
			AL_SRDS_REG_PAGE_0123_LANES_0123,
			AL_SRDS_REG_TYPE_PMA, 108, 5);

	/* Set RX preset hint table */
	al_serdes_grp_reg_masked_write(
		grp_obj, AL_SRDS_REG_PAGE_4_COMMON, AL_SRDS_REG_TYPE_PMA,
		26, 3 << 4, 0);
	al_serdes_grp_reg_write(
		grp_obj, AL_SRDS_REG_PAGE_4_COMMON, AL_SRDS_REG_TYPE_PCS,
		22, 1);
	al_serdes_grp_reg_write(
		grp_obj, AL_SRDS_REG_PAGE_4_COMMON, AL_SRDS_REG_TYPE_PCS,
		23, 0);
	al_serdes_grp_reg_masked_write(
		grp_obj, AL_SRDS_REG_PAGE_4_COMMON, AL_SRDS_REG_TYPE_PCS,
		34, 0x7f, 1);

	/* Override block align control register to zero */
	al_serdes_grp_reg_masked_write(
		grp_obj, AL_SRDS_REG_PAGE_0_LANE_0, AL_SRDS_REG_TYPE_PCS,
		7, 0x03, 2);
	al_serdes_grp_reg_masked_write(
		grp_obj, AL_SRDS_REG_PAGE_1_LANE_1, AL_SRDS_REG_TYPE_PCS,
		7, 0x03, 2);
	al_serdes_grp_reg_masked_write(
		grp_obj, AL_SRDS_REG_PAGE_2_LANE_2, AL_SRDS_REG_TYPE_PCS,
		7, 0x03, 2);
	al_serdes_grp_reg_masked_write(
		grp_obj, AL_SRDS_REG_PAGE_3_LANE_3, AL_SRDS_REG_TYPE_PCS,
		7, 0x03, 2);

	/* Override default PCS EqCal entry#0 with a custom HIFREQAGCCAP value */
	if (override_agc_ac_boost)
		al_serdes_grp_reg_masked_write(
			grp_obj, AL_SRDS_REG_PAGE_4_COMMON, AL_SRDS_REG_TYPE_PCS,
			SERDES_IREG_FLD_PCS_VPCSEQ_HIFREQAGCCAP_LUP0_REG_NUM,
			SERDES_IREG_FLD_PCS_VPCSEQ_HIFREQAGCCAP_LUP0_MASK,
			(override_agc_ac_boost_val
					<< SERDES_IREG_FLD_PCS_VPCSEQ_HIFREQAGCCAP_LUP0_SHIFT));

	/* PMA_TX_EN*/
	al_reg_write32(
		&regs_base->gen.ictl_pma,
		ictl_pma_val | SERDES_GEN_ICTL_PMA_TXENABLE_A |
		((x8_lanes_4_to_7) ?
		SERDES_GEN_ICTL_PMA_TXENABLE_A_SRC_MASTER :
		SERDES_GEN_ICTL_PMA_TXENABLE_A_SRC_THIS));

	/* ICTL_PCS_EN_NT = 1 (PIPE)*/
	al_reg_write32(&regs_base->gen.ictl_pcs , 1);

	al_reg_write32(&regs_base->gen.irst, 0xF1100);
	al_serdes_ns_delay(500);

	/*
	 * Rx rate change software flow - begin
	 */

	if (inhibit_gen3) {
		/*
		 * Write lane PMA register in offset 201
		 * with below bits values:
		 *	b0: RSTPDOVR_RX_AETRREGRX_DROPLEV = 0
		 *	b1: RSTPDOVR_RX_AETRRXPHD_MUTE = 0
		 *	b2: RSTPDOVR_RX_AETRRX_CDRFBDIVCKEN = 1
		 *	b3: RSTPDOVR_RX_AETRRX_TERMHIZ_EN = 1
		 *	b4: RSTPDOVR_RX_APDREGRX = 1
		 *	b5: RSTPDOVR_RX_APDRXIASMIRROR = 1
		 *	b6: RSTPDOVR_RX_APDRX_DFE = 1
		 *	b7: RSTPDOVR_RX_APDRX_HIFREQAGC = 1
		 */
		al_serdes_grp_reg_write(
				grp_obj, AL_SRDS_REG_PAGE_0123_LANES_0123, AL_SRDS_REG_TYPE_PMA,
				201, 0xfc);
		/*
		 * Write lane PMA register in offset 202
		 * with below bits values:
		 *	b0: RSTPDOVR_RX_APDRX_LOSDET = 1
		 *	b1: RSTPDOVR_RX_APDRX_ROAMCOMP = 1
		 *	b2: RSTPDOVR_RX_APDRX_S2PA = 1
		 *	b3: RSTPDOVR_RX_APDRX_S2PB = 1
		 *	b4: RSTPDOVR_RX_APDRX_SIGDET = 1
		 *	b5: RSTPDOVR_RX_APDRX_VCO = 1
		 *	b6: RSTPDOVR_RX_ARSTRX_CDRFBDIV = 1
		 *	b7: RSTPDOVR_RX_ARSTRX_PDET = 1
		 */
		al_serdes_grp_reg_write(
				grp_obj, AL_SRDS_REG_PAGE_0123_LANES_0123, AL_SRDS_REG_TYPE_PMA,
				202, 0xff);
		/*
		 * Write lane PMA register in offset 203
		 * with below bits values:
		 *	b0: RSTPDOVR_RX_ARSTRX_PFD = 1
		 *	b1: RSTPDOVR_RX_ARSTRX_REFDIV = 1
		 *	b2: RSTPDOVR_RX_ARSTRX_S2PA = 1
		 *	b3: RSTPDOVR_RX_ARSTRX_S2PB = 1
		 *	b4: RSTPDOVR_RX_ARSTRX_VCO = 1
		 *	b5: RSTPDOVR_RX_CLKGENMUXSELPCSRXWORD_KEEPALIVESEL = 1
		 *	b6: RSTPDOVR_RX_CLKGENMUXSELREFRX_KEEPALIVESEL = 1
		 *	b7: RSTPDOVR_RX_DRSTRX_CALDUTYFSM = 1
		 */
		al_serdes_grp_reg_write(
				grp_obj, AL_SRDS_REG_PAGE_0123_LANES_0123, AL_SRDS_REG_TYPE_PMA,
				203, 0xff);
		/*
		 * Write lane PMA register in offset 204
		 * with below bits values:
		 *	b0: RSTPDOVR_RX_DRSTRX_CALDUTYMEASCYCLE = 1
		 *	b1: RSTPDOVR_RX_DRSTRX_CALFOSCFSM = 1
		 *	b2: RSTPDOVR_RX_DRSTRX_CALFOSCMEASCYCLE = 1
		 *	b3: RSTPDOVR_RX_DRSTRX_CALOFFSETFSM = 1
		 *	b4: RSTPDOVR_RX_DRSTRX_CALOFFSETMEASCYCLE = 1
		 *	b5: RSTPDOVR_RX_DRSTRX_CALROAMDELAYFSM = 1
		 *	b6: RSTPDOVR_RX_DRSTRX_CALROAMDELAYMEASCYCLE = 1
		 *	b7: RSTPDOVR_RX_DRSTRX_CALROAMEYEMEASCYCLE = 1
		 */
		al_serdes_grp_reg_write(
				grp_obj, AL_SRDS_REG_PAGE_0123_LANES_0123, AL_SRDS_REG_TYPE_PMA,
				204, 0xff);
		/*
		 * Write lane PMA register in offset 205
		 * with below bits values:
		 *	b0: RSTPDOVR_RX_DRSTRX_DATAPATHA = 1
		 *	b1: RSTPDOVR_RX_DRSTRX_DATAPATHB = 1
		 *	b2: RSTPDOVR_RX_DRSTRX_DPIF = 1
		 *	b3: RSTPDOVR_RX_DRSTRX_EYEDIAGFSM = 1
		 *	b4: RSTPDOVR_RX_DRSTRX_FBDIVSLIP = 1
		 *	b5: RSTPDOVR_RX_DRSTRX_PPM = 1
		 *	b6: RSTPDOVR_RX_DRSTRX_SIGDET = 1
		 *	b7: RSTPDOVR_RX_OVREN = 0
		 */
		al_serdes_grp_reg_write(
				grp_obj, AL_SRDS_REG_PAGE_0123_LANES_0123, AL_SRDS_REG_TYPE_PMA,
				205, 0x7f);
		/* Enable RX OVR by writting lane PMA register in offset 205
		 * with setted bit7
		 *	b0: RSTPDOVR_RX_DRSTRX_DATAPATHA = 1
		 *	b1: RSTPDOVR_RX_DRSTRX_DATAPATHB = 1
		 *	b2: RSTPDOVR_RX_DRSTRX_DPIF = 1
		 *	b3: RSTPDOVR_RX_DRSTRX_EYEDIAGFSM = 1
		 *	b4: RSTPDOVR_RX_DRSTRX_FBDIVSLIP = 1
		 *	b5: RSTPDOVR_RX_DRSTRX_PPM = 1
		 *	b6: RSTPDOVR_RX_DRSTRX_SIGDET = 1
		 *	b7: RSTPDOVR_RX_OVREN = 1
		 */
		al_serdes_grp_reg_write(
				grp_obj, AL_SRDS_REG_PAGE_0123_LANES_0123, AL_SRDS_REG_TYPE_PMA,
				205, 0xff);

		al_serdes_ns_delay(500);
	}

	/*
	 * Rx rate change software flow - end
	 */

	/* Addition for better Rx equalization - start */
	al_serdes_grp_reg_masked_write(
				grp_obj,
				AL_SRDS_REG_PAGE_4_COMMON,
				AL_SRDS_REG_TYPE_PCS,
				SERDES_IREG_FLD_PCS_RXEQ_LOOKUP_CODE_EN_REG_NUM,
				SERDES_IREG_FLD_PCS_RXEQ_LOOKUP_CODE_EN_MASK,
				(0x1 << SERDES_IREG_FLD_PCS_RXEQ_LOOKUP_CODE_EN_SHIFT));

	al_serdes_grp_reg_masked_write(
				grp_obj,
				AL_SRDS_REG_PAGE_4_COMMON,
				AL_SRDS_REG_TYPE_PCS,
				SERDES_IREG_FLD_PCS_RXEQ_LOOKUP_LASTCODE_REG_NUM,
				SERDES_IREG_FLD_PCS_RXEQ_LOOKUP_LASTCODE_MASK,
				(0 << SERDES_IREG_FLD_PCS_RXEQ_LOOKUP_LASTCODE_SHIFT));

	al_serdes_grp_reg_masked_write(
				grp_obj,
				AL_SRDS_REG_PAGE_4_COMMON,
				AL_SRDS_REG_TYPE_PCS,
				SERDES_IREG_FLD_PCS_RXEQ_COARSE_RUN1_MASK_REG_NUM,
				SERDES_IREG_FLD_PCS_RXEQ_COARSE_RUN1_MASK_MASK,
				(0x4 << SERDES_IREG_FLD_PCS_RXEQ_COARSE_RUN1_MASK_SHIFT));

	al_serdes_grp_reg_masked_write(
				grp_obj,
				AL_SRDS_REG_PAGE_4_COMMON,
				AL_SRDS_REG_TYPE_PCS,
				SERDES_IREG_FLD_PCS_RXEQ_COARSE_RUN2_MASK_REG_NUM,
				SERDES_IREG_FLD_PCS_RXEQ_COARSE_RUN2_MASK_MASK,
				(0 << SERDES_IREG_FLD_PCS_RXEQ_COARSE_RUN2_MASK_SHIFT));

	al_serdes_grp_reg_masked_write(
				grp_obj,
				AL_SRDS_REG_PAGE_4_COMMON,
				AL_SRDS_REG_TYPE_PCS,
				SERDES_IREG_FLD_PCS_RXEQ_COARSE_STEP_REG_NUM,
				SERDES_IREG_FLD_PCS_RXEQ_COARSE_STEP_MASK,
				(0x1 << SERDES_IREG_FLD_PCS_RXEQ_COARSE_STEP_SHIFT));

	al_serdes_grp_reg_masked_write(
				grp_obj,
				AL_SRDS_REG_PAGE_4_COMMON,
				AL_SRDS_REG_TYPE_PCS,
				SERDES_IREG_FLD_PCS_RXEQ_COARSE_ITER_NUM_REG_NUM,
				SERDES_IREG_FLD_PCS_RXEQ_COARSE_ITER_NUM_MASK,
				(0x1 << SERDES_IREG_FLD_PCS_RXEQ_COARSE_ITER_NUM_SHIFT));

	al_serdes_grp_reg_masked_write(
				grp_obj,
				AL_SRDS_REG_PAGE_4_COMMON,
				AL_SRDS_REG_TYPE_PCS,
				SERDES_IREG_FLD_PCS_RXEQ_FINE_RUN1_MASK_REG_NUM,
				SERDES_IREG_FLD_PCS_RXEQ_FINE_RUN1_MASK_MASK,
				(0x0 << SERDES_IREG_FLD_PCS_RXEQ_FINE_RUN1_MASK_SHIFT));

	al_serdes_grp_reg_masked_write(
				grp_obj,
				AL_SRDS_REG_PAGE_4_COMMON,
				AL_SRDS_REG_TYPE_PCS,
				SERDES_IREG_FLD_PCS_RXEQ_FINE_RUN2_MASK_REG_NUM,
				SERDES_IREG_FLD_PCS_RXEQ_FINE_RUN2_MASK_MASK,
				(0 << SERDES_IREG_FLD_PCS_RXEQ_FINE_RUN2_MASK_SHIFT));

	al_serdes_grp_reg_masked_write(
				grp_obj,
				AL_SRDS_REG_PAGE_4_COMMON,
				AL_SRDS_REG_TYPE_PCS,
				SERDES_IREG_FLD_PCS_RXEQ_FINE_STEP_REG_NUM,
				SERDES_IREG_FLD_PCS_RXEQ_FINE_STEP_MASK,
				(1 << SERDES_IREG_FLD_PCS_RXEQ_FINE_STEP_SHIFT));

	al_serdes_grp_reg_masked_write(
				grp_obj,
				AL_SRDS_REG_PAGE_4_COMMON,
				AL_SRDS_REG_TYPE_PCS,
				SERDES_IREG_FLD_PCS_RXEQ_FINE_ITER_NUM_REG_NUM,
				SERDES_IREG_FLD_PCS_RXEQ_FINE_ITER_NUM_MASK,
				(0x1 << SERDES_IREG_FLD_PCS_RXEQ_FINE_ITER_NUM_SHIFT));

	al_serdes_grp_reg_masked_write(
				grp_obj,
				AL_SRDS_REG_PAGE_4_COMMON,
				AL_SRDS_REG_TYPE_PMA,
				SERDES_IREG_FLD_RXCALEYEDIAGFSM_BERTHRESHOLD1_REG_NUM,
				SERDES_IREG_FLD_RXCALEYEDIAGFSM_BERTHRESHOLD1_MASK,
				(0 << SERDES_IREG_FLD_RXCALEYEDIAGFSM_BERTHRESHOLD1_SHIFT));

	al_serdes_grp_reg_masked_write(
				grp_obj,
				AL_SRDS_REG_PAGE_4_COMMON,
				AL_SRDS_REG_TYPE_PMA,
				SERDES_IREG_FLD_RXCALEYEDIAGFSM_BERTHRESHOLD2_REG_NUM,
				SERDES_IREG_FLD_RXCALEYEDIAGFSM_BERTHRESHOLD2_MASK,
				(0x14 << SERDES_IREG_FLD_RXCALEYEDIAGFSM_BERTHRESHOLD2_SHIFT));

	al_serdes_grp_reg_masked_write(
				grp_obj,
				AL_SRDS_REG_PAGE_4_COMMON,
				AL_SRDS_REG_TYPE_PMA,
				SERDES_IREG_FLD_RXCALEYEDIAGFSM_XVALCOARSE_REG_NUM,
				SERDES_IREG_FLD_RXCALEYEDIAGFSM_XVALCOARSE_MASK,
				(0x3 << SERDES_IREG_FLD_RXCALEYEDIAGFSM_XVALCOARSE_SHIFT));

	al_serdes_grp_reg_masked_write(
				grp_obj,
				AL_SRDS_REG_PAGE_4_COMMON,
				AL_SRDS_REG_TYPE_PMA,
				SERDES_IREG_FLD_RXCALEYEDIAGFSM_XVALFINE_REG_NUM,
				SERDES_IREG_FLD_RXCALEYEDIAGFSM_XVALFINE_MASK,
				(0x1 << SERDES_IREG_FLD_RXCALEYEDIAGFSM_XVALFINE_SHIFT));

	al_serdes_grp_reg_masked_write(
				grp_obj,
				AL_SRDS_REG_PAGE_4_COMMON,
				AL_SRDS_REG_TYPE_PMA,
				SERDES_IREG_FLD_RXCALEYEDIAGFSM_YVALCOARSE_REG_NUM,
				SERDES_IREG_FLD_RXCALEYEDIAGFSM_YVALCOARSE_MASK,
				(3 << SERDES_IREG_FLD_RXCALEYEDIAGFSM_YVALCOARSE_SHIFT));

	al_serdes_grp_reg_masked_write(
				grp_obj,
				AL_SRDS_REG_PAGE_4_COMMON,
				AL_SRDS_REG_TYPE_PMA,
				SERDES_IREG_FLD_RXCALEYEDIAGFSM_YVALFINE_REG_NUM,
				SERDES_IREG_FLD_RXCALEYEDIAGFSM_YVALFINE_MASK,
				(1 << SERDES_IREG_FLD_RXCALEYEDIAGFSM_YVALFINE_SHIFT));

	al_serdes_grp_reg_masked_write(
				grp_obj,
				AL_SRDS_REG_PAGE_4_COMMON,
				AL_SRDS_REG_TYPE_PMA,
				SERDES_IREG_FLD_EYE_DIAG_SAMPLE_CNT_MSB_REG_NUM,
				SERDES_IREG_FLD_EYE_DIAG_SAMPLE_CNT_MSB_MASK,
				(0x2 << SERDES_IREG_FLD_EYE_DIAG_SAMPLE_CNT_MSB_SHIFT));

	al_serdes_grp_reg_masked_write(
				grp_obj,
				AL_SRDS_REG_PAGE_4_COMMON,
				AL_SRDS_REG_TYPE_PMA,
				SERDES_IREG_FLD_EYE_DIAG_SAMPLE_CNT_LSB_REG_NUM,
				SERDES_IREG_FLD_EYE_DIAG_SAMPLE_CNT_LSB_MASK,
				(0x8a << SERDES_IREG_FLD_EYE_DIAG_SAMPLE_CNT_LSB_SHIFT));
	/* Addition for better Rx equalization - end */

	return status;
}

/******************************************************************************/
/******************************************************************************/
static void al_serdes_common_cfg_eth(struct al_serdes_grp_obj *grp_obj)
{
	al_serdes_grp_reg_masked_write(
				grp_obj,
				AL_SRDS_REG_PAGE_4_COMMON,
				AL_SRDS_REG_TYPE_PMA,
				SERDES_IREG_FLD_RXEQ_LOOKUP_CODE_EN_REG_NUM,
				SERDES_IREG_FLD_RXEQ_LOOKUP_CODE_EN_MASK,
				(0x1 << SERDES_IREG_FLD_RXEQ_LOOKUP_CODE_EN_SHIFT));

	al_serdes_grp_reg_masked_write(
				grp_obj,
				AL_SRDS_REG_PAGE_4_COMMON,
				AL_SRDS_REG_TYPE_PMA,
				SERDES_IREG_FLD_RXEQ_LOOKUP_LASTCODE_REG_NUM,
				SERDES_IREG_FLD_RXEQ_LOOKUP_LASTCODE_MASK,
				(0 << SERDES_IREG_FLD_RXEQ_LOOKUP_LASTCODE_SHIFT));

	al_serdes_grp_reg_masked_write(
				grp_obj,
				AL_SRDS_REG_PAGE_4_COMMON,
				AL_SRDS_REG_TYPE_PMA,
				SERDES_IREG_FLD_RXEQ_COARSE_RUN1_MASK_REG_NUM,
				SERDES_IREG_FLD_RXEQ_COARSE_RUN1_MASK_MASK,
				(0x2 << SERDES_IREG_FLD_RXEQ_COARSE_RUN1_MASK_SHIFT));

	al_serdes_grp_reg_masked_write(
				grp_obj,
				AL_SRDS_REG_PAGE_4_COMMON,
				AL_SRDS_REG_TYPE_PMA,
				SERDES_IREG_FLD_RXEQ_COARSE_RUN2_MASK_REG_NUM,
				SERDES_IREG_FLD_RXEQ_COARSE_RUN2_MASK_MASK,
				(0 << SERDES_IREG_FLD_RXEQ_COARSE_RUN2_MASK_SHIFT));

	al_serdes_grp_reg_masked_write(
				grp_obj,
				AL_SRDS_REG_PAGE_4_COMMON,
				AL_SRDS_REG_TYPE_PMA,
				SERDES_IREG_FLD_RXEQ_COARSE_STEP_REG_NUM,
				SERDES_IREG_FLD_RXEQ_COARSE_STEP_MASK,
				(0x1 << SERDES_IREG_FLD_RXEQ_COARSE_STEP_SHIFT));

	al_serdes_grp_reg_masked_write(
				grp_obj,
				AL_SRDS_REG_PAGE_4_COMMON,
				AL_SRDS_REG_TYPE_PMA,
				SERDES_IREG_FLD_RXEQ_COARSE_ITER_NUM_REG_NUM,
				SERDES_IREG_FLD_RXEQ_COARSE_ITER_NUM_MASK,
				(0x1 << SERDES_IREG_FLD_RXEQ_COARSE_ITER_NUM_SHIFT));

	al_serdes_grp_reg_masked_write(
				grp_obj,
				AL_SRDS_REG_PAGE_4_COMMON,
				AL_SRDS_REG_TYPE_PMA,
				SERDES_IREG_FLD_RXEQ_FINE_RUN1_MASK_REG_NUM,
				SERDES_IREG_FLD_RXEQ_FINE_RUN1_MASK_MASK,
				(0xf0 << SERDES_IREG_FLD_RXEQ_FINE_RUN1_MASK_SHIFT));

	al_serdes_grp_reg_masked_write(
				grp_obj,
				AL_SRDS_REG_PAGE_4_COMMON,
				AL_SRDS_REG_TYPE_PMA,
				SERDES_IREG_FLD_RXEQ_FINE_RUN2_MASK_REG_NUM,
				SERDES_IREG_FLD_RXEQ_FINE_RUN2_MASK_MASK,
				(0 << SERDES_IREG_FLD_RXEQ_FINE_RUN2_MASK_SHIFT));

	al_serdes_grp_reg_masked_write(
				grp_obj,
				AL_SRDS_REG_PAGE_4_COMMON,
				AL_SRDS_REG_TYPE_PMA,
				SERDES_IREG_FLD_RXEQ_FINE_STEP_REG_NUM,
				SERDES_IREG_FLD_RXEQ_FINE_STEP_MASK,
				(1 << SERDES_IREG_FLD_RXEQ_FINE_STEP_SHIFT));

	al_serdes_grp_reg_masked_write(
				grp_obj,
				AL_SRDS_REG_PAGE_4_COMMON,
				AL_SRDS_REG_TYPE_PMA,
				SERDES_IREG_FLD_RXEQ_FINE_ITER_NUM_REG_NUM,
				SERDES_IREG_FLD_RXEQ_FINE_ITER_NUM_MASK,
				(0x8 << SERDES_IREG_FLD_RXEQ_FINE_ITER_NUM_SHIFT));

	al_serdes_grp_reg_masked_write(
				grp_obj,
				AL_SRDS_REG_PAGE_4_COMMON,
				AL_SRDS_REG_TYPE_PMA,
				SERDES_IREG_FLD_RXCALEYEDIAGFSM_BERTHRESHOLD1_REG_NUM,
				SERDES_IREG_FLD_RXCALEYEDIAGFSM_BERTHRESHOLD1_MASK,
				(0 << SERDES_IREG_FLD_RXCALEYEDIAGFSM_BERTHRESHOLD1_SHIFT));

	al_serdes_grp_reg_masked_write(
				grp_obj,
				AL_SRDS_REG_PAGE_4_COMMON,
				AL_SRDS_REG_TYPE_PMA,
				SERDES_IREG_FLD_RXCALEYEDIAGFSM_BERTHRESHOLD2_REG_NUM,
				SERDES_IREG_FLD_RXCALEYEDIAGFSM_BERTHRESHOLD2_MASK,
				(0x64 << SERDES_IREG_FLD_RXCALEYEDIAGFSM_BERTHRESHOLD2_SHIFT));

	al_serdes_grp_reg_masked_write(
				grp_obj,
				AL_SRDS_REG_PAGE_4_COMMON,
				AL_SRDS_REG_TYPE_PMA,
				SERDES_IREG_FLD_RXCALEYEDIAGFSM_XVALCOARSE_REG_NUM,
				SERDES_IREG_FLD_RXCALEYEDIAGFSM_XVALCOARSE_MASK,
				(0x3 << SERDES_IREG_FLD_RXCALEYEDIAGFSM_XVALCOARSE_SHIFT));

	al_serdes_grp_reg_masked_write(
				grp_obj,
				AL_SRDS_REG_PAGE_4_COMMON,
				AL_SRDS_REG_TYPE_PMA,
				SERDES_IREG_FLD_RXCALEYEDIAGFSM_XVALFINE_REG_NUM,
				SERDES_IREG_FLD_RXCALEYEDIAGFSM_XVALFINE_MASK,
				(0x1 << SERDES_IREG_FLD_RXCALEYEDIAGFSM_XVALFINE_SHIFT));

	al_serdes_grp_reg_masked_write(
				grp_obj,
				AL_SRDS_REG_PAGE_4_COMMON,
				AL_SRDS_REG_TYPE_PMA,
				SERDES_IREG_FLD_RXCALEYEDIAGFSM_YVALCOARSE_REG_NUM,
				SERDES_IREG_FLD_RXCALEYEDIAGFSM_YVALCOARSE_MASK,
				(3 << SERDES_IREG_FLD_RXCALEYEDIAGFSM_YVALCOARSE_SHIFT));

	al_serdes_grp_reg_masked_write(
				grp_obj,
				AL_SRDS_REG_PAGE_4_COMMON,
				AL_SRDS_REG_TYPE_PMA,
				SERDES_IREG_FLD_RXCALEYEDIAGFSM_YVALFINE_REG_NUM,
				SERDES_IREG_FLD_RXCALEYEDIAGFSM_YVALFINE_MASK,
				(1 << SERDES_IREG_FLD_RXCALEYEDIAGFSM_YVALFINE_SHIFT));

	al_serdes_grp_reg_masked_write(
				grp_obj,
				AL_SRDS_REG_PAGE_4_COMMON,
				AL_SRDS_REG_TYPE_PMA,
				SERDES_IREG_FLD_EYE_DIAG_SAMPLE_CNT_MSB_REG_NUM,
				SERDES_IREG_FLD_EYE_DIAG_SAMPLE_CNT_MSB_MASK,
				(0xc << SERDES_IREG_FLD_EYE_DIAG_SAMPLE_CNT_MSB_SHIFT));

	al_serdes_grp_reg_masked_write(
				grp_obj,
				AL_SRDS_REG_PAGE_4_COMMON,
				AL_SRDS_REG_TYPE_PMA,
				SERDES_IREG_FLD_EYE_DIAG_SAMPLE_CNT_LSB_REG_NUM,
				SERDES_IREG_FLD_EYE_DIAG_SAMPLE_CNT_LSB_MASK,
				(0xcc << SERDES_IREG_FLD_EYE_DIAG_SAMPLE_CNT_LSB_SHIFT));
}

/******************************************************************************/
/******************************************************************************/
int al_serdes_hssp_group_cfg_eth_kr_mode(
	struct al_serdes_grp_obj	*grp_obj,
	int				skip_core_init,
	uint32_t			ictl_pma_val,
	enum al_serdes_clk_freq		core_clk_freq,
	al_bool				is_16_bit_interface)
{
	struct al_serdes_regs __iomem	*regs_base = grp_obj->regs_base;
	int status = 0;

	/*ETH Configurations:*/

	al_reg_write32(&regs_base->gen.irst, 0x000000);
	/*WIDTH/RATE*/
	if (is_16_bit_interface) {
		al_reg_write32(&regs_base->lane[0].ictl_multi, 0x20330020);
		al_reg_write32(&regs_base->lane[1].ictl_multi, 0x20330020);
		al_reg_write32(&regs_base->lane[2].ictl_multi, 0x20330020);
		al_reg_write32(&regs_base->lane[3].ictl_multi, 0x20330020);
	} else {
		al_reg_write32(&regs_base->lane[0].ictl_multi, 0x30330030);
		al_reg_write32(&regs_base->lane[1].ictl_multi, 0x30330030);
		al_reg_write32(&regs_base->lane[2].ictl_multi, 0x30330030);
		al_reg_write32(&regs_base->lane[3].ictl_multi, 0x30330030);
	}

	/*IPD*/
	al_reg_write32(&regs_base->gen.ipd_multi_synth , 0x0001);
	al_reg_write32(&regs_base->lane[0].ipd_multi, 0x0003);
	al_reg_write32(&regs_base->lane[1].ipd_multi, 0x0003);
	al_reg_write32(&regs_base->lane[2].ipd_multi, 0x0003);
	al_reg_write32(&regs_base->lane[3].ipd_multi, 0x0003);

	/* PMA_TX_EN*/
	al_reg_write32(
		&regs_base->gen.ictl_pma ,
		ictl_pma_val | SERDES_GEN_ICTL_PMA_TXENABLE_A);

	/* ICTL_PCS_EN_NT = 0 (Multi)*/
	al_reg_write32(&regs_base->gen.ictl_pcs , 0);

	al_reg_write32(&regs_base->gen.irst, 0x001000);
	al_serdes_ns_delay(800);
	al_reg_write32(&regs_base->gen.irst, 0x000000);
	al_serdes_ns_delay(500);
	al_reg_write32(&regs_base->gen.irst, 0x001000);
	al_serdes_ns_delay(500);

	switch (core_clk_freq) {
	case AL_SRDS_CLK_FREQ_125_MHZ:
		if (!skip_core_init)
			al_serdes_group_cfg_WrReg_KR_125_Extra_Config_4lane(
				grp_obj);
		break;

	case AL_SRDS_CLK_FREQ_156_MHZ:
		if (!skip_core_init)
			al_serdes_group_cfg_WrReg_KR_156_Extra_Config_4lane(
				grp_obj);
		break;

	default:
		al_err(
			"%s: invalid core clock freq (%d)\n",
			__func__,
			core_clk_freq);
		status = -EINVAL;
		goto done;
	}

	/* TXDRV override enable - clear bit 5 */
	al_serdes_grp_reg_write(
		grp_obj,
		AL_SRDS_REG_PAGE_0123_LANES_0123,
		AL_SRDS_REG_TYPE_PMA,
		87,
		0x1f);

	al_serdes_common_cfg_eth(grp_obj);

	al_reg_write32(&regs_base->gen.irst, 0x0011F0);
	al_serdes_ns_delay(500);

done:
	return status;
}

/******************************************************************************/
/******************************************************************************/
int al_serdes_hssp_group_cfg_eth_sgmii_mode(
	struct al_serdes_grp_obj	*grp_obj,
	int				skip_core_init,
	enum al_serdes_clk_freq		core_clk_freq,
	uint32_t			ictl_pma_val)
{
	struct al_serdes_regs __iomem	*regs_base = grp_obj->regs_base;
	int status = 0;

	/*ETH Configurations:*/

	al_reg_write32(&regs_base->gen.irst, 0x000000);
	/*WIDTH/RATE*/
	al_reg_write32(&regs_base->lane[0].ictl_multi, 0x10110010);
	al_reg_write32(&regs_base->lane[1].ictl_multi, 0x10110010);
	al_reg_write32(&regs_base->lane[2].ictl_multi, 0x10110010);
	al_reg_write32(&regs_base->lane[3].ictl_multi, 0x10110010);

	/*IPD*/
	al_reg_write32(&regs_base->gen.ipd_multi_synth , 0x0001);
	al_reg_write32(&regs_base->lane[0].ipd_multi, 0x0003);
	al_reg_write32(&regs_base->lane[1].ipd_multi, 0x0003);
	al_reg_write32(&regs_base->lane[2].ipd_multi, 0x0003);
	al_reg_write32(&regs_base->lane[3].ipd_multi, 0x0003);

	/* PMA_TX_EN*/
	al_reg_write32(
		&regs_base->gen.ictl_pma ,
		ictl_pma_val | SERDES_GEN_ICTL_PMA_TXENABLE_A);

	/* ICTL_PCS_EN_NT = 0 (Multi)*/
	al_reg_write32(&regs_base->gen.ictl_pcs , 0);

	al_reg_write32(&regs_base->gen.irst, 0x001000);
	al_serdes_ns_delay(800);
	al_reg_write32(&regs_base->gen.irst, 0x000000);
	al_serdes_ns_delay(500);
	al_reg_write32(&regs_base->gen.irst, 0x001000);
	al_serdes_ns_delay(500);

	if (!skip_core_init) {
		switch (core_clk_freq) {
		case AL_SRDS_CLK_FREQ_125_MHZ:
			al_serdes_group_cfg_WrReg_SGMII_125_Extra_Config_4lane(grp_obj);
			break;

		case AL_SRDS_CLK_FREQ_100_MHZ:
			al_serdes_group_cfg_WrReg_SGMII_100_Extra_Config_4lane(grp_obj);
			break;

		case AL_SRDS_CLK_FREQ_156_MHZ:
			al_serdes_group_cfg_WrReg_SGMII_156_Extra_Config_4lane(grp_obj);
			break;

		default:
			al_err(
				"%s: invalid core clock freq (%d)\n",
				__func__,
				core_clk_freq);
			status = -EINVAL;
			return -EINVAL;
		}
	}

	/* TXDRV override enable - clear bit 5 */
	al_serdes_grp_reg_write(
		grp_obj,
		AL_SRDS_REG_PAGE_0123_LANES_0123,
		AL_SRDS_REG_TYPE_PMA,
		87,
		0x1f);

	al_serdes_common_cfg_eth(grp_obj);

	al_reg_write32(&regs_base->gen.irst, 0x0011F0);
	al_serdes_ns_delay(500);

	return status;
}

int al_serdes_hssp_group_cfg_eth_sgmii_2_5g_mode(
	struct al_serdes_grp_obj	*grp_obj,
	int				skip_core_init,
	enum al_serdes_clk_freq		core_clk_freq,
	uint32_t			ictl_pma_val)
{
	struct al_serdes_regs __iomem	*regs_base = grp_obj->regs_base;
	int status = 0;

	/*ETH Configurations:*/

	al_reg_write32(&regs_base->gen.irst, 0x000000);
	/*WIDTH/RATE*/
	al_reg_write32(&regs_base->lane[0].ictl_multi, 0x10220010);
	al_reg_write32(&regs_base->lane[1].ictl_multi, 0x10220010);
	al_reg_write32(&regs_base->lane[2].ictl_multi, 0x10220010);
	al_reg_write32(&regs_base->lane[3].ictl_multi, 0x10220010);

	/*IPD*/
	al_reg_write32(&regs_base->gen.ipd_multi_synth , 0x0001);
	al_reg_write32(&regs_base->lane[0].ipd_multi, 0x0003);
	al_reg_write32(&regs_base->lane[1].ipd_multi, 0x0003);
	al_reg_write32(&regs_base->lane[2].ipd_multi, 0x0003);
	al_reg_write32(&regs_base->lane[3].ipd_multi, 0x0003);

	/* PMA_TX_EN*/
	al_reg_write32(
		&regs_base->gen.ictl_pma ,
		ictl_pma_val | SERDES_GEN_ICTL_PMA_TXENABLE_A);

	/* ICTL_PCS_EN_NT = 0 (Multi)*/
	al_reg_write32(&regs_base->gen.ictl_pcs , 0);

	al_reg_write32(&regs_base->gen.irst, 0x001000);
	al_serdes_ns_delay(800);
	al_reg_write32(&regs_base->gen.irst, 0x000000);
	al_serdes_ns_delay(500);
	al_reg_write32(&regs_base->gen.irst, 0x001000);
	al_serdes_ns_delay(500);

	if (!skip_core_init) {
		switch (core_clk_freq) {
		case AL_SRDS_CLK_FREQ_100_MHZ:
			al_serdes_group_cfg_WrReg_SGMII_2_5G_100_Extra_Config_4lane(grp_obj);
			break;

		case AL_SRDS_CLK_FREQ_156_MHZ:
			al_serdes_group_cfg_WrReg_SGMII_2_5G_156_Extra_Config_4lane(grp_obj);
			break;

		default:
			al_err(
				"%s: invalid core clock freq (%d)\n",
				__func__,
				core_clk_freq);
			status = -EINVAL;
			return -EINVAL;
		}
	}

	/* TXDRV override enable - clear bit 5 */
	al_serdes_grp_reg_write(
		grp_obj,
		AL_SRDS_REG_PAGE_0123_LANES_0123,
		AL_SRDS_REG_TYPE_PMA,
		87,
		0x1f);

	al_reg_write32(&regs_base->gen.irst, 0x0011F0);
	al_serdes_ns_delay(500);

	return status;
}

